// morphologicalDialogueGenerator.js

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// 1. Geli≈ümi≈ü Dinamik Kelime Havuzlarƒ± üöÄ
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
class DynamicLexicon {
    constructor() {
        this.baseWords = {
            subjects: ['bakteri', 'h√ºcre', 'gezgin', 'hayal', 'karƒ±nca', 'atom', '√ßi√ßek', 'balƒ±k', 'ruh', 'zihin', 'kalp', 'nefes', 'yƒ±ldƒ±z', 
                      'elektron', 'proton', 'molek√ºl', 'organizma', 'sistem', 'nesne', 'varlƒ±k', 'bilim', 'sanat', 'm√ºzik', 'renk', 'ƒ±≈üƒ±k', 'ses', 'hareket',
                      'doƒüa', 'evren', 'galaksi', 'gezegen', 'uydu', 'g√ºne≈ü', 'ay', 'toprak', 'deniz', 'nehir', 'daƒü', 'orman', 'aƒüa√ß', 'yaprak', 'meyve',
                      'hayvan', 'ku≈ü', 'kedi', 'k√∂pek', 'fil', 'kaplan', 'aslan', 'kartal', 'balina', 'yunus', 'kelebek', 'arƒ±', 'b√∂cek', 'solucan'],
            verbs: ['sentezliyor', 'ke≈üfediyor', 'dans ediyor', 'payla≈üƒ±yor', 'yƒ±ldƒ±zƒ± g√∂r√ºyor', 'm√ºzik yapƒ±yor', 'r√ºya kuruyor', 'titre≈üiyor', 'parƒ±ldƒ±yor', 'evrimle≈üiyor', 'fƒ±sƒ±ldƒ±yor', 'b√ºy√ºl√ºyor', 'uyanƒ±yor', 'hissediyor', 'anlƒ±yor',
                   'ko≈üuyor', 'u√ßuyor', 'y√ºz√ºyor', 'zƒ±plƒ±yor', 'd√∂k√ºyor', 'yakƒ±yor', 'soƒüutuyor', 'ƒ±sƒ±tƒ±yor', 'b√ºy√ºyor', 'k√º√ß√ºl√ºyor', 'deƒüi≈üiyor', 'd√∂n√º≈ü√ºyor',
                   '√∂ƒüreniyor', '√∂ƒüretiyor', 'ara≈ütƒ±rƒ±yor', 'buluyor', 'yaratƒ±yor', '√ºretiyor', 'tasarlƒ±yor', 'kurguluyor', 'hayali kuruyor', 'd√º≈ü√ºn√ºyor',
                   'seviyo–≥', 'nefret ediyor', 'kƒ±zƒ±yor', 'g√ºl√ºyor', 'aƒülƒ±yor', '≈üarkƒ± s√∂yl√ºyor', 'dans ediyor', 'oyunlar oynuyor', 'hikayeler anlatƒ±yor',
                   'ke≈üfediyor', 'geziyo–≥', 'maceralara atƒ±lƒ±yor', 'sava≈üƒ±yor', 'barƒ±≈ü yapƒ±yor', 'arkada≈ülƒ±k kuruyor', 'i≈übirliƒüi yapƒ±yor', 'yarƒ±≈üƒ±yor'],
            objects: ['enerji', 'dna', 'd√º≈ü√ºnce', 'vitamin', 'mineral', '≈üarkƒ±', 'renk', 'koku', 'anƒ±', 'gizem', 'umut', 'korku', 'sevgi',
                     'protein', 'karbohidrat', 'yaƒü', 'vitamin', 'enzim', 'hormon', 'antikor', 'gen', 'kromozom', 'ribozom', 'mitokondri', '√ßekirdek',
                     '√ßikolata', 'dondurma', 'kek', 'kurabiye', 'meyve', 'sebze', 'et', 'balƒ±k', 'tavuk', 's√ºt', 'peynir', 'ekmek', 'pasta', '≈üeker',
                     'kitap', 'film', 'oyun', 'm√ºzik', 'resim', 'heykel', 'dans', 'tiyatro', '≈üiir', 'hikaye', 'masal', 'efsane', 'r√ºya', 'hayal',
                     'a≈ük', 'dostluk', 'mutluluk', 'h√ºz√ºn', '√∂fke', 'korku', 'heyecan', 'merak', '≈üa≈ükƒ±nlƒ±k', 'gurur', 'utan√ß', 'pi≈ümanlƒ±k', '√∂zlem'],
            emotions: ['mutlu', 'meraklƒ±', '≈üa≈ükƒ±n', 'kararlƒ±', 'h√ºz√ºnl√º', 'heyecanlƒ±', 'sakin', 'endi≈üeli', 'umutlu', 'korkmu≈ü', '≈üefkatli', 'gururlu', 'utanga√ß', 'cesur', 'nazik',
                      'ne≈üeli', 'keyifli', 'rahat', 'huzurlu', 'memnun', 'tatmin olmu≈ü', '≈üanslƒ±', 'ba≈üarƒ±lƒ±', 'g√ºvenli', '√∂zg√ºr', 'yaratƒ±cƒ±', 'ilhamlƒ±',
                      '√ºzg√ºn', 'melankoli', 'kƒ±rƒ±k', 'yalnƒ±z', 'kayƒ±p', '√ßaresiz', 'umutsuz', 'bitkin', 'yorgun', 'stresli', 'gergin', 'sinirli',
                      '≈üa≈üƒ±rmƒ±≈ü', 'hayret', 'deh≈üet', 'panik', 'kaygƒ±lƒ±', 'tedirgin', 'ku≈ükulu', 'kararsƒ±z', '≈ü√ºpheli', 'endi≈üeli', 'korkutucu'],
            locations: ['laboratuvar', 'okyan√∫s', 'g√∂ky√ºz√º', 'yaprak', 'toprak', 'hava', 'su', 'ƒ±≈üƒ±k', 'g√∂lge', 'r√ºzgar', 'kalp', 'zihin', 'ev', 'yol', 'k√∂pr√º',
                       '≈üehir', 'kasaba', 'k√∂y', 'park', 'bah√ße', 'orman', 'daƒü', 'vadi', 'g√∂l', 'nehir', 'deniz', 'okyan√∫s', 'ada', 'yarƒ±mada', 'kƒ±ta',
                       'okul', 'hastane', 'k√ºt√ºphane', 'm√ºze', 'tiyatro', 'sinema', 'restoran', 'kafe', 'market', 'd√ºkkan', 'fabrika', 'ofis', 'bina',
                       'uzay', 'galaksi', 'yƒ±ldƒ±z', 'gezegen', 'ay', 'g√ºne≈ü', 'd√ºnya', 'mars', 'ven√ºs', 'j√ºpiter', 'sat√ºrn', 'uran√ºs', 'nept√ºn'],
            conjunctions: ['ancak', 'ama', 'fakat', 'lakin', 'oysa', 've', 'ile', 'hem', 'ya da', 'veya', 'ki', '√ß√ºnk√º', 'zira', 'hatta', 'ayrƒ±ca',
                          'b√∂ylece', 'bundan dolayƒ±', 'bu nedenle', 'bu y√ºzden', 'sonu√ß olarak', '√∂zetle', 'kƒ±sacasƒ±', 'diƒüer taraftan', '√∂te yandan',
                          'benzer ≈üekilde', 'aynƒ± zamanda', 'bunun yanƒ±nda', 'buna ek olarak', 'dahasƒ±', '√ºstelik', 'hatta', 'bile', 'dahi'],
            intensifiers: ['√ßok', 'epey', 'olduk√ßa', 'fazlasƒ±yla', 'son derece', 'b√ºy√ºk √∂l√ß√ºde', 'hayli', 'bir hayli', 'gayet', 'pek',
                          'a≈üƒ±rƒ±', 'm√ºthi≈ü', 'inanƒ±lmaz', 'deh≈üet', 'korkun√ß', 'berbat', 'm√ºkemmel', 'harika', 'fantastik', 'olaƒüan√ºst√º',
                          'biraz', 'az', 'hafif', 'ufak', 'minimal', 'sƒ±nƒ±rlƒ±', 'kƒ±smen', 'kƒ±sa', 'uzun', 'devasa', 'mini', 'maksi'],
            temporal: ['≈üimdi', 'sonra', '√∂nce', 'hemen', 'yava≈ü√ßa', 'birden', 'aniden', 'derhal', 'zamanla', 'sonunda',
                      'ba≈ülangƒ±√ßta', 'ilk √∂nce', 'ilk ba≈üta', '√∂ncelikle', 'daha sonra', 'arkasƒ±ndan', 'pe≈üinden', 'devamƒ±nda',
                      'arada sƒ±rada', 'bazen', 'ara ara', 'zaman zaman', 's√ºrekli', 's√ºrekli olarak', 'devamlƒ±', 'hi√ß durmadan',
                      'd√ºn', 'bug√ºn', 'yarƒ±n', 'ge√ßmi≈üte', 'gelecekte', '≈üu anda', 'o sƒ±rada', 'o zaman', '≈üimdiye kadar']
        };
        
        this.dynamicWords = {
            subjects: new Set(),
            verbs: new Set(),
            objects: new Set(),
            emotions: new Set(),
            locations: new Set()
        };
        
        this.wordSuccessRates = new Map(); // Track success for adaptation
        this.contextFrequency = new Map(); // Track context usage
    }
    
    addDynamicWord(category, word, successRate = 0.5) {
        if (this.dynamicWords[category]) {
            this.dynamicWords[category].add(word);
            this.wordSuccessRates.set(word, successRate);
        }
    }
    
    getWords(category) {
        const base = this.baseWords[category] || [];
        const dynamic = Array.from(this.dynamicWords[category] || []);
        return [...base, ...dynamic];
    }
    
    updateWordSuccess(word, success) {
        const current = this.wordSuccessRates.get(word) || 0.5;
        const updated = (current * 0.8) + (success * 0.2); // Weighted update
        this.wordSuccessRates.set(word, updated);
    }
    
    getWordSuccess(word) {
        return this.wordSuccessRates.get(word) || 0.5;
    }
}

// Global dynamic lexicon instance
const dynamicLexicon = new DynamicLexicon();

// Backward compatibility
const LEXICON = {
    subjects: dynamicLexicon.getWords('subjects'),
    verbs: dynamicLexicon.getWords('verbs'),
    objects: dynamicLexicon.getWords('objects'),
    emotions: dynamicLexicon.getWords('emotions'),
    locations: dynamicLexicon.getWords('locations')
};

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// 2. Geni≈ületilmi≈ü Morfoloji: T√ºrk√ße √únl√º Uyumu ile Ek Ekleme
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
const VOWELS_BACK = ['a','ƒ±','o','u'];
const VOWELS_FRONT = ['e','i','√∂','√º'];

function getLastVowel(word) {
  for (let i = word.length - 1; i >= 0; i--) {
    if (VOWELS_BACK.includes(word[i]) || VOWELS_FRONT.includes(word[i])) {
      return word[i];
    }
  }
  return 'a'; // default
}

function addCase(noun, role) {
  // role: 'nom' | 'acc' | 'dat' | 'loc' | 'abl' | 'gen'
  const lastVowel = getLastVowel(noun);
  const isBack = VOWELS_BACK.includes(lastVowel);
  const isRounded = ['o','u','√∂','√º'].includes(lastVowel);
  
  switch(role) {
    case 'acc': // ‚Äìƒ±/‚Äìi/‚Äìu/‚Äì√º
      if (isBack) {
        return noun + (isRounded ? 'u' : 'ƒ±');
      } else {
        return noun + (isRounded ? '√º' : 'i');
      }
    case 'dat': // ‚Äìa/‚Äìe
      return noun + (isBack ? 'a' : 'e');
    case 'loc': // ‚Äìda/‚Äìde
      return noun + (isBack ? 'da' : 'de');
    case 'abl': // ‚Äìdan/‚Äìden
      return noun + (isBack ? 'dan' : 'den');
    case 'gen': // ‚Äìƒ±n/‚Äìin/‚Äìun/‚Äì√ºn
      if (isBack) {
        return noun + (isRounded ? 'un' : 'ƒ±n');
      } else {
        return noun + (isRounded ? '√ºn' : 'in');
      }
    default:    // nom: yalƒ±n hali
      return noun;
  }
}

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// 3. Geli≈ümi≈ü Skorlama Fonksiyonlarƒ±
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
function coherenceScore(word, contextEmbed, previousContext = []) {
  // Baƒülam ile uyum skorlamasƒ±
  let score = 1.0;
  
  // √ñnceki kelimelerle anlamsal uyum
  if (previousContext.length > 0) {
    const lastWord = previousContext[previousContext.length - 1];
    
    // Kelime kategorisi uyumu
    const wordCategory = getWordCategory(word);
    const lastCategory = getWordCategory(lastWord);
    
    if (wordCategory === lastCategory) {
      score += 0.3; // Aynƒ± kategori bonus
    }
    
    // Anlamsal yakƒ±nlƒ±k (basit heuristic)
    if (hasSemanticRelation(word, lastWord)) {
      score += 0.5;
    }
  }
  
  return score;
}

function infoScore(word) {
  // Bilgi deƒüeri skorlamasƒ± (daha nadir kelimeler daha y√ºksek skor)
  const allWords = Object.values(LEXICON).flat();
  const frequency = allWords.filter(w => w === word).length;
  const totalWords = allWords.length;
  
  // Shannon information: -log(p)
  const probability = frequency / totalWords;
  return -Math.log(probability + 0.001); // +0.001 to avoid log(0)
}

function surprisalScore(word, previousWords = []) {
  // S√ºrpriz deƒüeri skorlamasƒ±
  if (previousWords.length === 0) {
    return Math.random() * 0.3; // Ba≈ülangƒ±√ß s√ºrprizi
  }
  
  const lastWord = previousWords[previousWords.length - 1];
  const wordCategory = getWordCategory(word);
  const lastCategory = getWordCategory(lastWord);
  
  // Beklenmedik kategori ge√ßi≈üleri daha y√ºksek s√ºrpriz
  if (wordCategory !== lastCategory) {
    return Math.random() * 0.7;
  }
  
  return Math.random() * 0.2;
}

function morphCompatibilityScore(role, sentencePosition = 'middle') {
  // Morfolojik uyum skorlamasƒ±
  const roleScores = {
    'nom': 1.0,  // √ñzne i√ßin ideal
    'acc': 1.2,  // Nesne i√ßin ideal
    'dat': 0.9,  // Dolaylƒ± nesne
    'loc': 0.8,  // Yer belirtme
    'abl': 0.7,  // √áƒ±kma hali
    'gen': 0.6   // ƒ∞lgi hali
  };
  
  let score = roleScores[role] || 1.0;
  
  // C√ºmle pozisyonu bonusu
  if (sentencePosition === 'start' && role === 'nom') {
    score += 0.3; // C√ºmle ba≈üƒ±nda √∂zne bonusu
  } else if (sentencePosition === 'middle' && role === 'acc') {
    score += 0.2; // C√ºmle ortasƒ±nda nesne bonusu
  }
  
  return score;
}

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// 4. Yardƒ±mcƒ± Fonksiyonlar
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
function getWordCategory(word) {
  for (const [category, words] of Object.entries(LEXICON)) {
    if (words.includes(word)) {
      return category;
    }
  }
  return 'unknown';
}

function hasSemanticRelation(word1, word2) {
  // Basit anlamsal ili≈üki kontrol√º
  const relations = {
    'bakteri': ['h√ºcre', 'dna', 'enerji', 'laboratuvar'],
    'm√ºzik': ['≈üarkƒ±', 'mikrofon', 'dans'],
    'doƒüa': ['√ßi√ßek', 'yaprak', 'toprak', 'su', 'hava'],
    'bilim': ['atom', 'kristal', 'laboratuvar', 'ke≈üif']
  };
  
  for (const [concept, relatedWords] of Object.entries(relations)) {
    if (relatedWords.includes(word1) && relatedWords.includes(word2)) {
      return true;
    }
  }
  
  return false;
}

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// 5. üöÄ Performance-Optimized Scoring with Beam Search
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
class OptimizedScoringEngine {
    constructor() {
        this.scoreCache = new Map(); // Memoization for performance
        this.beamWidth = 5; // Beam search width
    }
    
    // Enhanced scoring with dynamic learning integration
    coherenceScoreEnhanced(word, contextEmbed, previousContext = []) {
        let score = 1.0;
        
        // Enhanced contextual scoring
        if (contextEmbed && contextEmbed.topWords) {
            const wordInContext = contextEmbed.topWords.find(w => w.word === word);
            if (wordInContext) {
                score += wordInContext.frequency * 0.5;
            }
        }
        
        // Previous context coherence
        if (previousContext.length > 0) {
            const lastWord = previousContext[previousContext.length - 1];
            const wordCategory = getWordCategory(word);
            const lastCategory = getWordCategory(lastWord);
            
            if (wordCategory === lastCategory) {
                score += 0.3;
            }
            
            if (hasSemanticRelation(word, lastWord)) {
                score += 0.5;
            }
        }
        
        // Dynamic success rate bonus
        const successRate = dynamicLexicon.getWordSuccess(word);
        score += (successRate - 0.5) * 0.4; // Boost/penalize based on past success
        
        return score;
    }
    
    // Enhanced info score with dynamic learning
    infoScoreEnhanced(word) {
        const allWords = Object.values(dynamicLexicon.baseWords).flat();
        const dynamicWords = Object.values(dynamicLexicon.dynamicWords).map(s => Array.from(s)).flat();
        const totalWords = [...allWords, ...dynamicWords];
        
        const frequency = totalWords.filter(w => w === word).length;
        const totalCount = totalWords.length;
        
        // Shannon information with smoothing
        const probability = (frequency + 1) / (totalCount + totalWords.length);
        const infoValue = -Math.log(probability);
        
        // Bonus for successful dynamic words
        const successBonus = dynamicLexicon.getWordSuccess(word) > 0.7 ? 0.3 : 0;
        
        return infoValue + successBonus;
    }
    
    // Beam search for optimal word selection
    beamSearchBest(candidates, contextEmbed, prevWords = [], role = 'nom', position = 'middle') {
        const Œ± = 1.0, Œ≤ = 0.8, Œ≥ = 0.6, Œ¥ = 1.2;
        
        const scoredCandidates = candidates.map(word => {
            const coherence = Œ± * this.coherenceScoreEnhanced(word, contextEmbed, prevWords);
            const info = Œ≤ * this.infoScoreEnhanced(word);
            const surprisal = Œ≥ * surprisalScore(word, prevWords);
            const morphCompat = Œ¥ * morphCompatibilityScore(role, position);
            
            const totalScore = coherence + info - surprisal + morphCompat;
            
            return { word, score: totalScore, details: { coherence, info, surprisal, morphCompat } };
        });
        
        // Sort and return top beam width
        const topCandidates = scoredCandidates
            .sort((a, b) => b.score - a.score)
            .slice(0, this.beamWidth);
        
        if (topCandidates.length === 0) return candidates[0];
        
        // Probabilistic selection from top candidates
        const totalScore = topCandidates.reduce((sum, c) => sum + Math.exp(c.score), 0);
        let random = Math.random() * totalScore;
        
        for (const candidate of topCandidates) {
            random -= Math.exp(candidate.score);
            if (random <= 0) {
                return candidate.word;
            }
        }
        
        return topCandidates[0]?.word || candidates[0];
    }
}

const optimizedScoring = new OptimizedScoringEngine();

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// üé® Advanced Sentence Composer with Punctuation & Style
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
class AdvancedSentenceComposer {
    constructor() {
        this.punctuationPatterns = {
            excitement: ['!', '!!', '...!'],
            question: ['?', '??', '...?'],
            ellipsis: ['...', '‚Ä¶', '. . .'],
            emphasis: ['!', '.', '...'],
            doubt: ['...', '?', '...?']
        };
        
        this.styleModifiers = {
            intensity: ['√ßok', 'epey', 'olduk√ßa', 'son derece'],
            temporal: ['≈üimdi', 'sonra', 'birden', 'yava≈ü√ßa'],
            modal: ['belki', 'muhtemelen', 'kesinlikle', 'sanki'],
            connective: ['ancak', 'ama', 'fakat', 've', 'hem de']
        };
    }
    
    selectPunctuation(emotionalTone = 'neutral', complexity = 'simple') {
        const patterns = this.punctuationPatterns;
        
        switch (emotionalTone) {
            case 'heyecanlƒ±':
            case 'mutlu':
                return this.randomChoice(patterns.excitement);
            case 'meraklƒ±':
            case '≈üa≈ükƒ±n':
                return this.randomChoice(patterns.question);
            case 'h√ºz√ºnl√º':
            case 'endi≈üeli':
                return this.randomChoice(patterns.ellipsis);
            case 'kararlƒ±':
            case 'cesur':
                return this.randomChoice(patterns.emphasis);
            default:
                return Math.random() > 0.8 ? this.randomChoice(patterns.ellipsis) : '.';
        }
    }
    
    addStyleModifier(sentence, style = 'neutral') {
        if (Math.random() > 0.6) return sentence; // 40% chance to add modifier
        
        const modifiers = this.styleModifiers;
        let modifier = '';
        
        switch (style) {
            case 'intensive':
                modifier = this.randomChoice(modifiers.intensity);
                break;
            case 'temporal':
                modifier = this.randomChoice(modifiers.temporal);
                break;
            case 'modal':
                modifier = this.randomChoice(modifiers.modal);
                break;
            default:
                const categories = Object.keys(modifiers);
                const category = this.randomChoice(categories);
                modifier = this.randomChoice(modifiers[category]);
        }
        
        // Insert modifier at appropriate position
        const words = sentence.split(' ');
        if (modifier && words.length > 2) {
            words.splice(1, 0, modifier); // Insert after subject
            return words.join(' ');
        }
        
        return sentence;
    }
    
    randomChoice(array) {
        return array[Math.floor(Math.random() * array.length)];
    }
}

const sentenceComposer = new AdvancedSentenceComposer();

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// üé≤ √áE≈ûITLILIK ENJƒ∞Nƒ∞ - Anti-Monoton Kelime Se√ßimi
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
class DiversityEngine {
    constructor() {
        this.recentWords = []; // Son kullanƒ±lan kelimeler
        this.maxHistory = 15; // Tekrar cezasƒ± i√ßin hafƒ±za (biraz azalttƒ±m)
        this.diversityBoost = 1.2; // √áe≈üitlilik fakt√∂r√º (artƒ±rdƒ±m)
        this.contextRotation = ['biological', 'creative', 'social', 'philosophical', 'emotional'];
        this.currentContextIndex = 0;
        this.sentenceCount = 0;
        this.bannedWords = new Set(); // Ge√ßici olarak yasaklanan kelimeler
        this.wordUsageCount = new Map(); // Kelime kullanƒ±m sayacƒ±
    }
    
    // Top-K + Softmax Sampling - Greedy'nin alternatifi - G√ú√áLENDƒ∞Rƒ∞LMƒ∞≈û!
    pickDiverse(candidates, contextEmbed, prevWords = [], role = 'nom', K = 4, temp = 1.8) {
        if (!candidates || candidates.length === 0) return 'h√ºcre';
        
        // üö´ Yasaklƒ± kelimeleri filtrele
        const filteredCandidates = candidates.filter(word => !this.bannedWords.has(word));
        const workingCandidates = filteredCandidates.length > 2 ? filteredCandidates : candidates;
        
        // 1) Her adayƒ± skorla - AGGRESSIVE NOVELTY!
        const scored = workingCandidates.map(word => {
            const coherence = this.coherenceScore(word, contextEmbed, prevWords);
            const info = this.infoScore(word);
            const surprisal = this.surprisalScore(word, prevWords);
            const morph = this.morphCompatibilityScore(role);
            const novelty = this.aggressiveNoveltyScore(word); // YENƒ∞ - DAHA AGRESƒ∞F!
            const antiMonotony = this.antiMonotonyBonus(word, prevWords); // YENƒ∞!
            
            const totalScore = coherence + info - surprisal + morph + (novelty * 1.5) + antiMonotony;
            return { word, score: totalScore };
        });
        
        // 2) En iyi K adayƒ± al
        scored.sort((a, b) => b.score - a.score);
        const topK = scored.slice(0, Math.min(K, scored.length));
        
        if (topK.length === 0) return workingCandidates[0];
        
        // 3) Softmax ile probabilistic selection - DAHA RASTGELE
        const exps = topK.map(item => Math.exp(item.score / temp));
        const sumExp = exps.reduce((a, b) => a + b, 0);
        const probs = exps.map(e => e / sumExp);
        
        // 4) Weighted random selection
        let random = Math.random();
        let acc = 0;
        for (let i = 0; i < probs.length; i++) {
            acc += probs[i];
            if (random < acc) {
                this.addToHistory(topK[i].word);
                return topK[i].word;
            }
        }
        
        // Fallback
        const selected = topK[0].word;
        this.addToHistory(selected);
        return selected;
    }
    
    // DAHA AGRESƒ∞F yenilik skoru
    aggressiveNoveltyScore(word) {
        const recentUsage = this.recentWords.filter(w => w === word).length;
        const totalUsage = this.wordUsageCount.get(word) || 0;
        
        // √áok kullanƒ±lan kelimeler i√ßin aƒüƒ±r ceza
        let heavyPenalty = 0;
        if (recentUsage > 2) heavyPenalty = -2.0; // Son 15 kelimede 3+ kez kullanƒ±lmƒ±≈üsa
        if (totalUsage > 5) heavyPenalty -= 1.0; // Toplam 5+ kez kullanƒ±lmƒ±≈üsa
        
        // Hi√ß kullanƒ±lmamƒ±≈ü kelimeler i√ßin b√ºy√ºk bonus
        const freshBonus = totalUsage === 0 ? 1.5 : 0;
        const recentBonus = !this.recentWords.includes(word) ? 0.8 : 0;
        
        return freshBonus + recentBonus + heavyPenalty;
    }
    
    // Monotonluk kar≈üƒ±tƒ± bonus - YENI!
    antiMonotonyBonus(word, prevWords) {
        if (prevWords.length < 2) return 0;
        
        const lastTwo = prevWords.slice(-2);
        const category = this.getWordCategory(word);
        const lastCategories = lastTwo.map(w => this.getWordCategory(w));
        
        // Farklƒ± kategoriden kelime se√ßimi i√ßin bonus
        const isDifferentCategory = !lastCategories.includes(category);
        
        // √ú√ßl√º tekrarƒ± √∂nleme (ruh-dna-b√ºy√ºl√ºyor gibi)
        const isBreakingPattern = !lastTwo.some(w => w === word);
        
        return (isDifferentCategory ? 0.7 : 0) + (isBreakingPattern ? 0.5 : -1.0);
    }
    
    addToHistory(word) {
        this.recentWords.push(word);
        if (this.recentWords.length > this.maxHistory) {
            this.recentWords.shift(); // Eski kelimeleri sil
        }
        
        // Kelime kullanƒ±m sayacƒ±nƒ± g√ºncelle
        this.wordUsageCount.set(word, (this.wordUsageCount.get(word) || 0) + 1);
        
        // √áok kullanƒ±lan kelimeleri ge√ßici yasak listesine ekle
        if (this.wordUsageCount.get(word) >= 4) {
            this.bannedWords.add(word);
            // 10 c√ºmle sonra yasaƒüƒ± kaldƒ±r
            setTimeout(() => {
                this.bannedWords.delete(word);
                this.wordUsageCount.set(word, Math.max(0, (this.wordUsageCount.get(word) || 0) - 2));
            }, 10000);
        }
    }
    
    // Context d√∂nd√ºrme - YENI!
    rotateContext() {
        this.sentenceCount++;
        if (this.sentenceCount % 3 === 0) { // Her 3 c√ºmlede bir context deƒüi≈ütir
            this.currentContextIndex = (this.currentContextIndex + 1) % this.contextRotation.length;
            return this.contextRotation[this.currentContextIndex];
        }
        return null; // Context deƒüi≈ümedi
    }
    
    // Kelime havuzunu geni≈ület - YENI!
    expandWordPool(category) {
        const expansions = {
            'subjects': ['bakteri', 'h√ºcre', 'organizma', 'ya≈üam', 'doƒüa', 'evren', 'zaman', 'd√º≈ü√ºnce', 'his', 'r√ºya'],
            'objects': ['protein', 'enzim', 'ATP', 'molek√ºl', 'oksijen', '≈üeker', 'amino', 'vitamin', 'mineral', 'enerji'],
            'verbs': ['hareket', 'b√ºy√ºyor', 'geli≈üiyor', '√∂ƒüreniyor', 'ke≈üfediyor', 'hissediyor', 'd√º≈ü√ºn√ºyor', 'yaratƒ±yor', 'd√∂n√º≈ü√ºyor', 'evrimle≈üiyor'],
            'emotions': ['merak', 'sevgi', 'umut', 'korku', 'heyecan', 'huzur', '≈üa≈ükƒ±nlƒ±k', '√∂zlem', 'ne≈üe', 'endi≈üe'],
            'locations': ['laboratuvar', 'doƒüa', 'okul', 'ev', '≈üehir', 'orman', 'deniz', 'g√∂ky√ºz√º', 'uzay', 'kalp']
        };
        return expansions[category] || [];
    }
    
    // Basit scoring functions (backward compatibility) - G√ú√áLENDƒ∞Rƒ∞LMƒ∞≈û
    coherenceScore(word, contextEmbed, prevWords) {
        let score = 1.0;
        if (prevWords.length > 0) {
            const lastWord = prevWords[prevWords.length - 1];
            const wordCat = this.getWordCategory(word);
            const lastCat = this.getWordCategory(lastWord);
            
            // Aynƒ± kategoriden kelime cezasƒ±
            if (wordCat === lastCat) {
                score -= 0.3; // Ceza artƒ±rdƒ±m
            } else {
                score += 0.4; // Farklƒ± kategori bonusu
            }
        }
        return score;
    }
    
    infoScore(word) {
        const allWords = Object.values(dynamicLexicon.baseWords).flat();
        const expanded = this.expandWordPool('subjects').concat(
            this.expandWordPool('objects'),
            this.expandWordPool('verbs')
        );
        const totalWords = [...allWords, ...expanded];
        
        const frequency = totalWords.filter(w => w === word).length;
        return frequency > 0 ? -Math.log(frequency / totalWords.length) : 2.5; // Bilinmeyen kelimeler i√ßin bonus
    }
    
    surprisalScore(word, prevWords) {
        if (prevWords.length === 0) return Math.random() * 0.5;
        const lastWord = prevWords[prevWords.length - 1];
        const surprise = this.getWordCategory(word) !== this.getWordCategory(lastWord) ? 0.8 : 0.1;
        
        // Tekrar eden kelimeler i√ßin s√ºrpriz cezasƒ±
        const repetitionPenalty = prevWords.includes(word) ? -0.5 : 0;
        
        return surprise + repetitionPenalty;
    }
    
    morphCompatibilityScore(role) {
        const scores = { 'nom': 1.0, 'acc': 1.2, 'dat': 0.9, 'loc': 0.8 };
        return scores[role] || 1.0;
    }
    
    getWordCategory(word) {
        for (const [category, words] of Object.entries(dynamicLexicon.baseWords)) {
            if (words.includes(word)) return category;
        }
        
        // Geni≈ületilmi≈ü kelime havuzunda ara
        for (const category of ['subjects', 'objects', 'verbs', 'emotions']) {
            if (this.expandWordPool(category).includes(word)) {
                return category;
            }
        }
        
        return 'unknown';
    }
    
    // Context √ße≈üitliliƒüi i√ßin rastgele field se√ßimi - G√ú√áLENDƒ∞Rƒ∞LMƒ∞≈û
    diversifyContext() {
        const rotated = this.rotateContext();
        if (rotated) {
            console.log(`üîÑ Context rotated to: ${rotated}`);
            return rotated;
        }
        
        // Rastgele deƒüi≈üim (daha sƒ±k)
        if (Math.random() < 0.4) { // 20% -> 40%
            const contexts = ['biological', 'creative', 'social', 'philosophical', 'emotional'];
            const newContext = contexts[Math.floor(Math.random() * contexts.length)];
            console.log(`üé≤ Context randomized to: ${newContext}`);
            return newContext;
        }
        
        return this.contextRotation[this.currentContextIndex];
    }
    
    // Debugging - G√ú√áLENDƒ∞Rƒ∞LMƒ∞≈û
    getStats() {
        const wordCounts = {};
        this.recentWords.forEach(w => wordCounts[w] = (wordCounts[w] || 0) + 1);
        return { 
            recentWords: this.recentWords.slice(-10),
            topRepeated: Object.entries(wordCounts).sort((a,b) => b[1] - a[1]).slice(0, 5),
            bannedWords: Array.from(this.bannedWords),
            currentContext: this.contextRotation[this.currentContextIndex],
            sentenceCount: this.sentenceCount,
            totalWordUsage: this.wordUsageCount.size
        };
    }
    
    // Sistem resetleme i√ßin
    resetDiversity() {
        this.recentWords = [];
        this.bannedWords.clear();
        this.wordUsageCount.clear();
        this.sentenceCount = 0;
        this.currentContextIndex = 0;
        console.log('üîÑ Diversity engine reset!');
    }
}

// Global diversity engine
const diversityEngine = new DiversityEngine();

// Backward compatibility function - ARTIK √áE≈ûƒ∞TLƒ∞Lƒ∞K KULLANIR!
function pickBest(candidates, contextEmbed, prevWords = [], role = 'nom', position = 'middle') {
    return diversityEngine.pickDiverse(candidates, contextEmbed, prevWords, role, 4, 1.5);
}

// üîç DEBUGGING - Diversity Stats'ƒ± g√∂ster
function showDiversityStats() {
    const stats = diversityEngine.getStats();
    console.log('üé≠ DIVERSITY ENGINE STATS:', stats);
    
    if (typeof window !== 'undefined' && window.console) {
        console.group('üî§ Word Diversity Analysis');
        console.log('üìù Recent words:', stats.recentWords);
        console.log('üîÅ Most repeated:', stats.topRepeated);
        console.log('üö´ Banned words:', stats.bannedWords);
        console.log('üéØ Current context:', stats.currentContext);
        console.log('üìä Sentence count:', stats.sentenceCount);
        console.log('üìö Total vocabulary used:', stats.totalWordUsage);
        console.groupEnd();
    }
    
    return stats;
}

// üîÑ Diversity Reset
function resetDiversityEngine() {
    diversityEngine.resetDiversity();
    console.log('üîÑ Diversity engine has been reset!');
}

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// 6. Geli≈ümi≈ü C√ºmle √úretimi
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
async function generateMorphSentence(contextEmbed = null, sentenceType = 'simple') {
  const prevWords = [];
  let sentence = '';
  
  switch (sentenceType) {
    case 'simple':
      sentence = await generateSimpleSentence(contextEmbed, prevWords);
      break;
    case 'complex':
      sentence = await generateComplexSentence(contextEmbed, prevWords);
      break;
    case 'emotional':
      sentence = await generateEmotionalSentence(contextEmbed, prevWords);
      break;
    case 'locative':
      sentence = await generateLocativeSentence(contextEmbed, prevWords);
      break;
    default:
      sentence = await generateSimpleSentence(contextEmbed, prevWords);
  }
  
  return sentence;
}

async function generateSimpleSentence(contextEmbed, prevWords) {
  // SOV: √ñzne + Nesne + Fiil - GENƒ∞≈ûLETƒ∞LMƒ∞≈û KELƒ∞ME HAVUZU ƒ∞LE!
  
  // üé≤ Context deƒüi≈üimi (daha sƒ±k)
  const newContext = diversityEngine.diversifyContext();
  
  // √ñzne se√ßimi - GENƒ∞≈ûLETƒ∞LMƒ∞≈û kategorilerden
  const expandedSubjects = [
    ...LEXICON.subjects, 
    ...diversityEngine.expandWordPool('subjects'),
    ...LEXICON.emotions.slice(0, 3), // Sadece birka√ß emotion
    ...diversityEngine.expandWordPool('emotions').slice(0, 3)
  ];
  const subject = pickBest(expandedSubjects, contextEmbed, prevWords, 'nom', 'start');
  prevWords.push(subject);
  
  // Nesne se√ßimi - GENƒ∞≈ûLETƒ∞LMƒ∞≈û havuzdan
  let objectPart = '';
  const expandedObjects = [
    ...LEXICON.objects,
    ...diversityEngine.expandWordPool('objects')
  ];
  
  if (Math.random() < 0.4) { // Temporal modifier ≈üansƒ±nƒ± artƒ±rdƒ±m
    const temporals = [...LEXICON.temporal, 'aniden', 'sessizce', 'dikkatli bir ≈üekilde'];
    const temporal = pickBest(temporals, contextEmbed, prevWords, 'nom', 'middle');
    const objectBase = pickBest(expandedObjects, contextEmbed, prevWords, 'acc', 'middle');
    const object = addCase(objectBase, 'acc');
    objectPart = `${temporal} ${object}`;
    prevWords.push(temporal, object);
  } else {
    const objectBase = pickBest(expandedObjects, contextEmbed, prevWords, 'acc', 'middle');
    const object = addCase(objectBase, 'acc');
    objectPart = object;
    prevWords.push(object);
  }
  
  // Fiil se√ßimi - GENƒ∞≈ûLETƒ∞LMƒ∞≈û havuzdan
  const expandedVerbs = [
    ...LEXICON.verbs,
    ...diversityEngine.expandWordPool('verbs')
  ];
  const verb = pickBest(expandedVerbs, contextEmbed, prevWords, 'nom', 'end');
  prevWords.push(verb);
  
  return `${capitalize(subject)} ${objectPart} ${verb}.`;
}

async function generateComplexSentence(contextEmbed, prevWords) {
  // √ñzne + Yer + Nesne + Fiil - ULTRA GENƒ∞≈ûLETƒ∞LMƒ∞≈û √áE≈ûƒ∞TLƒ∞Lƒ∞K
  
  // Context rotation
  diversityEngine.diversifyContext();
  
  // √ñzne √ße≈üitliliƒüi - B√úY√úK HAVUZ
  const megaSubjects = [
    ...LEXICON.subjects, 
    ...diversityEngine.expandWordPool('subjects'),
    ...LEXICON.emotions.slice(0, 4),
    ...diversityEngine.expandWordPool('emotions').slice(0, 4)
  ];
  const subject = pickBest(megaSubjects, contextEmbed, prevWords, 'nom', 'start');
  prevWords.push(subject);
  
  // Konum + yoƒüunluk belirteci (bazen)
  let locationPart = '';
  if (Math.random() < 0.4) {
    const intensifier = pickBest(LEXICON.intensifiers, contextEmbed, prevWords, 'nom', 'middle');
    const locationBase = pickBest(LEXICON.locations, contextEmbed, prevWords, 'loc', 'middle');
    const location = addCase(locationBase, 'loc');
    locationPart = `${intensifier} ${location}`;
    prevWords.push(intensifier, location);
  } else {
    const locationBase = pickBest(LEXICON.locations, contextEmbed, prevWords, 'loc', 'middle');
    const location = addCase(locationBase, 'loc');
    locationPart = location;
    prevWords.push(location);
  }
  
  // Nesne + baƒüla√ß kombinasyonu (bazen)
  let objectPart = '';
  if (Math.random() < 0.25) {
    const objectBase1 = pickBest(LEXICON.objects, contextEmbed, prevWords, 'acc', 'middle');
    const object1 = addCase(objectBase1, 'acc');
    const conjunction = pickBest(LEXICON.conjunctions.slice(5, 9), contextEmbed, prevWords, 'nom', 'middle'); // 've', 'ile', 'hem', 'ya da'
    const objectBase2 = pickBest(LEXICON.objects, contextEmbed, prevWords, 'acc', 'middle');
    const object2 = addCase(objectBase2, 'acc');
    objectPart = `${object1} ${conjunction} ${object2}`;
    prevWords.push(object1, conjunction, object2);
  } else {
    const objectBase = pickBest(LEXICON.objects, contextEmbed, prevWords, 'acc', 'middle');
    const object = addCase(objectBase, 'acc');
    objectPart = object;
    prevWords.push(object);
  }
  
  const verb = pickBest(LEXICON.verbs, contextEmbed, prevWords, 'nom', 'end');
  prevWords.push(verb);
  
  return `${capitalize(subject)} ${locationPart} ${objectPart} ${verb}.`;
}

async function generateEmotionalSentence(contextEmbed, prevWords) {
  // Duygusal √ñzne + Nesne + Fiil
  
  const subject = pickBest(LEXICON.subjects, contextEmbed, prevWords, 'nom', 'start');
  prevWords.push(subject);
  
  const emotion = pickBest(LEXICON.emotions, contextEmbed, prevWords, 'nom', 'middle');
  prevWords.push(emotion);
  
  const objectBase = pickBest(LEXICON.objects, contextEmbed, prevWords, 'acc', 'middle');
  const object = addCase(objectBase, 'acc');
  prevWords.push(object);
  
  const verb = pickBest(LEXICON.verbs, contextEmbed, prevWords, 'nom', 'end');
  prevWords.push(verb);
  
  return `${capitalize(subject)} ${emotion} bir ≈üekilde ${object} ${verb}.`;
}

async function generateLocativeSentence(contextEmbed, prevWords) {
  // √ñzne + Yerden + Yere + Fiil (Ablative + Dative)
  
  const subject = pickBest(LEXICON.subjects, contextEmbed, prevWords, 'nom', 'start');
  prevWords.push(subject);
  
  const fromLocationBase = pickBest(LEXICON.locations, contextEmbed, prevWords, 'abl', 'middle');
  const fromLocation = addCase(fromLocationBase, 'abl');
  prevWords.push(fromLocation);
  
  const toLocationBase = pickBest(LEXICON.locations, contextEmbed, prevWords, 'dat', 'middle');
  const toLocation = addCase(toLocationBase, 'dat');
  prevWords.push(toLocation);
  
  const verb = pickBest(['gidiyor', 'u√ßuyor', 'y√ºz√ºyor', 'ko≈üuyor', 'sƒ±√ßrƒ±yor'], contextEmbed, prevWords, 'nom', 'end');
  prevWords.push(verb);
  
  return `${capitalize(subject)} ${fromLocation} ${toLocation} ${verb}.`;
}

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// 7. Yardƒ±mcƒ± Fonksiyon
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
function capitalize(s) {
  return s.charAt(0).toLocaleUpperCase('tr') + s.slice(1);
}

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// 8. √áoklu C√ºmle √úretimi
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
async function generateMorphDialogue(sentences = 3, contextEmbed = null) {
  const dialogue = [];
  const types = ['simple', 'complex', 'emotional', 'locative'];
  
  // üéØ √áE≈ûƒ∞TLƒ∞Lƒ∞K ENJƒ∞Nƒ∞ - Her c√ºmle farklƒ± tip olsun
  const usedTypes = [];
  
  for (let i = 0; i < sentences; i++) {
    // Mevcut kullanƒ±lmamƒ±≈ü tipleri al
    const availableTypes = types.filter(type => !usedTypes.includes(type) || usedTypes.length >= types.length);
    
    // Eƒüer t√ºm tipler kullanƒ±ldƒ±ysa, listesini temizle
    if (availableTypes.length === 0) {
      usedTypes.length = 0;
      availableTypes.push(...types);
    }
    
    // Rastgele ama kullanƒ±lmamƒ±≈ü tip se√ß
    const randomType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
    usedTypes.push(randomType);
    
    // Diversity engine history'sini kontrol et
    if (i > 0 && diversityEngine.recentWords.length > 10) {
      console.log(`üîÑ Diversity stats: ${JSON.stringify(diversityEngine.getStats().topRepeated)}`);
    }
    
    const sentence = await generateMorphSentence(contextEmbed, randomType);
    dialogue.push(sentence);
  }
  
  return dialogue.join(' ');
}

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// 9. √ñrnek Kullanƒ±m ve Test
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// Test function moved to tests/MorphologicalDialogueGenerator.test.js

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// üöÄ Enhanced Generation Functions with All Improvements
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

/**
 * Enhanced morphological sentence generation with style and punctuation
 */
async function generateEnhancedMorphSentence(contextEmbed = null, sentenceType = 'simple', options = {}) {
    const {
        emotionalTone = 'neutral',
        complexity = 'medium',
        consciousness = 0.5,
        enableStyle = true,
        enableComposition = true
    } = options;
    
    const prevWords = [];
    let sentence = '';
    
    // Advanced sentence type selection
    const advancedTypes = ['compound', 'temporal', 'modal', 'intensive'];
    if (enableComposition && Math.random() > 0.7 && complexity !== 'simple') {
        sentenceType = sentenceComposer.randomChoice(advancedTypes);
    }
    
    switch (sentenceType) {
        case 'simple':
            sentence = await generateAdvancedSimpleSentence(contextEmbed, prevWords, emotionalTone);
            break;
        case 'complex':
            sentence = await generateAdvancedComplexSentence(contextEmbed, prevWords, emotionalTone);
            break;
        case 'emotional':
            sentence = await generateAdvancedEmotionalSentence(contextEmbed, prevWords, emotionalTone);
            break;
        case 'locative':
            sentence = await generateAdvancedLocativeSentence(contextEmbed, prevWords, emotionalTone);
            break;
        case 'compound':
            sentence = await generateCompoundSentence(contextEmbed, prevWords, emotionalTone);
            break;
        case 'temporal':
            sentence = await generateTemporalSentence(contextEmbed, prevWords, emotionalTone);
            break;
        case 'modal':
            sentence = await generateModalSentence(contextEmbed, prevWords, emotionalTone);
            break;
        case 'intensive':
            sentence = await generateIntensiveSentence(contextEmbed, prevWords, emotionalTone);
            break;
        default:
            sentence = await generateAdvancedSimpleSentence(contextEmbed, prevWords, emotionalTone);
    }
    
    // Apply style modifications
    if (enableStyle) {
        sentence = sentenceComposer.addStyleModifier(sentence, sentenceType);
    }
    
    // Add appropriate punctuation
    const punct = sentenceComposer.selectPunctuation(emotionalTone, complexity);
    if (!sentence.endsWith(punct) && !sentence.match(/[.!?‚Ä¶]$/)) {
        sentence += punct;
    }
    
    // Update dynamic lexicon with usage
    const words = sentence.split(/\s+/);
    words.forEach(word => {
        const cleanWord = word.replace(/[.,!?‚Ä¶]/g, '');
        if (cleanWord.length > 2) {
            dynamicLexicon.updateWordSuccess(cleanWord, 0.7 + Math.random() * 0.3);
        }
    });
    
    return sentence;
}

/**
 * Enhanced dialogue generation with emotional progression
 */
async function generateEnhancedMorphDialogue(sentences = 3, contextEmbed = null, options = {}) {
    const {
        emotionalProgression = true,
        narrativeCoherence = true,
        styleDiversity = true
    } = options;
    
    const dialogue = [];
    const dialogueContext = [];
    
    // Emotional progression pattern
    const emotionalStates = ['neutral', 'meraklƒ±', 'heyecanlƒ±', 'mutlu', 'sakin'];
    let currentEmotion = 'neutral';
    
    for (let i = 0; i < sentences; i++) {
        // Emotional progression
        if (emotionalProgression && Math.random() > 0.5) {
            currentEmotion = sentenceComposer.randomChoice(emotionalStates);
        }
        
        // Sentence type diversity
        const types = ['simple', 'complex', 'emotional', 'locative', 'compound', 'temporal'];
        let sentenceType = 'simple';
        
        if (styleDiversity) {
            if (i === 0) {
                sentenceType = sentenceComposer.randomChoice(['simple', 'temporal', 'modal']);
            } else if (i === sentences - 1) {
                sentenceType = sentenceComposer.randomChoice(['emotional', 'intensive', 'compound']);
            } else {
                sentenceType = sentenceComposer.randomChoice(types);
            }
        }
        
        // Generate with enhanced context
        const enhancedContextEmbed = narrativeCoherence 
            ? enhanceContextWithDialogueHistory(contextEmbed, dialogueContext)
            : contextEmbed;
        
        const sentenceOptions = {
            emotionalTone: currentEmotion,
            complexity: i > 0 ? 'complex' : 'medium',
            consciousness: 0.6 + (i * 0.1), // Progressive consciousness
            enableStyle: styleDiversity,
            enableComposition: i > 0
        };
        
        const sentence = await generateEnhancedMorphSentence(
            enhancedContextEmbed, 
            sentenceType, 
            sentenceOptions
        );
        
        dialogue.push(sentence);
        dialogueContext.push({
            sentence,
            emotion: currentEmotion,
            type: sentenceType,
            position: i
        });
    }
    
    return dialogue.join(' ');
}

// Enhanced sentence generation functions
async function generateAdvancedSimpleSentence(contextEmbed, prevWords, emotionalTone) {
    const subject = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('subjects'), 
        contextEmbed, 
        prevWords, 
        'nom', 
        'start'
    );
    prevWords.push(subject);
    
    const objectBase = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('objects'), 
        contextEmbed, 
        prevWords, 
        'acc', 
        'middle'
    );
    const object = addCase(objectBase, 'acc');
    prevWords.push(object);
    
    const verb = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('verbs'), 
        contextEmbed, 
        prevWords, 
        'nom', 
        'end'
    );
    
    return `${capitalize(subject)} ${object} ${verb}`;
}

async function generateCompoundSentence(contextEmbed, prevWords, emotionalTone) {
    // Generate two simple sentences and connect them
    const sentence1 = await generateAdvancedSimpleSentence(contextEmbed, prevWords, emotionalTone);
    
    const conjunction = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('conjunctions'), 
        contextEmbed, 
        prevWords, 
        'nom', 
        'middle'
    );
    
    // Generate second sentence with different subject
    const subject2 = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('subjects').filter(s => !prevWords.includes(s)), 
        contextEmbed, 
        prevWords, 
        'nom', 
        'start'
    );
    
    const objectBase2 = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('objects'), 
        contextEmbed, 
        [...prevWords, subject2], 
        'acc', 
        'middle'
    );
    const object2 = addCase(objectBase2, 'acc');
    
    const verb2 = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('verbs'), 
        contextEmbed, 
        [...prevWords, subject2, object2], 
        'nom', 
        'end'
    );
    
    return `${sentence1}, ${conjunction} ${subject2} ${object2} ${verb2}`;
}

async function generateTemporalSentence(contextEmbed, prevWords, emotionalTone) {
    const temporal = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('temporal'), 
        contextEmbed, 
        prevWords, 
        'nom', 
        'start'
    );
    const baseSentence = await generateAdvancedSimpleSentence(contextEmbed, prevWords, emotionalTone);
    
    return `${capitalize(temporal)} ${baseSentence.toLocaleLowerCase('tr')}`;
}

async function generateModalSentence(contextEmbed, prevWords, emotionalTone) {
    const modal = sentenceComposer.randomChoice(['belki', 'muhtemelen', 'kesinlikle', 'sanki', 'galiba']);
    const baseSentence = await generateAdvancedSimpleSentence(contextEmbed, prevWords, emotionalTone);
    
    const words = baseSentence.split(' ');
    words.splice(1, 0, modal); // Insert after subject
    
    return words.join(' ');
}

async function generateIntensiveSentence(contextEmbed, prevWords, emotionalTone) {
    const intensity = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('intensifiers'), 
        contextEmbed, 
        prevWords, 
        'nom', 
        'middle'
    );
    const baseSentence = await generateAdvancedSimpleSentence(contextEmbed, prevWords, emotionalTone);
    
    const words = baseSentence.split(' ');
    if (words.length >= 3) {
        words.splice(-2, 0, intensity); // Insert before verb
    }
    
    return words.join(' ');
}

async function generateAdvancedComplexSentence(contextEmbed, prevWords, emotionalTone) {
    const subject = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('subjects'), 
        contextEmbed, 
        prevWords, 
        'nom', 
        'start'
    );
    prevWords.push(subject);
    
    const locationBase = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('locations'), 
        contextEmbed, 
        prevWords, 
        'loc', 
        'middle'
    );
    const location = addCase(locationBase, 'loc');
    prevWords.push(location);
    
    const objectBase = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('objects'), 
        contextEmbed, 
        prevWords, 
        'acc', 
        'middle'
    );
    const object = addCase(objectBase, 'acc');
    prevWords.push(object);
    
    const verb = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('verbs'), 
        contextEmbed, 
        prevWords, 
        'nom', 
        'end'
    );
    
    return `${capitalize(subject)} ${location} ${object} ${verb}`;
}

async function generateAdvancedEmotionalSentence(contextEmbed, prevWords, emotionalTone) {
    const subject = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('subjects'), 
        contextEmbed, 
        prevWords, 
        'nom', 
        'start'
    );
    prevWords.push(subject);
    
    const emotion = emotionalTone !== 'neutral' 
        ? emotionalTone 
        : optimizedScoring.beamSearchBest(
            dynamicLexicon.getWords('emotions'), 
            contextEmbed, 
            prevWords, 
            'nom', 
            'middle'
        );
    prevWords.push(emotion);
    
    const objectBase = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('objects'), 
        contextEmbed, 
        prevWords, 
        'acc', 
        'middle'
    );
    const object = addCase(objectBase, 'acc');
    prevWords.push(object);
    
    const verb = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('verbs'), 
        contextEmbed, 
        prevWords, 
        'nom', 
        'end'
    );
    
    return `${capitalize(subject)} ${emotion} bir ≈üekilde ${object} ${verb}`;
}

async function generateAdvancedLocativeSentence(contextEmbed, prevWords, emotionalTone) {
    const subject = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('subjects'), 
        contextEmbed, 
        prevWords, 
        'nom', 
        'start'
    );
    prevWords.push(subject);
    
    const fromLocationBase = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('locations'), 
        contextEmbed, 
        prevWords, 
        'abl', 
        'middle'
    );
    const fromLocation = addCase(fromLocationBase, 'abl');
    prevWords.push(fromLocation);
    
    const toLocationBase = optimizedScoring.beamSearchBest(
        dynamicLexicon.getWords('locations').filter(l => l !== fromLocationBase), 
        contextEmbed, 
        prevWords, 
        'dat', 
        'middle'
    );
    const toLocation = addCase(toLocationBase, 'dat');
    prevWords.push(toLocation);
    
    const verb = optimizedScoring.beamSearchBest(
        ['gidiyor', 'u√ßuyor', 'y√ºz√ºyor', 'ko≈üuyor', 'sƒ±√ßrƒ±yor', 'atlƒ±yor', 's√ºz√ºl√ºyor'], 
        contextEmbed, 
        prevWords, 
        'nom', 
        'end'
    );
    
    return `${capitalize(subject)} ${fromLocation} ${toLocation} ${verb}`;
}

function enhanceContextWithDialogueHistory(contextEmbed, dialogueContext) {
    if (!contextEmbed || dialogueContext.length === 0) return contextEmbed;
    
    // Extract words from dialogue history
    const historyWords = dialogueContext.flatMap(item => 
        item.sentence.split(/\s+/).map(word => word.replace(/[.,!?‚Ä¶]/g, ''))
    );
    
    // Create enhanced context
    const enhancedEmbed = { ...contextEmbed };
    
    if (enhancedEmbed.topWords) {
        // Boost words that appeared in dialogue
        enhancedEmbed.topWords = enhancedEmbed.topWords.map(wordInfo => {
            if (historyWords.includes(wordInfo.word)) {
                return { ...wordInfo, frequency: wordInfo.frequency * 1.2 };
            }
            return wordInfo;
        });
    }
    
    // Add dialogue coherence info
    enhancedEmbed.dialogueHistory = dialogueContext;
    enhancedEmbed.dominantEmotion = getMostFrequentEmotion(dialogueContext);
    
    return enhancedEmbed;
}

function getMostFrequentEmotion(dialogueContext) {
    const emotionCounts = {};
    dialogueContext.forEach(item => {
        emotionCounts[item.emotion] = (emotionCounts[item.emotion] || 0) + 1;
    });
    
    return Object.keys(emotionCounts).reduce((a, b) => 
        emotionCounts[a] > emotionCounts[b] ? a : b
    ) || 'neutral';
}

// Test function moved to tests/EnhancedMorphologicalSystem.test.js

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// 10. Expanded Module Exports
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
export { 
  // Original functions (backward compatibility)
  generateMorphSentence, 
  generateMorphDialogue, 
  // testMorphologicalGenerator, // Moved to tests
  addCase,
  LEXICON,
  
  // Enhanced functions
  generateEnhancedMorphSentence,
  generateEnhancedMorphDialogue,
  // testEnhancedMorphologicalSystem, // Moved to tests
  
  // Classes and engines
  DynamicLexicon,
  OptimizedScoringEngine,
  AdvancedSentenceComposer,
  DiversityEngine, // YENƒ∞!
  
  // Instances
  dynamicLexicon,
  optimizedScoring,
  sentenceComposer,
  diversityEngine, // YENƒ∞!
  
  // Debug functions
  showDiversityStats,
  resetDiversityEngine
}; 