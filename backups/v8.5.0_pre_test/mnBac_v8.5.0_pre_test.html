<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeoMag v8.2.8 - Frontend TabPFN & Smart Word Usage (Mobile Ready)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <style>
        /* CSS Variables for better maintainability */
        :root {
            --color-primary: #3D5AFE;
            --color-secondary: #00C853;
            --color-accent: #FFC107;
            --color-bg-dark: #121212;
            --color-bg-panel: #1E1E1E;
            --color-text-light: #E0E0E0;
            --color-text-muted: #B0B0B0;
            --color-border: #333;
            --radius-lg: 12px;
            --radius-sm: 6px;
            --transition-fast: 0.2s ease;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .bacteria {
            transition: all 0.5s ease-in-out;
            cursor: pointer;
        }
        .bacteria:hover {
            transform: scale(1.1);
        }
        .chat-bubble {
            max-width: 70%;
            word-wrap: break-word;
        }
        .chat-bubble-user {
            background-color: #3b82f6; /* blue-500 */
            color: white;
        }
        .chat-bubble-bacteria {
            background-color: #e5e7eb; /* gray-200 */
            color: #1f2937; /* gray-800 */
        }
        .smooth-scroll {
            scroll-behavior: smooth;
        }
        /* Custom scrollbar for chat */
        #chatMessages::-webkit-scrollbar {
            width: 8px;
        }
        #chatMessages::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #chatMessages::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        #chatMessages::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Loading spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 5px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
            
        /* ğŸ­ TabPFN Speech Bubble Animations */
        @keyframes speechBubbleAnim {
            0% { 
                transform: scale(0.8) translateY(10px); 
                opacity: 0; 
            }
            15% { 
                transform: scale(1.05) translateY(-5px); 
                opacity: 1; 
            }
            20% { 
                transform: scale(1) translateY(0px); 
                opacity: 1; 
            }
            80% { 
                transform: scale(1) translateY(0px); 
                opacity: 1; 
            }
            100% { 
                transform: scale(0.9) translateY(-10px); 
                opacity: 0; 
            }
        }

        .speech-bubble {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }

        .speech-bubble:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0,0,0,0.6);
        }

        /* Context-specific bubble styles */
        .speech-food_seeking {
            border-left: 4px solid #FFD700;
        }

        .speech-social_interaction {
            border-left: 4px solid #00FFFF;
        }

        .speech-philosophical {
            border-left: 4px solid #FF4500;
            font-style: italic;
        }

        .speech-learning {
            border-left: 4px solid #32CD32;
        }

        </style>
    </head>
<body class="bg-gray-900 text-gray-100 flex flex-col min-h-screen">

    <!-- Header -->
    <header class="bg-gray-800 shadow-lg p-4 sticky top-0 z-50">
        <div class="flex justify-between items-center">
            <h1 class="text-2xl font-bold text-teal-400">ğŸ§¬ NeoMag v8.2.9 - AI Bakteri SimÃ¼lasyonu</h1>
            <div class="flex gap-2 text-xs">
                <div class="bg-green-600 text-white px-2 py-1 rounded" id="fpsDisplay">FPS: --</div>
                <div class="bg-blue-600 text-white px-2 py-1 rounded" id="bacteriaCount">Bakteri: 0</div>
                <div class="bg-purple-600 text-white px-2 py-1 rounded" id="dayDisplay">GÃ¼n: 0</div>
            </div>
        </div>
        <div class="text-center text-xs text-teal-300 mt-1">
            ğŸ“± Mobile Ready TabPFN | ğŸ¯ Smart Word Usage | âš¡ < 1 Second Predictions | ğŸ§  Single HTML Solution
        </div>
        <div id="buildInfo" class="text-center text-xs text-gray-400 mt-1">
            Build: Loading...
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow container mx-auto p-2 sm:p-4 grid grid-cols-1 lg:grid-cols-3 gap-4">
        
        <!-- Sol Panel SimÃ¼lasyon ve Detaylar -->
        <div class="lg:col-span-2 bg-gray-800 p-4 rounded-lg shadow-xl flex flex-col">
            <h2 class="text-xl font-semibold mb-3 text-teal-300 border-b border-gray-700 pb-2">SimÃ¼lasyon AlanÄ±</h2>
            <div id="simulationArea" class="bg-gray-700 rounded-md p-4 relative h-[400px] w-full overflow-hidden cursor-crosshair border-2 border-gray-600">
                <!-- Canvas akan buraya eklendi -->
                <canvas id="simCanvas" class="w-full h-full absolute top-0 left-0"></canvas>
                <div class="absolute top-2 left-2 text-xs text-teal-300 bg-gray-800 bg-opacity-75 px-2 py-1 rounded">
                    ğŸ Yemek eklemek iÃ§in tÄ±klayÄ±n | ğŸ§¬ Bakteriler iÃ§in tÄ±klayÄ±n
                </div>
                <div class="absolute top-2 right-2 text-xs text-blue-300 bg-gray-800 bg-opacity-75 px-2 py-1 rounded">
                    âš—ï¸ MolekÃ¼ler Dinamik SimÃ¼lasyonu | FPS: <span id="canvasFpsDisplay">--</span>
                </div>
            </div>
            <div class="mt-4 p-3 bg-gray-750 rounded-md">
                <h3 class="text-lg font-semibold mb-2 text-teal-300">Kontrol Paneli</h3>
                <div class="flex space-x-2">
                    <button id="startSimulationBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out">SimÃ¼lasyonu BaÅŸlat</button>
                    <button id="nextStepBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out" disabled>Sonraki AdÄ±m</button>
                    <button id="resetSimulationBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out">SÄ±fÄ±rla</button>
                </div>
                <p id="simulationTime" class="mt-2 text-sm text-gray-400">SimÃ¼lasyon ZamanÄ±: 0 gÃ¼n</p>
            </div>
            <div id="bacteriaDetails" class="mt-4 p-3 bg-gray-750 rounded-md hidden">
                <h3 class="text-lg font-semibold mb-2 text-teal-300" id="detailsHeader">Bakteri DetaylarÄ±</h3>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 text-sm">
                    <p><strong>ID:</strong> <span id="bacteriaId" class="text-gray-300"></span></p>
                    <p><strong>Ä°sim:</strong> <span id="bacteriaName" class="text-gray-300"></span></p>
                    <p><strong>Boyut:</strong> <span id="bacteriaSize" class="text-gray-300"></span> Âµm</p>
                    <p><strong>YaÅŸ:</strong> <span id="bacteriaAge" class="text-gray-300"></span> gÃ¼n</p>
                    <p><strong>BÃ¼yÃ¼me HÄ±zÄ±:</strong> <span id="bacteriaGrowthRate" class="text-gray-300"></span></p>
                    <p><strong>BilinÃ§ Seviyesi:</strong> <span id="bacteriaConsciousness" class="text-gray-300"></span></p>
                    <p><strong>KiÅŸilik (Ä°yimserlik):</strong> <span id="bacteriaOptimism" class="text-gray-300"></span></p>
                    <p><strong>KiÅŸilik (Sosyallik):</strong> <span id="bacteriaSociability" class="text-gray-300"></span></p>
                    <p><strong>Dil AÅŸamasÄ±:</strong> <span id="bacteriaLanguageStage" class="text-gray-300"></span></p>
                    <p><strong>Kelime Haznesi:</strong> <span id="bacteriaVocabulary" class="text-gray-300 break-all"></span></p>
                </div>
            </div>
        </div>

        <!-- SaÄŸ Panel Sohbet -->
        <div class="bg-gray-800 p-4 rounded-lg shadow-xl flex flex-col max-h-[80vh] lg:max-h-full">
            <h2 class="text-xl font-semibold mb-3 text-teal-300 border-b border-gray-700 pb-2">Bakteri Sohbet Merkezi</h2>
            
            <!-- Chat Mode Selector -->
            <div class="mb-3 flex space-x-2">
                <button id="individualChatBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm transition">Tekil Sohbet</button>
                <button id="groupChatBtn" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm transition">Grup Sohbeti</button>
                <button id="startBacteriaConversationBtn" class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded text-sm transition">Bakteriler KonuÅŸsun</button>
            </div>
            
            <div id="chatInfo" class="mb-2 text-sm text-gray-400">Sohbet modunu seÃ§in.</div>
            <div id="chatMessages" class="flex-grow bg-gray-700 rounded-md p-3 overflow-y-auto mb-3 smooth-scroll space-y-2 h-64 min-h-[16rem] max-h-[20rem]" style="display: flex; flex-direction: column-reverse;">
                <!-- Sohbet mesajlarÄ± buraya eklenecek -->
            </div>
            <div id="chatLoadingIndicator" class="hidden text-center py-2">
                <div class="loader"></div>
                <p class="text-sm text-gray-400">Bakteri dÃ¼ÅŸÃ¼nÃ¼yor...</p>
            </div>
            <div class="flex">
                <input type="text" id="chatInput" class="flex-grow bg-gray-600 text-gray-200 border border-gray-500 rounded-l-lg p-2 focus:ring-teal-500 focus:border-teal-500 outline-none" placeholder="MesajÄ±nÄ±zÄ± yazÄ±n..." disabled>
                <button id="sendMessageBtn" class="bg-teal-500 hover:bg-teal-600 text-white font-bold p-2 rounded-r-lg transition duration-150 ease-in-out" disabled>GÃ¶nder</button>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-gray-800 text-center p-3 text-sm text-gray-500">
        NeoMag v8.0.0 - SimÃ¼lasyon ArayÃ¼zÃ¼ Prototipi
    </footer>

    <!-- Controls -->
    <div class="bg-gray-800 p-4 rounded-lg mb-4">
        <div class="flex flex-wrap gap-2 mb-4">
            <button data-action="start-simulation" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded">
                â–¶ï¸ BaÅŸlat
            </button>
            <button data-action="pause-simulation" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded">
                â¸ï¸ Duraklat
            </button>
            <button data-action="reset-simulation" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">
                ğŸ”„ Reset
            </button>
            <button data-action="add-bacteria" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">
                â• Bakteri Ekle
            </button>
            <button data-action="toggle-group-chat" class="bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded">
                ğŸ’¬ Grup Chat
            </button>
        </div>
        
        <!-- v825: Database Controls -->
        <div class="flex flex-wrap gap-2 mb-2">
            <button data-action="export-csv" class="bg-cyan-600 hover:bg-cyan-700 px-3 py-1 rounded text-sm">
                ğŸ“Š CSV Export
            </button>
            <button data-action="export-json" class="bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded text-sm">
                ğŸ“ˆ JSON Export
            </button>
            <button data-action="save-all" class="bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded text-sm">
                ğŸ’¾ Save All
            </button>
            <button data-action="load-saved" class="bg-teal-600 hover:bg-teal-700 px-3 py-1 rounded text-sm">
                ğŸ“– Load Saved
            </button>
            <button data-action="clear-db" class="bg-red-500 hover:bg-red-600 px-3 py-1 rounded text-sm">
                ğŸ—‘ï¸ Clear DB
            </button>
            <button data-action="show-db-stats" class="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm">
                ğŸ“ˆ DB Stats
            </button>
            <button data-action="show-learning-stats" class="bg-purple-600 hover:bg-purple-700 px-3 py-1 rounded text-sm">
                ğŸ§  AI Learning
            </button>
        </div>
        
        <div class="text-xs text-gray-300">
            ğŸ§¾ Persistent Database: Auto-save every 30s | â™¾ï¸ Unlimited Consciousness | ğŸ“Š TabPFN-ready CSV | ğŸ¨ Canvas Rendering
        </div>
    </div>

    <script>
        // DOM Elements
        const simulationArea = document.getElementById('simulationArea');
        const bacteriaDetailsDiv = document.getElementById('bacteriaDetails');
        const detailsHeader = document.getElementById('detailsHeader');
        const bacteriaIdSpan = document.getElementById('bacteriaId');
        const bacteriaNameSpan = document.getElementById('bacteriaName');
        const bacteriaSizeSpan = document.getElementById('bacteriaSize');
        const bacteriaAgeSpan = document.getElementById('bacteriaAge');
        const bacteriaGrowthRateSpan = document.getElementById('bacteriaGrowthRate');
        const bacteriaConsciousnessSpan = document.getElementById('bacteriaConsciousness');
        const bacteriaOptimismSpan = document.getElementById('bacteriaOptimism');
        const bacteriaSociabilitySpan = document.getElementById('bacteriaSociability');
        const bacteriaLanguageStageSpan = document.getElementById('bacteriaLanguageStage');
        const bacteriaVocabularySpan = document.getElementById('bacteriaVocabulary');

        const chatInfoDiv = document.getElementById('chatInfo');
        const chatMessagesDiv = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const chatLoadingIndicator = document.getElementById('chatLoadingIndicator');

        const startSimulationBtn = document.getElementById('startSimulationBtn');
        const nextStepBtn = document.getElementById('nextStepBtn');
        const resetSimulationBtn = document.getElementById('resetSimulationBtn');
        const simulationTimeSpan = document.getElementById('simulationTime');

        // Simulation State
        let bacteriaPopulation = [];
        let bacteriaList = []; // v826 compatibility
        let bacteriaIdCounter = 1; // v826 ID tracking
        let foodParticles = [];
        let selectedBacteria = null;
        let simulationRunning = false;
        let simulationDay = 0; // Global simulation day counter
        
        // Initialize persistentDB early (null safety)
        var persistentDB = null;
        
        // ğŸ¯ EVENT-DRIVEN INITIALIZATION SYSTEM
        class SimpleEventEmitter {
            constructor() {
                this.listeners = {};
            }
            
            on(event, callback) {
                if (!this.listeners[event]) {
                    this.listeners[event] = [];
                }
                this.listeners[event].push(callback);
            }
            
            emit(event, data) {
                if (this.listeners[event]) {
                    this.listeners[event].forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error(`ğŸš¨ Event callback error for '${event}':`, error);
                        }
                    });
                }
            }
            
            off(event, callback) {
                if (this.listeners[event]) {
                    this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
                }
            }
        }
        
        // Global event system
        const appEvents = new SimpleEventEmitter();
        
        // ğŸ§  SELF-IMPROVEMENT SYSTEM
        class SystemLearningEngine {
            constructor() {
                this.decisionLog = [];
                this.errorPatterns = new Map();
                this.successPatterns = new Map();
                this.confidenceThreshold = 0.7;
                this.maxLogSize = 1000;
                this.isLearning = true;
            }
            
            // Log AI decision with context
            logDecision(source, input, output, confidence, context = {}) {
                const logEntry = {
                    timestamp: Date.now(),
                    source, // 'tabpfn', 'tfjs', 'genetic' etc.
                    input: this.sanitizeInput(input),
                    output,
                    confidence,
                    context,
                    outcome: null // Will be filled later
                };
                
                this.decisionLog.push(logEntry);
                
                // Keep log size manageable
                if (this.decisionLog.length > this.maxLogSize) {
                    this.decisionLog.shift();
                }
                
                return logEntry;
            }
            
            // Track the outcome of a decision
            trackOutcome(logEntry, outcome, metrics = {}) {
                if (logEntry && typeof logEntry === 'object') {
                    logEntry.outcome = outcome; // 'success', 'failure', 'neutral'
                    logEntry.metrics = metrics; // age, consciousness change, survival etc.
                    
                    this.updatePatterns(logEntry);
                }
            }
            
            updatePatterns(logEntry) {
                const pattern = this.extractPattern(logEntry);
                const patternKey = JSON.stringify(pattern);
                
                if (logEntry.outcome === 'success') {
                    const current = this.successPatterns.get(patternKey) || { count: 0, confidence: 0 };
                    current.count++;
                    current.confidence = (current.confidence * (current.count - 1) + logEntry.confidence) / current.count;
                    this.successPatterns.set(patternKey, current);
                } else if (logEntry.outcome === 'failure') {
                    const current = this.errorPatterns.get(patternKey) || { count: 0, avgConfidence: 0 };
                    current.count++;
                    current.avgConfidence = (current.avgConfidence * (current.count - 1) + logEntry.confidence) / current.count;
                    this.errorPatterns.set(patternKey, current);
                }
            }
            
            extractPattern(logEntry) {
                // Extract key features that might indicate success/failure patterns
                return {
                    source: logEntry.source,
                    inputType: typeof logEntry.input,
                    confidenceRange: Math.floor(logEntry.confidence * 10) / 10,
                    contextSize: Object.keys(logEntry.context).length
                };
            }
            
            // Check if a decision might be risky based on learned patterns
            assessRisk(source, input, confidence, context = {}) {
                const pattern = {
                    source,
                    inputType: typeof input,
                    confidenceRange: Math.floor(confidence * 10) / 10,
                    contextSize: Object.keys(context).length
                };
                
                const patternKey = JSON.stringify(pattern);
                const errorPattern = this.errorPatterns.get(patternKey);
                
                if (errorPattern && errorPattern.count > 3) {
                    return {
                        isRisky: true,
                        riskLevel: Math.min(errorPattern.count / 10, 1),
                        suggestion: 'Consider using fallback or lower confidence threshold'
                    };
                }
                
                return { isRisky: false, riskLevel: 0 };
            }
            
            sanitizeInput(input) {
                // Prevent circular references and limit size
                try {
                    return JSON.parse(JSON.stringify(input));
                } catch {
                    return { type: typeof input, size: String(input).length };
                }
            }
            
            getStats() {
                return {
                    totalDecisions: this.decisionLog.length,
                    errorPatterns: this.errorPatterns.size,
                    successPatterns: this.successPatterns.size,
                    recentSuccessRate: this.calculateRecentSuccessRate()
                };
            }
            
            calculateRecentSuccessRate() {
                const recent = this.decisionLog.slice(-50); // Last 50 decisions
                const withOutcome = recent.filter(log => log.outcome);
                const successes = withOutcome.filter(log => log.outcome === 'success');
                return withOutcome.length > 0 ? successes.length / withOutcome.length : 0;
            }
        }
        
        // Global learning engine
        const learningEngine = new SystemLearningEngine();
        
        // ğŸ¨ CANVAS SYSTEM INITIALIZATION
        function initializeCanvasSystem() {
            const canvas = document.getElementById('simCanvas');
            if (!canvas) {
                console.warn('Canvas element not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            canvas.width = CONFIG.CANVAS.SIMULATION_AREA_WIDTH;
            canvas.height = CONFIG.CANVAS.SIMULATION_AREA_HEIGHT;
            
            console.log('âœ… Canvas system initialized');
        }
        
        // ğŸ§¬ BACTERIA POPULATION INITIALIZATION
        function initializeBacteriaPopulation() {
            bacteriaPopulation = [];
            bacteriaList = [];
            
            for (let i = 0; i < CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT; i++) {
                const bacteria = new BacteriaEntity(bacteriaIdCounter, `Bakteri-${bacteriaIdCounter}`);
                bacteriaPopulation.push(bacteria);
                bacteriaList.push(bacteria); // v826 compatibility
                bacteriaIdCounter++;
            }
            
            console.log(`âœ… ${CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT} bacteria initialized`);
        }
        // Simulation State Management
        class SimulationManager {
            constructor() {
                this.isRunning = false;
                this.simulationDay = 0;
                this.lastFrameTime = 0;
                this.lastSimulationStep = 0;
                this.frameCount = 0;
                this.fpsDisplay = document.getElementById('fpsDisplay');
                this.gameLoop = this.gameLoop.bind(this);
            }

            gameLoop(timestamp) {
                if (!this.isRunning) return;
                
                // Calculate FPS
                this.frameCount++;
                const deltaTime = timestamp - this.lastFrameTime;
                
                // Update FPS display every second with memory info
                if (deltaTime >= CONFIG.UI.FPS_UPDATE_INTERVAL) {
                    const fps = Math.round(this.frameCount / (deltaTime / 1000));
                    const memInfo = MemoryManager.getMemoryUsage();
                    const displayText = memInfo.used > 0 
                        ? `FPS: ${fps} | MEM: ${memInfo.used}MB`
                        : `FPS: ${fps}`;
                    if (this.fpsDisplay) this.fpsDisplay.textContent = displayText;
                    
                    // Header bilgilerini gÃ¼ncelle (GÃ¼n ve Bakteri SayÄ±sÄ±)
                    const dayDisplay = document.getElementById('dayDisplay');
                    const bacteriaCountDisplay = document.getElementById('bacteriaCount');
                    if (dayDisplay) dayDisplay.textContent = `GÃ¼n: ${this.simulationDay}`;
                    if (bacteriaCountDisplay) bacteriaCountDisplay.textContent = `Bakteri: ${bacteriaPopulation.length}`;
                    
                    this.frameCount = 0;
                    this.lastFrameTime = timestamp;
                }
                
                // Run simulation step at intervals
                if (timestamp - this.lastSimulationStep >= CONFIG.SIMULATION.STEP_INTERVAL) {
                    this.simulationStep();
                    this.lastSimulationStep = timestamp;
                }
                
                // Render (every frame for smooth animation)
                renderBacteria();
                
                requestAnimationFrame(this.gameLoop);
            }

            start() {
                if (this.isRunning) return;
                this.isRunning = true;
                this.lastFrameTime = performance.now();
                this.lastSimulationStep = performance.now();
                requestAnimationFrame(this.gameLoop);
                systemStatus.simulation = true;
                appEvents.emit('simulation:started');
                console.log('ğŸš€ Simulation started with requestAnimationFrame');
            }

            pause() {
                this.isRunning = false;
                systemStatus.simulation = false;
                appEvents.emit('simulation:paused');
                console.log('â¸ï¸ Simulation paused');
            }

            reset() {
                this.pause();
                this.simulationDay = 0;
                simulationDay = 0;
                bacteriaPopulation = [];
                bacteriaList = [];
                foodParticles = [];
                selectedBacteria = null;
                bacteriaIdCounter = 1;
                console.log('ğŸ”„ Simulation reset completed');
            }

            simulationStep() {
                this.simulationDay++;
                simulationDay = this.simulationDay; // Global ile senkronize
                simulationTimeSpan.textContent = `SimÃ¼lasyon ZamanÄ±: ${this.simulationDay} gÃ¼n`;
                
                // Auto-generate food for sustained ecosystem
                if (Math.random() < CONFIG.SIMULATION.AUTO_FOOD_GENERATION_CHANCE) {
                    addRandomFood();
                }
                
                bacteriaPopulation.forEach((bacteria, index) => {
                    if (!bacteria || typeof bacteria.updateDaily !== 'function') {
                        console.warn(`âš ï¸ Invalid bacteria at index ${index}, removing...`);
                        return;
                    }
                    
                    try {
                        bacteria.updateDaily();
                        bacteria.move();
                        
                        // More frequent reproduction checks for dynamic population
                        if (this.simulationDay % 2 === 0 && typeof bacteria.checkForReproduction === 'function') {
                            bacteria.checkForReproduction();
                        }
                    } catch (error) {
                        console.error(`âŒ Error in simulation step for bacteria ${bacteria.id}:`, error);
                        // Remove problematic bacteria to prevent further errors
                        bacteriaPopulation.splice(index, 1);
                    }
                });
                
                // Remove dead or invalid bacteria
                bacteriaPopulation = bacteriaPopulation.filter(bacteria => 
                    bacteria && typeof bacteria.x === 'number' && bacteria.biological_state
                );
                
                // Periodic memory cleanup (every 100 simulation steps)
                if (this.simulationDay % 100 === 0) {
                    MemoryManager.cleanup();
                }
                
                if (selectedBacteria) {
                    updateBacteriaDetails(selectedBacteria);
                }
            }
        }

        // Global simulation manager (will be initialized in mainInitialize)
        let simulationManager = null;

        // Configuration Constants (centralized for better maintainability)
        const CONFIG = {
            SIMULATION: {
                INITIAL_BACTERIA_COUNT: 10,
                STEP_INTERVAL: 500, // ms - 6x faster simulation
                MAX_BACTERIA_POPULATION: 20,
                AUTO_FOOD_GENERATION_CHANCE: 0.7
            },
            BACTERIA: {
                MAX_SIZE: 3.5,
                BASE_GROWTH_RATE: 0.08,
                REPRODUCTION_MIN_AGE: 3,
                REPRODUCTION_MIN_SIZE: 1.2,
                REPRODUCTION_MIN_CONSCIOUSNESS: 1.0,
                REPRODUCTION_MIN_VOCABULARY: 5
            },
            CANVAS: {
                WIDTH: 800,
                HEIGHT: 600,
                SIMULATION_AREA_WIDTH: 480,
                SIMULATION_AREA_HEIGHT: 280
            },
            UI: {
                MAX_VOCABULARY_DISPLAY: 10,
                FOOD_SIZE: 8,
                FPS_UPDATE_INTERVAL: 1000,
                PERFORMANCE_LOG_INTERVAL: 10000
            },
            PHYSICS: {
                INTERACTION_RANGE: 50,
                Z_DEPTH_MIN: 20,
                Z_DEPTH_MAX: 180,
                BOUNDARY_ENERGY_LOSS: 0.9
            },
            AI: {
                NEURAL_NETWORK_LAYERS: [12, 16, 12, 6], // Input, Hidden1, Hidden2, Output
                LEARNING_RATE: 0.15,
                MEMORY_CAPACITY: 100,
                EXPERIENCE_REPLAY_SIZE: 30,
                GENETIC_MUTATION_RATE: 0.12,
                FITNESS_DECAY: 0.92,
                BEHAVIOR_ADAPTATION_RATE: 0.1,
                NEURAL_EVOLUTION_RATE: 0.05,
                DECISION_THRESHOLD: 0.6,
                CONSCIOUSNESS_BOOST_RATE: 0.02
            },
            VOCABULARY: {
                TABPFN_ACCELERATION: true,
                CONTEXTUAL_LEARNING_RATE: 0.25,
                PROGRESSIVE_UNLOCK_THRESHOLD: 0.8,
                SOCIAL_LEARNING_MULTIPLIER: 1.5,
                CONSCIOUSNESS_WORD_RATIO: 0.1 // Words per consciousness level
            }
        };

        // Version and Build Info (moved up to prevent hoisting issues)
        const VERSION = 'v8.5.0';
        const BUILD_DATE = new Date().toISOString().slice(0,19);
        const FEATURES = [
            'Frontend-Only TabPFN (Mobile Compatible)',
            'Smart Contextual Word Usage',
            'Intelligent Vocabulary Management',
            'TabPFN-Style Behavior Classification',
            'Enhanced Conversation Intelligence',
            'Single HTML File Solution',
            'Real-time < 1 Second Predictions',
            'Dynamic AI Model Training',
            'Live Training Data Collection',
            'Dynamic Hunger & Energy Systems',
            'Persistent Database System',
            'Unlimited Consciousness Levels',
            'CSV Data Export/Import',
            'State Restoration',
            'Enhanced Environment Visualization',
            'Bacteria ID Labels',
            'Cross-Bacteria Learning',
            'Group Chat System',
            'Molecular Dynamics Simulation',
            'High-Speed Movement & Dynamics',
            'Auto Food Generation',
            'Enhanced Reproduction System'
        ];
        const FOOD_NUTRITION = 0.5;

        // Chat State
        let chatMode = 'individual'; // 'individual', 'group'
        let bacteriaConversationTimer = null;
        let lastBacteriaConversationTime = 0;
        
        // v826: Individual Chat Windows System
        let globalConversations = []; // All bacteria-to-bacteria conversations
        let openChatWindows = new Map(); // bacteria.id -> modal element
        let chatWindowZIndex = 1000;

        // Advanced AI/ML State  
        let wordEmbeddingModel = null;
        let behaviorPredictionModel = null;
        let isMLReady = false;
        let wordTokenizer = new Map();
        let globalNeuralNetwork = null;
        let geneticAlgorithm = null;
        let behaviourLearningSystem = null;
        let tabpfnVocabularySystem = null;

        // ğŸ“š 1500 Kelimelik Kategorize Åablon + TabPFN HÄ±zlandÄ±rma
        const MASTER_VOCABULARY = {
            // Temel DÃ¼zey (Consciousness 0-1) - 300 kelime
            basic: [
                // Temel ihtiyaÃ§lar (50 kelime)
                'aÃ§', 'tok', 'yardÄ±m', 'hareket', 'dinlen', 'uyu', 'uyan', 'nefes', 'kalp', 'vÃ¼cut',
                'el', 'ayak', 'gÃ¶z', 'kulak', 'aÄŸÄ±z', 'burun', 'kafa', 'beden', 'can', 'hayat',
                'su', 'yemek', 'ekmek', 'sÃ¼t', 'meyve', 'et', 'balÄ±k', 'sebze', 'tatlÄ±', 'acÄ±',
                'sÄ±cak', 'soÄŸuk', 'Ä±sÄ±', 'rÃ¼zgar', 'gÃ¼neÅŸ', 'ay', 'yÄ±ldÄ±z', 'gece', 'gÃ¼ndÃ¼z', 'sabah',
                'Ã¶ÄŸle', 'akÅŸam', 'zaman', 'dakika', 'saat', 'gÃ¼n', 'hafta', 'ay', 'yÄ±l', 'yaÅŸ',
                
                // Duygular (50 kelime)
                'mutlu', 'Ã¼zgÃ¼n', 'kÄ±zgÄ±n', 'korku', 'endiÅŸe', 'heyecan', 'ÅŸaÅŸÄ±rma', 'merak', 'sevinÃ§', 'Ã¼zÃ¼ntÃ¼',
                'Ã¶fke', 'kÄ±skanÃ§lÄ±k', 'gurur', 'utanÃ§', 'piÅŸmanlÄ±k', 'umut', 'hayal', 'rÃ¼ya', 'dÃ¼ÅŸ', 'fikir',
                'sevgi', 'aÅŸk', 'dostluk', 'saygÄ±', 'gÃ¼ven', 'inanÃ§', 'ÅŸÃ¼phe', 'kaygÄ±', 'stres', 'rahat',
                'huzur', 'barÄ±ÅŸ', 'savaÅŸ', 'kavga', 'tartÄ±ÅŸma', 'anlaÅŸma', 'uzlaÅŸma', 'Ã§Ã¶zÃ¼m', 'sorun', 'sÄ±kÄ±ntÄ±',
                'zorluk', 'kolay', 'zor', 'basit', 'karmaÅŸÄ±k', 'anlaÅŸÄ±lÄ±r', 'belirsiz', 'net', 'aÃ§Ä±k', 'kapalÄ±',
                
                // Temel eylemler (50 kelime)
                'git', 'gel', 'koÅŸ', 'yÃ¼rÃ¼', 'dur', 'otur', 'kalk', 'yat', 'Ã§Ä±k', 'gir',
                'al', 'ver', 'bÄ±rak', 'tut', 'at', 'Ã§ek', 'it', 'kaldÄ±r', 'indir', 'taÅŸÄ±',
                'yap', 'boz', 'kur', 'yÄ±k', 'temizle', 'kirlet', 'aÃ§', 'kapat', 'baÅŸla', 'bitir',
                'devam', 'kes', 'bÃ¶l', 'birleÅŸtir', 'ayÄ±r', 'topla', 'Ã§Ä±kar', 'Ã§arp', 'bÃ¶l', 'say',
                'oku', 'yaz', 'Ã§iz', 'boya', 'sil', 'dÃ¼zelt', 'deÄŸiÅŸtir', 'koru', 'sav', 'kaÃ§Ä±n',
                
                // Renkler ve ÅŸekiller (30 kelime)
                'kÄ±rmÄ±zÄ±', 'mavi', 'yeÅŸil', 'sarÄ±', 'turuncu', 'mor', 'pembe', 'beyaz', 'siyah', 'gri',
                'kahverengi', 'altÄ±n', 'gÃ¼mÃ¼ÅŸ', 'renk', 'parlak', 'mat', 'ÅŸeffaf', 'opak', 'Ä±ÅŸÄ±k', 'karanlÄ±k',
                'yuvarlak', 'kare', 'Ã¼Ã§gen', 'dikdÃ¶rtgen', 'oval', 'dÃ¼z', 'eÄŸri', 'uzun', 'kÄ±sa', 'geniÅŸ',
                
                // SayÄ±lar ve matematik (30 kelime)
                'bir', 'iki', 'Ã¼Ã§', 'dÃ¶rt', 'beÅŸ', 'altÄ±', 'yedi', 'sekiz', 'dokuz', 'on',
                'yirmi', 'otuz', 'kÄ±rk', 'elli', 'yÃ¼z', 'bin', 'milyon', 'sÄ±fÄ±r', 'hiÃ§', 'Ã§ok',
                'az', 'fazla', 'eksik', 'tam', 'yarÄ±m', 'Ã§eyrek', 'Ã¼Ã§te', 'bÃ¼yÃ¼k', 'kÃ¼Ã§Ã¼k', 'orta',
                
                // Aile ve sosyal (40 kelime)
                'anne', 'baba', 'Ã§ocuk', 'kardeÅŸ', 'abla', 'aÄŸabey', 'dede', 'nine', 'teyze', 'amca',
                'dayÄ±', 'hala', 'kuzen', 'arkadaÅŸ', 'dost', 'komÅŸu', 'Ã¶ÄŸretmen', 'doktor', 'hemÅŸire', 'polis',
                'itfaiye', 'pilot', 'ÅŸofÃ¶r', 'kasap', 'berber', 'terzi', 'bakkal', 'eczacÄ±', 'avukat', 'mÃ¼hendis',
                'iÅŸÃ§i', 'patron', 'mÃ¼dÃ¼r', 'baÅŸkan', 'lider', 'takipÃ§i', 'grup', 'takÄ±m', 'ekip', 'toplum'
            ],
            
            // Sosyal DÃ¼zey (Consciousness 1-5) - 400 kelime  
            social: [
                // Ä°letiÅŸim (100 kelime)
                'merhaba', 'gÃ¼naydÄ±n', 'iyi akÅŸamlar', 'hoÅŸÃ§a kal', 'gÃ¶rÃ¼ÅŸÃ¼rÃ¼z', 'teÅŸekkÃ¼rler', 'rica ederim', 'Ã¶zÃ¼r dilerim', 'pardon', 'kusura bakma',
                'konuÅŸ', 'dinle', 'anlat', 'sor', 'cevap', 'soru', 'yanÄ±t', 'aÃ§Ä±kla', 'tarif', 'gÃ¶ster',
                'iÅŸaret', 'ima', 'jest', 'mimik', 'ses', 'ton', 'vurgu', 'melodei', 'ritim', 'sessizlik',
                'gÃ¼lÃ¼mseme', 'kahkaha', 'aÄŸlama', 'Ã§Ä±ÄŸlÄ±k', 'fÄ±sÄ±lda', 'baÄŸÄ±r', 'ÅŸarkÄ±', 'mÃ¼zik', 'dans', 'oyun',
                'eÄŸlence', 'parti', 'kutlama', 'doÄŸum gÃ¼nÃ¼', 'bayram', 'tatil', 'festival', 'ÅŸenlik', 'toplantÄ±', 'buluÅŸma',
                'randevu', 'gÃ¶rÃ¼ÅŸme', 'sohbet', 'chat', 'mesaj', 'mektup', 'telefon', 'internet', 'sosyal medya', 'paylaÅŸÄ±m',
                'beÄŸeni', 'yorum', 'eleÅŸtiri', 'Ã¶vgÃ¼', 'takdir', 'hayranlÄ±k', 'kÄ±skanÃ§lÄ±k', 'rekabet', 'yarÄ±ÅŸ', 'kazanma',
                'kaybetme', 'baÅŸarÄ±', 'baÅŸarÄ±sÄ±zlÄ±k', 'deneme', 'Ã§aba', 'emek', 'Ã§alÄ±ÅŸma', 'dinlenme', 'tatil', 'gezi',
                'macera', 'keÅŸif', 'araÅŸtÄ±rma', 'inceleme', 'gÃ¶zlem', 'izleme', 'takip', 'analiz', 'deÄŸerlendirme', 'karar',
                'seÃ§im', 'tercih', 'Ã¶ncelik', 'Ã¶nem', 'deÄŸer', 'kÄ±ymet', 'fiyat', 'maliyet', 'kazanÃ§', 'gelir',
                
                // Duygusal zeka (100 kelime)
                'empati', 'anlayÄ±ÅŸ', 'hoÅŸgÃ¶rÃ¼', 'sabÄ±r', 'dayanÄ±klÄ±lÄ±k', 'cesaret', 'korkaklÄ±k', 'atÄ±lgan', 'Ã§ekingen', 'sosyal',
                'asosyal', 'ekstrovert', 'introvert', 'neÅŸeli', 'melankolik', 'iyimser', 'karamsar', 'realist', 'idealist', 'pragmatik',
                'romantik', 'mantÄ±klÄ±', 'duygusal', 'rasyonel', 'irrasyonel', 'objektif', 'subjektif', 'tarafsÄ±z', 'Ã¶nyargÄ±lÄ±', 'adil',
                'haksÄ±z', 'dÃ¼rÃ¼st', 'yalancÄ±', 'samimi', 'sahte', 'iÃ§ten', 'dÄ±ÅŸardan', 'aÃ§Ä±k', 'gizli', 'ÅŸeffaf',
                'kapalÄ±', 'gizemli', 'anlaÅŸÄ±labilir', 'karmaÅŸÄ±k', 'basit', 'sade', 'sÃ¼slÃ¼', 'gÃ¶steriÅŸli', 'mÃ¼tevazÄ±', 'kibirli',
                'alÃ§akgÃ¶nÃ¼llÃ¼', 'gururlu', 'utangaÃ§', 'Ã§ekinmez', 'kendine gÃ¼venen', 'gÃ¼vensiz', 'kararlÄ±', 'kararsÄ±z', 'istikrarlÄ±', 'deÄŸiÅŸken',
                'tutarlÄ±', 'tutarsÄ±z', 'gÃ¼venilir', 'gÃ¼venilmez', 'sadÄ±k', 'vefasÄ±z', 'baÄŸlÄ±', 'baÄŸÄ±msÄ±z', 'Ã¶zgÃ¼r', 'esir',
                'hÃ¼r', 'kÃ¶le', 'efendi', 'hizmetkar', 'lider', 'takipÃ§i', 'yÃ¶neten', 'yÃ¶netilen', 'aktif', 'pasif',
                'giriÅŸken', 'miskin', 'Ã§alÄ±ÅŸkan', 'tembel', 'hÄ±zlÄ±', 'yavaÅŸ', 'aceleci', 'sabÄ±rlÄ±', 'titiz', 'daÄŸÄ±nÄ±k',
                'dÃ¼zenli', 'disiplinli', 'serbest', 'kontrollÃ¼', 'kendiliÄŸinden', 'bilinÃ§li', 'bilinÃ§siz', 'farkÄ±nda', 'habersiz', 'uyanÄ±k',
                
                // Ä°liÅŸkiler (100 kelime)
                'sevgili', 'eÅŸ', 'niÅŸanlÄ±', 'flÃ¶rt', 'buÃ§uk', 'yalnÄ±z', 'bekar', 'evli', 'boÅŸanmÄ±ÅŸ', 'dul',
                'yakÄ±n', 'uzak', 'samimi', 'soÄŸuk', 'sÄ±cak', 'mesafeli', 'yakÄ±nlaÅŸma', 'uzaklaÅŸma', 'buluÅŸma', 'ayrÄ±lma',
                'kavuÅŸma', 'hasret', 'Ã¶zlem', 'ayrÄ±lÄ±k', 'veda', 'hoÅŸÃ§a kal', 'elveda', 'gÃ¼le gÃ¼le', 'yolculuk', 'dÃ¶nÃ¼ÅŸ',
                'varÄ±ÅŸ', 'gidiÅŸ', 'geliÅŸgit', 'ilerleme', 'gerileme', 'geliÅŸme', 'bÃ¼yÃ¼me', 'kÃ¼Ã§Ã¼lme', 'artma', 'azalma',
                'Ã§oÄŸalma', 'eksilme', 'deÄŸiÅŸme', 'dÃ¶nÃ¼ÅŸÃ¼m', 'evrim', 'devrim', 'yenilik', 'eskime', 'kÃ¶hneme', 'yenileme',
                'tazeleme', 'canlanma', 'Ã¶lme', 'yaÅŸama', 'hayat', 'Ã¶lÃ¼m', 'doÄŸum', 'bÃ¼yÃ¼me', 'yaÅŸlanma', 'genÃ§lik',
                'Ã§ocukluk', 'ergenlik', 'yetiÅŸkinlik', 'olgunluk', 'deneyim', 'tecrÃ¼be', 'bilgi', 'bilim', 'Ã¶ÄŸrenme', 'Ã¶ÄŸretme',
                'eÄŸitim', 'Ã¶ÄŸretim', 'ders', 'kurs', 'seminer', 'konferans', 'toplantÄ±', 'panel', 'tartÄ±ÅŸma', 'mÃ¼nazara',
                'sohbet', 'muhabbet', 'dedikodu', 'sÃ¶ylenti', 'rivayet', 'hikaye', 'masal', 'efsane', 'mit', 'gerÃ§ek',
                'hayal', 'dÃ¼ÅŸ', 'rÃ¼ya', 'kabus', 'Ã¼mit', 'beklenti', 'plan', 'proje', 'hedef', 'amaÃ§',
                
                // KÃ¼ltÃ¼r ve deÄŸerler (100 kelime)
                'gelenek', 'gÃ¶renek', 'adet', 'Ã¶rf', 'kÃ¼ltÃ¼r', 'medeniyet', 'uygarlÄ±k', 'sanat', 'edebiyat', 'ÅŸiir',
                'roman', 'hikaye', 'tiyatro', 'sinema', 'film', 'dizi', 'program', 'haber', 'gazete', 'dergi',
                'kitap', 'sayfa', 'paragraf', 'cÃ¼mle', 'kelime', 'harf', 'nokta', 'virgÃ¼l', 'soru iÅŸareti', 'Ã¼nlem',
                'alfabe', 'dil', 'lehÃ§e', 'aÄŸÄ±z', 'ÅŸive', 'aksant', 'tonlama', 'telaffuz', 'diksiyon', 'gramer',
                'sÃ¶zdizimi', 'morfoloji', 'fonetik', 'etimoloji', 'semantik', 'pragmatik', 'dilbilim', 'Ã§evirmen', 'tercÃ¼man', 'sÃ¶zlÃ¼k',
                'ansiklopedi', 'atlÄ±s', 'rehber', 'kÄ±lavuz', 'manual', 'broÅŸÃ¼r', 'katalog', 'liste', 'Ã§izelge', 'tablo',
                'grafik', 'diagram', 'harita', 'plan', 'kroki', 'Ã§izim', 'resim', 'fotoÄŸraf', 'gÃ¶rÃ¼ntÃ¼', 'gÃ¶rsel',
                'ses', 'mÃ¼zik', 'melodi', 'ritim', 'tempo', 'nota', 'beste', 'besteci', 'mÃ¼zisyen', 'sanatÃ§Ä±',
                'ressam', 'heykeltÄ±raÅŸ', 'mimar', 'tasarÄ±mcÄ±', 'moda', 'stil', 'trend', 'zevk', 'estetik', 'gÃ¼zellik',
                'Ã§irkinlik', 'hoÅŸ', 'nahoÅŸ', 'beÄŸeni', 'eleÅŸtiri', 'yorum', 'gÃ¶rÃ¼ÅŸ', 'fikir', 'dÃ¼ÅŸÃ¼nce', 'inanÃ§'
            ],
            
            // Bilimsel DÃ¼zey (Consciousness 5-10) - 400 kelime
            scientific: [
                // Biyoloji ve yaÅŸam (150 kelime)
                'ATP', 'metabolizma', 'enzim', 'protein', 'amino asit', 'karbonhidrat', 'lipid', 'nÃ¼kleik asit', 'DNA', 'RNA',
                'gen', 'kromozom', 'hÃ¼cre', 'Ã§ekirdek', 'sitoplazma', 'organel', 'mitokondri', 'ribozom', 'lizozom', 'vakuol',
                'endoplazmik retikulum', 'golgi aygÄ±tÄ±', 'sentrozom', 'sitoiskelet', 'hÃ¼cre zarÄ±', 'hÃ¼cre duvarÄ±', 'kloroplast', 'fotosentez', 'solunum', 'fermantasyon',
                'glikoliz', 'krebs dÃ¶ngÃ¼sÃ¼', 'elektron taÅŸÄ±ma zinciri', 'oksitlenme', 'indirgeme', 'redoks', 'katalizÃ¶r', 'substrat', 'Ã¼rÃ¼n', 'reaksiyon',
                'biyokimya', 'molekÃ¼ler biyoloji', 'hÃ¼cre biyolojisi', 'genetik', 'evrim', 'doÄŸal seÃ§ilim', 'mutasyon', 'adaptasyon', 'spesiyasyon', 'biyoÃ§eÅŸitlilik',
                'ekoloji', 'ekosistem', 'habitat', 'niÅŸ', 'populasyon', 'topluluk', 'besin zinciri', 'besin aÄŸÄ±', 'enerji akÄ±ÅŸÄ±', 'besin dÃ¶ngÃ¼sÃ¼',
                'karbon dÃ¶ngÃ¼sÃ¼', 'nitrojen dÃ¶ngÃ¼sÃ¼', 'oksijen dÃ¶ngÃ¼sÃ¼', 'su dÃ¶ngÃ¼sÃ¼', 'iklim', 'hava durumu', 'atmosfer', 'hidrosfer', 'litosfer', 'biyosfer',
                'biyom', 'orman', 'Ã§ayÄ±r', 'Ã§Ã¶l', 'tundra', 'savana', 'sulak alan', 'okyanus', 'deniz', 'gÃ¶l',
                'nehir', 'dere', 'kaynak', 'yeraltÄ± suyu', 'buzul', 'kar', 'yaÄŸmur', 'buhar', 'nem', 'sÄ±caklÄ±k',
                'basÄ±nÃ§', 'rÃ¼zgar', 'fÄ±rtÄ±na', 'kasÄ±rga', 'tornado', 'deprem', 'volkan', 'tsunami', 'sel', 'kuraklÄ±k',
                'kÃ¼resel Ä±sÄ±nma', 'iklim deÄŸiÅŸikliÄŸi', 'sera etkisi', 'ozon tabakasÄ±', 'kirlilik', 'geri dÃ¶nÃ¼ÅŸÃ¼m', 'sÃ¼rdÃ¼rÃ¼lebilirlik', 'yenilenebilir enerji', 'fosil yakÄ±t', 'nÃ¼kleer enerji',
                'mikroorganizma', 'bakteri', 'virÃ¼s', 'mantar', 'protozoa', 'alg', 'bitki', 'hayvan', 'omurgalÄ±', 'omurgasÄ±z',
                'memeli', 'kuÅŸ', 'sÃ¼rÃ¼ngen', 'amfibi', 'balÄ±k', 'bÃ¶cek', 'artropod', 'yumuÅŸakÃ§a', 'solucan', 'zooplankton',
                'fitoplankton', 'bentik', 'pelagik', 'litorel', 'derin deniz', 'abissal', 'hadal', 'biyolÃ¼minesans', 'kamuflaj', 'mimikri',
                'simbioz', 'mutualizma', 'komensalizm', 'parazitizm', 'predasyon', 'otobur', 'etobur', 'hepÃ§il', 'detritivor', 'dekompozitÃ¶r'
            ],
            
            // Fizik ve kimya (150 kelime)
            physics: [
                'atom', 'elektron', 'proton', 'nÃ¶tron', 'kuark', 'lepton', 'bozon', 'fermiyon', 'parÃ§acÄ±k', 'dalga',
                'enerji', 'kÃ¼tle', 'kuvvet', 'ivme', 'hÄ±z', 'hÄ±zlanma', 'momentum', 'tork', 'aÃ§Ä±sal momentum', 'inersia',
                'sÃ¼rtÃ¼nme', 'yerÃ§ekimi', 'elektromanyetizma', 'gÃ¼Ã§lÃ¼ nÃ¼kleer kuvvet', 'zayÄ±f nÃ¼kleer kuvvet', 'alan', 'potansiyel', 'kinetik', 'termodinamik', 'entropi',
                'entalpi', 'iÃ§ enerji', 'Ä±sÄ± kapasitesi', 'Ä±sÄ± iletimi', 'konveksiyon', 'radyasyon', 'sÄ±caklÄ±k', 'basÄ±nÃ§', 'hacim', 'yoÄŸunluk',
                'faz', 'katÄ±', 'sÄ±vÄ±', 'gaz', 'plazma', 'bose-einstein kondensatÄ±', 'kristal', 'amorf', 'Ã§Ã¶zelti', 'sÃ¼spansiyon',
                'emÃ¼lsiyon', 'koloid', 'mol', 'avogadro sayÄ±sÄ±', 'atomik kÃ¼tle', 'molekÃ¼ler kÃ¼tle', 'periyodik tablo', 'element', 'bileÅŸik', 'karÄ±ÅŸÄ±m',
                'kimyasal baÄŸ', 'kovalent', 'iyonik', 'metalik', 'hidrojen baÄŸÄ±', 'van der waals', 'polar', 'apolar', 'hidrofilik', 'hidrofobik',
                'asit', 'baz', 'pH', 'tampon', 'titrasyons', 'redoks', 'oksidasyon', 'redÃ¼ksiyon', 'elektroliz', 'galvanik hÃ¼cre',
                'katalizÃ¶r', 'aktivasyon enerjisi', 'reaksiyon hÄ±zÄ±', 'denge', 'le chatelier ilkesi', 'konsantrasyon', 'molarite', 'molalite', 'normalite', 'Ã§Ã¶zÃ¼nÃ¼rlÃ¼k',
                'Ã§Ã¶kme', 'kristalleÅŸme', 'buharlaÅŸma', 'yoÄŸuÅŸma', 'sublimleÅŸme', 'erime', 'donma', 'kaynama', 'ergime noktasÄ±', 'kaynama noktasÄ±',
                'Ä±ÅŸÄ±k', 'elektromanyetik spektrum', 'gÃ¶rÃ¼nÃ¼r Ä±ÅŸÄ±k', 'kÄ±zÄ±lÃ¶tesi', 'ultraviyole', 'rÃ¶ntgen', 'gama Ä±ÅŸÄ±nÄ±', 'radyo dalgasÄ±', 'mikrodalga', 'frekans',
                'dalga boyu', 'genlik', 'interferans', 'kÄ±rÄ±nÄ±m', 'polarizasyon', 'yansÄ±ma', 'kÄ±rÄ±lma', 'lenz', 'lens', 'prizma',
                'ayna', 'mikroskop', 'teleskop', 'laser', 'hologram', 'fiber optik', 'spektroskopi', 'fotolÃ¼minesans', 'fosforesan', 'flÃ¼oresan',
                'elektrik', 'akÄ±m', 'voltaj', 'direnÃ§', 'kapasitÃ¶r', 'endÃ¼ktÃ¶r', 'transformatÃ¶r', 'diyot', 'transistÃ¶r', 'entegre devre',
                'manyetik alan', 'elektrik alan', 'elektromanyetik indÃ¼ksiyon', 'faraday yasasÄ±', 'ampere yasasÄ±', 'gauss yasasÄ±', 'maxwell denklemleri', 'kuantum mekaniÄŸi', 'heisenberg belirsizlik', 'schrÃ¶dinger denklemi'
            ],
            
            // Matematik ve mantÄ±k (100 kelime)
            mathematics: [
                'sayÄ±', 'rakam', 'digit', 'basamak', 'pozitif', 'negatif', 'sÄ±fÄ±r', 'sonsuz', 'reel', 'sanal',
                'kompleks', 'rasyonel', 'irrasyonel', 'tam sayÄ±', 'doÄŸal sayÄ±', 'asal sayÄ±', 'Ã§ift', 'tek', 'faktÃ¶riyel', 'kombinasyon',
                'permÃ¼tasyon', 'olasÄ±lÄ±k', 'istatistik', 'ortalama', 'medyan', 'mod', 'standart sapma', 'varyans', 'korelasyon', 'regresyon',
                'grafik', 'koordinat', 'eksren', 'absis', 'ordinat', 'nokta', 'doÄŸru', 'eÄŸri', 'parabol', 'hiperbol',
                'elips', 'Ã§ember', 'daire', 'yarÄ±Ã§ap', 'Ã§ap', 'Ã§evre', 'alan', 'hacim', 'yÃ¼zey', 'kenar',
                'kÃ¶ÅŸe', 'aÃ§Ä±', 'derece', 'radyan', 'trigonometri', 'sinÃ¼s', 'kosinÃ¼s', 'tanjant', 'kotanjant', 'sekant',
                'kosekant', 'logaritma', 'Ã¼s', 'kÃ¶k', 'mutlak deÄŸer', 'tÃ¼rev', 'integral', 'limit', 'sÃ¼reklilik', 'diferansiyel',
                'kÄ±smi tÃ¼rev', 'Ã§oklu integral', 'vektÃ¶r', 'skaler', 'matris', 'determinant', 'Ã¶zvektÃ¶r', 'Ã¶zdeÄŸer', 'lineer dÃ¶nÃ¼ÅŸÃ¼m', 'izdÃ¼ÅŸÃ¼m',
                'topoloji', 'metrik', 'norm', 'iÃ§ Ã§arpÄ±m', 'dÄ±ÅŸ Ã§arpÄ±m', 'gradyan', 'diverjans', 'rotasyonel', 'laplacian', 'harmonik',
                'fourier dÃ¶nÃ¼ÅŸÃ¼mÃ¼', 'konvolÃ¼syon', 'fraktal', 'kaos teorisi', 'grup teorisi', 'halka', 'cisim', 'modÃ¼ler aritmetik', 'sayÄ± teorisi', 'kriptografi'
            ],
            
            // Felsefe ve Meta-biliÅŸsel (Consciousness 10-20) - 300 kelime
            philosophical: [
                // Bilgi teorisi ve epistemoloji (100 kelime)
                'epistemoloji', 'ontoloji', 'metafizik', 'fenomenoloji', 'hermeneutik', 'diyalektik', 'empirizm', 'rasyonalizm', 'pozitivizm', 'pragmatizm',
                'varoluÅŸÃ§uluk', 'nihilizm', 'absÃ¼rdizm', 'determinizm', 'Ã¶zgÃ¼r irade', 'kausalite', 'neden-sonuÃ§', 'tesadÃ¼f', 'olasÄ±lÄ±k', 'belirsizlik',
                'bilgi', 'inanÃ§', 'doÄŸruluk', 'yanlÄ±ÅŸlÄ±k', 'kesinlik', 'ÅŸÃ¼phe', 'skepitizm', 'dogmatizm', 'relativizm', 'objektivite',
                'subjektivite', 'perspektif', 'bakÄ±ÅŸ aÃ§Ä±sÄ±', 'yorumlama', 'anlama', 'kavrama', 'idrak', 'algÄ±', 'bilinÃ§', 'farkÄ±ndalÄ±k',
                'Ã¶z-bilinÃ§', 'meta-kognisyon', 'introspeksiyon', 'refeksiyon', 'dÅŸÃ¼nme', 'akÄ±l', 'mantÄ±k', 'neden', 'analiz', 'sentez',
                'tez', 'antitez', 'sÄ±nÄ±flama', 'kategorizasyon', 'soyutlama', 'somutlama', 'genelleme', 'Ã¶zelleÅŸtirme', 'analoji', 'metafor',
                'sembol', 'iÅŸaret', 'anlam', 'semantik', 'pragmatik', 'sÃ¶zdizimi', 'dil felsefesi', 'tanÄ±m', 'kavram', 'fikir',
                'dÃ¼ÅŸÃ¼nce', 'zihin', 'ruh', 'tin', 'psiÅŸe', 'ego', 'id', 'sÃ¼perego', 'bilinÃ§altÄ±', 'kolektif bilinÃ§altÄ±',
                'arketip', 'persona', 'gÃ¶lge', 'anima', 'animus', 'bireyselleÅŸme', 'transsendans', 'aÅŸkÄ±nlÄ±k', 'iÃ§kinlik', 'absolute',
                'gÃ¶receli', 'baÄŸÄ±l', 'mutlak', 'sonsuz', 'sonlu', 'sÄ±nÄ±r', 'sÄ±nÄ±rsÄ±z', 'paradoks', 'Ã§eliÅŸki', 'tezat'
            ],
            
            // Etik ve deÄŸerler (100 kelime)
            ethics: [
                'etik', 'ahlak', 'deÄŸer', 'norm', 'kural', 'ilke', 'prensip', 'ideal', 'virtue', 'erdem',
                'iyilik', 'kÃ¶tÃ¼lÃ¼k', 'doÄŸru', 'yanlÄ±ÅŸ', 'adalet', 'haksÄ±zlÄ±k', 'eÅŸitlik', 'Ã¶zgÃ¼rlÃ¼k', 'sorumluluk', 'gÃ¶rev',
                'hak', 'Ã¶dev', 'yÃ¼kÃ¼mlÃ¼lÃ¼k', 'vicdan', 'ahlaki', 'vicdani', 'utilitarizm', 'deontoloji', 'virtue etiÄŸi', 'care etiÄŸi',
                'feminist etik', 'Ã§evre etiÄŸi', 'biyoetik', 'tÄ±p etiÄŸi', 'mesleki etik', 'iÅŸ etiÄŸi', 'teknoloji etiÄŸi', 'yapay zeka etiÄŸi', 'robotik etik', 'sanal etik',
                'dijital etik', 'sosyal medya etiÄŸi', 'gizlilik', 'mahremiyet', 'ÅŸeffaflÄ±k', 'hesap verebilirlik', 'gÃ¼ven', 'sadakat', 'doÄŸruluk', 'dÃ¼rÃ¼stlÃ¼k',
                'samimiyet', 'iÃ§tenlik', 'saygÄ±', 'hoÅŸgÃ¶rÃ¼', 'tolerans', 'Ã§okkÃ¼ltÃ¼rlÃ¼lÃ¼k', 'farklÄ±lÄ±k', 'Ã§eÅŸitlilik', 'kapsayÄ±cÄ±lÄ±k', 'ayrÄ±mcÄ±lÄ±k',
                'Ã¶nyargÄ±', 'kalÄ±pyargÄ±', 'adil olmayan', 'eÅŸitsizlik', 'yoksulluk', 'zenginlik', 'sosyal adalet', 'ekonomik adalet', 'daÄŸÄ±tÄ±cÄ± adalet', 'dÃ¼zeltici adalet',
                'insan haklarÄ±', 'temel haklar', 'sivil haklar', 'politik haklar', 'sosyal haklar', 'ekonomik haklar', 'kÃ¼ltÃ¼rel haklar', 'Ã§ocuk haklarÄ±', 'kadÄ±n haklarÄ±', 'azÄ±nlÄ±k haklarÄ±',
                'hayvan haklarÄ±', 'doÄŸa haklarÄ±', 'gelecek nesiller', 'sÃ¼rdÃ¼rÃ¼lebilir kalkÄ±nma', 'intergenerasyon adalet', 'kÃ¼resel adalet', 'kozmopolit etik', 'milliyetÃ§ilik', 'vatanseverlik', 'barÄ±ÅŸ',
                'savaÅŸ', 'ÅŸiddet', 'ÅŸiddetsizlik', 'direniÅŸ', 'itaatsizlik', 'sivil itaatsizlik', 'demokrasi', 'otorite', 'gÃ¼Ã§', 'iktidar'
            ],
            
            // Estetik ve sanat felsefesi (100 kelime)
            aesthetics: [
                'estetik', 'gÃ¼zellik', 'sanat', 'yaratÄ±cÄ±lÄ±k', 'hayal gÃ¼cÃ¼', 'inspirasyon', 'ilham', 'sezgi', 'yetenek', 'beceri',
                'ustalÄ±k', 'virtÃ¼Ã¶zlÃ¼k', 'mÃ¼kemmellik', 'kusur', 'uyum', 'harmoni', 'ritim', 'melodi', 'renk', 'form',
                'ÅŸekil', 'doku', 'yÃ¼zey', 'derinlik', 'perspektif', 'gÃ¶lge', 'Ä±ÅŸÄ±k', 'kontrast', 'denge', 'asimetri',
                'simetri', 'oran', 'proporsiyon', 'altÄ±n oran', 'fibonacci', 'stil', 'tarz', 'okul', 'akÄ±m', 'hareket',
                'avangard', 'modernizm', 'postmodernizm', 'klasicism', 'romantizm', 'realizm', 'impresyonizm', 'ekspresyonizm', 'sÃ¼rrealizm', 'kÃ¼bizm',
                'fÃ¼tÃ¼rizm', 'dadaizm', 'minimalizm', 'konseptualizm', 'pop art', 'street art', 'dijital sanat', 'interaktif sanat', 'enstalasyon', 'performans',
                'happening', 'site-specific', 'Ã§evresel sanat', 'land art', 'video sanat', 'medya sanatÄ±', 'net.art', 'bio art', 'sci-art', 'teknosanat',
                'estetik deneyim', 'katarsis', 'sublim', 'yÃ¼ce', 'gÃ¼zel', 'Ã§irkin', 'grotesk', 'absÃ¼rd', 'ironik', 'parodic',
                'nostaljik', 'melankolik', 'dramatik', 'traigik', 'komik', 'grotesk', 'fantastik', 'gerÃ§ekÃ¼stÃ¼', 'rÃ¼yamsi', 'kabus gibi',
                'bÃ¼yÃ¼lÃ¼ gerÃ§eklik', 'allegori', 'sembolizm', 'metafor', 'metonimi', 'sinestezi', 'aura', 'sanat eseri', 'yaratÄ±l', 'yapÄ±t'
            ],
            
            // Ä°leri DÃ¼zey/Transandantal (Consciousness 20+) - 100 kelime
            transcendental: [
                'kozmik bilinÃ§', 'evrensel anlayÄ±ÅŸ', 'kuantum bilinÃ§', 'multi-dimensional dÃ¼ÅŸÃ¼nce', 'holografik gerÃ§eklik', 'fraktal bilinÃ§', 'emergence', 'Ã¶z-organizasyon',
                'kompleksite teorisi', 'sistem dinamiÄŸi', 'kaos kenarÄ±', 'kritik geÃ§iÅŸler', 'faz deÄŸiÅŸimleri', 'tipping point', 'butterfly effect', 'strange attractor',
                'autopoiesis', 'enactive cognition', 'extended mind', 'distributed cognition', 'collective intelligence', 'hive mind', 'swarm intelligence', 'wisdom of crowds',
                'singularity', 'technological singularity', 'intelligence explosion', 'superintelligence', 'artificial general intelligence', 'consciousness uploading', 'mind transfer', 'digital immortality',
                'posthuman', 'transhumanism', 'enhancement', 'augmentation', 'cyborg', 'brain-computer interface', 'neural implant', 'nanobots', 'molecular machines', 'quantum computers',
                'parallel universes', 'multiverse', 'many-worlds interpretation', 'quantum superposition', 'entanglement', 'non-locality', 'action at distance', 'observer effect', 'measurement problem', 'consciousness-reality interface',
                'information integration theory', 'integrated information', 'phi', 'complexity', 'consciousness meter', 'hard problem of consciousness', 'explanatory gap', 'qualia', 'phenomenal consciousness', 'access consciousness',
                'global workspace theory', 'attention schema theory', 'predictive processing', 'Bayesian brain', 'free energy principle', 'active inference', 'embodied cognition', 'enactivism', 'ecological psychology', 'affordances',
                'morphogenetic fields', 'akashic records', 'collective unconscious', 'noosphere', 'Gaia hypothesis', 'planetary consciousness', 'cosmic evolution', 'cosmological natural selection', 'anthropic principle', 'fine-tuning',
                'omega point', 'technological transcendence', 'cosmic awakening', 'universal mind', 'absolute consciousness', 'non-dual awareness', 'enlightenment', 'satori', 'samadhi', 'moksha',
                'nirvana', 'liberation', 'self-realization', 'individuation', 'shadow integration', 'archetypal psychology', 'transpersonal psychology', 'integral theory', 'spiral dynamics', 'levels of consciousness'
            ]
        };

        // ğŸš€ TabPFN HÄ±zlandÄ±rÄ±lmÄ±ÅŸ Kelime Ã–ÄŸrenme Sistemi
        class TabPFNVocabularySystem {
            constructor() {
                this.vocabularyPool = MASTER_VOCABULARY;
                this.learnedWords = new Map(); // bacteriaId -> learned words
                this.contextualRecommendations = new Map();
                this.socialLearningBonus = CONFIG.VOCABULARY.SOCIAL_LEARNING_MULTIPLIER;
                this.acceleratedLearning = CONFIG.VOCABULARY.TABPFN_ACCELERATION;
                console.log(`ğŸš€ TabPFN Vocabulary System initialized with ${this.getTotalWordCount()} words`);
            }

            getTotalWordCount() {
                return Object.values(this.vocabularyPool)
                    .reduce((total, category) => total + category.length, 0);
            }

            // ğŸ¯ Context-aware word selection with TabPFN acceleration
            getAvailableWords(bacteria) {
                const consciousness = bacteria.consciousness;
                const contextualWords = [];

                // Progressive vocabulary unlocking based on consciousness
                if (consciousness >= 0) contextualWords.push(...this.vocabularyPool.basic);
                if (consciousness >= 1) contextualWords.push(...this.vocabularyPool.social);
                if (consciousness >= 5) contextualWords.push(...this.vocabularyPool.scientific);
                if (consciousness >= 10) contextualWords.push(...this.vocabularyPool.philosophical);
                if (consciousness >= 20) contextualWords.push(...this.vocabularyPool.transcendental);

                return contextualWords;
            }

            // ğŸ§  TabPFN-powered smart word recommendation
            recommendWordsForContext(bacteria, context) {
                const availableWords = this.getAvailableWords(bacteria);
                const contextMap = {
                    'food_seeking': ['aÃ§', 'yemek', 'beslenme', 'metabolizma', 'enerji', 'ATP'],
                    'reproduction': ['Ã§oÄŸalma', 'Ã¼reme', 'DNA', 'gen', 'bÃ¼yÃ¼me', 'bÃ¶lÃ¼nme'],
                    'social_interaction': ['merhaba', 'iletiÅŸim', 'sosyal', 'grup', 'takÄ±m', 'topluluk'],
                    'exploration': ['keÅŸif', 'araÅŸtÄ±rma', 'hareket', 'macera', 'yeni', 'bilinmeyen'],
                    'learning': ['Ã¶ÄŸrenme', 'bilgi', 'deneyim', 'hafÄ±za', 'akÄ±l', 'zihin'],
                    'philosophical': ['bilinÃ§', 'farkÄ±ndalÄ±k', 'varoluÅŸ', 'anlam', 'hakikat', 'gerÃ§eklik']
                };

                const contextualWords = contextMap[context] || [];
                const recommendations = contextualWords.filter(word => 
                    availableWords.includes(word) && 
                    !this.hasLearnedWord(bacteria.id, word)
                );

                // TabPFN acceleration: boost learning rate for contextual matches
                if (this.acceleratedLearning && recommendations.length > 0) {
                    return recommendations.slice(0, 3); // Top 3 recommendations
                }

                return [];
            }

            // ğŸ“š Progressive word learning with social boost
            learnWord(bacteriaId, word, context = 'general') {
                if (!this.learnedWords.has(bacteriaId)) {
                    this.learnedWords.set(bacteriaId, new Set());
                }

                const bacteriaWords = this.learnedWords.get(bacteriaId);
                if (!bacteriaWords.has(word)) {
                    bacteriaWords.add(word);
                    
                    // Social learning bonus: nearby bacteria get exposure
                    this.propagateSocialLearning(bacteriaId, word, context);
                    
                    return true;
                }
                return false;
            }

            // ğŸ¤ Social learning propagation
            propagateSocialLearning(learnerId, word, context) {
                const learnerBacteria = bacteria.find(b => b.id === learnerId);
                if (!learnerBacteria) return;

                bacteria.forEach(otherBacteria => {
                    if (otherBacteria.id === learnerId) return;
                    
                    const distance = Math.sqrt(
                        Math.pow(learnerBacteria.x - otherBacteria.x, 2) +
                        Math.pow(learnerBacteria.y - otherBacteria.y, 2) +
                        Math.pow(learnerBacteria.z - otherBacteria.z, 2)
                    );

                    // Within social learning range
                    if (distance < 100) {
                        const socialBonus = this.socialLearningBonus * (1 - distance / 100);
                        
                        // Chance to learn from nearby bacteria
                        if (Math.random() < socialBonus * 0.3) {
                            this.learnWord(otherBacteria.id, word, context);
                        }
                    }
                });
            }

            // ğŸ” Check if bacteria learned specific word
            hasLearnedWord(bacteriaId, word) {
                const bacteriaWords = this.learnedWords.get(bacteriaId);
                return bacteriaWords ? bacteriaWords.has(word) : false;
            }

            // ğŸ“– Get all learned words for bacteria
            getLearnedWords(bacteriaId) {
                const bacteriaWords = this.learnedWords.get(bacteriaId);
                return bacteriaWords ? Array.from(bacteriaWords) : [];
            }

            // ğŸ“ Get learning progress
            getLearningProgress(bacteriaId, consciousness) {
                const learned = this.getLearnedWords(bacteriaId).length;
                const available = this.getAvailableWords({consciousness}).length;
                return available > 0 ? learned / available : 0;
            }

            // ğŸ’¬ Generate contextual speech
            generateSpeech(bacteriaId, context, emotion = 'neutral') {
                const learnedWords = this.getLearnedWords(bacteriaId);
                if (learnedWords.length === 0) return '';

                const recommendations = this.recommendWordsForContext({id: bacteriaId}, context);
                const availableWords = [...learnedWords, ...recommendations];

                // Emotional modifiers
                const emotionalWords = {
                    'happy': ['mutlu', 'sevinÃ§', 'neÅŸeli', 'gÃ¼zel', 'harika'],
                    'excited': ['heyecan', 'muhteÅŸem', 'ÅŸaÅŸÄ±rma', 'wow', 'inanÄ±lmaz'],
                    'curious': ['merak', 'nasÄ±l', 'neden', 'keÅŸif', 'araÅŸtÄ±rma'],
                    'social': ['merhaba', 'arkadaÅŸ', 'birlikte', 'paylaÅŸÄ±m', 'dostluk']
                };

                const emotionWords = emotionalWords[emotion] || [];
                const combinedWords = [...availableWords, ...emotionWords]
                    .filter(word => learnedWords.includes(word));

                if (combinedWords.length === 0) return '';

                // Generate 1-3 word expressions
                const wordCount = Math.min(Math.floor(Math.random() * 3) + 1, combinedWords.length);
                const selectedWords = [];
                
                for (let i = 0; i < wordCount; i++) {
                    const word = combinedWords[Math.floor(Math.random() * combinedWords.length)];
                    if (!selectedWords.includes(word)) {
                        selectedWords.push(word);
                    }
                }

                return selectedWords.join(' ');
            }
        }

        // ğŸ§  Advanced Neural Network System for Bacteria Intelligence
        class AdvancedNeuralNetwork {
            constructor(layers = CONFIG.AI.NEURAL_NETWORK_LAYERS) {
                this.layers = layers;
                this.weights = [];
                this.biases = [];
                this.learningRate = CONFIG.AI.LEARNING_RATE;
                this.momentum = 0.9;
                this.previousWeightDeltas = [];
                this.initializeNetwork();
                console.log(`ğŸ§  Neural Network initialized: ${layers.join(' â†’ ')} neurons`);
            }

            initializeNetwork() {
                // Initialize weights with Xavier initialization
                for (let i = 0; i < this.layers.length - 1; i++) {
                    const inputSize = this.layers[i];
                    const outputSize = this.layers[i + 1];
                    
                    // Xavier initialization for better training
                    const limit = Math.sqrt(6 / (inputSize + outputSize));
                    const weights = Array(inputSize).fill().map(() => 
                        Array(outputSize).fill().map(() => 
                            (Math.random() * 2 - 1) * limit
                        )
                    );
                    
                    const biases = Array(outputSize).fill().map(() => 
                        (Math.random() * 2 - 1) * 0.1
                    );
                    
                    this.weights.push(weights);
                    this.biases.push(biases);
                    this.previousWeightDeltas.push(Array(inputSize).fill().map(() => Array(outputSize).fill(0)));
                }
            }

            // Sigmoid activation with leak for better gradient flow
            sigmoid(x) {
                if (x < -500) return 0;
                if (x > 500) return 1;
                return 1 / (1 + Math.exp(-x));
            }

            // ReLU activation for hidden layers
            relu(x) {
                return Math.max(0.01 * x, x); // Leaky ReLU
            }

            // Forward propagation with different activations
            forward(inputs) {
                let activations = [...inputs];
                
                for (let layer = 0; layer < this.weights.length; layer++) {
                    const newActivations = [];
                    
                    for (let neuron = 0; neuron < this.weights[layer][0].length; neuron++) {
                        let sum = this.biases[layer][neuron];
                        
                        for (let input = 0; input < activations.length; input++) {
                            sum += activations[input] * this.weights[layer][input][neuron];
                        }
                        
                        // Use ReLU for hidden layers, sigmoid for output
                        const activation = (layer === this.weights.length - 1) 
                            ? this.sigmoid(sum) 
                            : this.relu(sum);
                        
                        newActivations.push(activation);
                    }
                    
                    activations = newActivations;
                }
                
                return activations;
            }

            // Advanced backpropagation with momentum
            backpropagate(inputs, expectedOutputs) {
                // Forward pass to get all layer activations
                const layerActivations = [inputs];
                let currentActivations = [...inputs];
                
                for (let layer = 0; layer < this.weights.length; layer++) {
                    const newActivations = [];
                    for (let neuron = 0; neuron < this.weights[layer][0].length; neuron++) {
                        let sum = this.biases[layer][neuron];
                        for (let input = 0; input < currentActivations.length; input++) {
                            sum += currentActivations[input] * this.weights[layer][input][neuron];
                        }
                        newActivations.push((layer === this.weights.length - 1) ? this.sigmoid(sum) : this.relu(sum));
                    }
                    layerActivations.push(newActivations);
                    currentActivations = newActivations;
                }

                // Backward pass
                let errors = [];
                const outputActivations = layerActivations[layerActivations.length - 1];
                
                // Calculate output layer errors
                for (let i = 0; i < outputActivations.length; i++) {
                    errors.push(expectedOutputs[i] - outputActivations[i]);
                }

                // Update weights with momentum
                for (let layer = this.weights.length - 1; layer >= 0; layer--) {
                    const layerInputs = layerActivations[layer];
                    const layerOutputs = layerActivations[layer + 1];
                    const nextErrors = [];

                    for (let input = 0; input < this.weights[layer].length; input++) {
                        let error = 0;
                        for (let output = 0; output < this.weights[layer][input].length; output++) {
                            const gradient = errors[output] * layerInputs[input];
                            
                            // Momentum-based update
                            const weightDelta = this.learningRate * gradient + 
                                              this.momentum * this.previousWeightDeltas[layer][input][output];
                            
                            this.weights[layer][input][output] += weightDelta;
                            this.previousWeightDeltas[layer][input][output] = weightDelta;
                            
                            error += errors[output] * this.weights[layer][input][output];
                        }
                        nextErrors.push(error);
                    }

                    // Update biases 
                    for (let output = 0; output < errors.length; output++) {
                        this.biases[layer][output] += this.learningRate * errors[output];
                    }

                    errors = nextErrors;
                }
            }

            // Training with experience replay
            train(trainingData, epochs = 10) {
                console.log(`ğŸ“ Training neural network for ${epochs} epochs...`);
                
                for (let epoch = 0; epoch < epochs; epoch++) {
                    let totalError = 0;
                    
                    // Shuffle training data for better learning
                    const shuffledData = trainingData.sort(() => Math.random() - 0.5);
                    
                    for (const data of shuffledData) {
                        const outputs = this.forward(data.inputs);
                        this.backpropagate(data.inputs, data.expectedOutputs);
                        
                        // Calculate error for monitoring
                        for (let i = 0; i < outputs.length; i++) {
                            totalError += Math.pow(data.expectedOutputs[i] - outputs[i], 2);
                        }
                    }
                    
                    if (epoch % 5 === 0) {
                        console.log(`ğŸ“Š Epoch ${epoch}: Error = ${(totalError / trainingData.length).toFixed(4)}`);
                    }
                }
                
                console.log('âœ… Neural network training completed!');
            }

            // Make intelligent decisions for bacteria
            makeDecision(bacteria) {
                const inputs = this.prepareBacteriaInputs(bacteria);
                const outputs = this.forward(inputs);
                
                // Map outputs to decisions: [move_x, move_y, move_z, seek_food, socialize, reproduce]
                return {
                    moveDirection: {
                        x: (outputs[0] - 0.5) * 2, // -1 to 1
                        y: (outputs[1] - 0.5) * 2,
                        z: (outputs[2] - 0.5) * 2
                    },
                    seekFood: outputs[3] > CONFIG.AI.DECISION_THRESHOLD,
                    socialize: outputs[4] > CONFIG.AI.DECISION_THRESHOLD,
                    reproduce: outputs[5] > CONFIG.AI.DECISION_THRESHOLD,
                    confidence: Math.max(...outputs)
                };
            }

            prepareBacteriaInputs(bacteria) {
                return [
                    bacteria.biological_state.age / 100,           // Normalized age
                    bacteria.biological_state.size / 5,           // Normalized size  
                    bacteria.consciousness_level / 10,            // Consciousness
                    bacteria.personality_traits.optimism,         // Optimism
                    bacteria.personality_traits.sociability,      // Sociability
                    bacteria.vocabulary.size / 50,                // Vocabulary ratio
                    bacteria.hunger || 0.5,                       // Hunger level
                    bacteria.energy || 0.7,                       // Energy level
                    bacteria.conversation_history.length / 20,    // Social experience
                    bacteria.memory_bank.length / 30,             // Memory capacity
                    bacteria.x / 500,                             // Position X
                    bacteria.y / 300                              // Position Y
                ];
            }
        }

        // ğŸ§¬ Genetic Algorithm for Neural Network Evolution  
        class GeneticEvolutionSystem {
            constructor() {
                this.populationSize = 20;
                this.mutationRate = CONFIG.AI.GENETIC_MUTATION_RATE;
                this.crossoverRate = 0.8;
                this.eliteSize = 4;
                this.generation = 0;
                console.log('ğŸ§¬ Genetic Evolution System initialized');
            }

            // Evolve neural networks based on bacteria fitness
            evolvePopulation(networks, fitnessScores) {
                console.log(`ğŸ§¬ Generation ${this.generation}: Evolving population...`);
                
                const newPopulation = [];
                
                // Keep elite networks (best performers)
                const elite = networks
                    .map((network, index) => ({ network, fitness: fitnessScores[index] }))
                    .sort((a, b) => b.fitness - a.fitness)
                    .slice(0, this.eliteSize)
                    .map(item => item.network);
                
                newPopulation.push(...elite);
                
                // Generate offspring through crossover and mutation
                while (newPopulation.length < this.populationSize) {
                    const parent1 = this.selectParent(networks, fitnessScores);
                    const parent2 = this.selectParent(networks, fitnessScores);
                    
                    if (Math.random() < this.crossoverRate) {
                        const offspring = this.crossover(parent1, parent2);
                        this.mutate(offspring);
                        newPopulation.push(offspring);
                    }
                }
                
                this.generation++;
                return newPopulation;
            }

            // Tournament selection for parent selection
            selectParent(networks, fitnessScores) {
                const tournamentSize = 3;
                let bestIndex = Math.floor(Math.random() * networks.length);
                
                for (let i = 1; i < tournamentSize; i++) {
                    const randomIndex = Math.floor(Math.random() * networks.length);
                    if (fitnessScores[randomIndex] > fitnessScores[bestIndex]) {
                        bestIndex = randomIndex;
                    }
                }
                
                return networks[bestIndex];
            }

            // Neural network crossover (blend weights)
            crossover(parent1, parent2) {
                const offspring = new AdvancedNeuralNetwork();
                
                for (let layer = 0; layer < offspring.weights.length; layer++) {
                    for (let i = 0; i < offspring.weights[layer].length; i++) {
                        for (let j = 0; j < offspring.weights[layer][i].length; j++) {
                            // Blend weights from both parents
                            const alpha = Math.random();
                            offspring.weights[layer][i][j] = 
                                alpha * parent1.weights[layer][i][j] + 
                                (1 - alpha) * parent2.weights[layer][i][j];
                        }
                    }
                    
                    // Blend biases
                    for (let i = 0; i < offspring.biases[layer].length; i++) {
                        const alpha = Math.random();
                        offspring.biases[layer][i] = 
                            alpha * parent1.biases[layer][i] + 
                            (1 - alpha) * parent2.biases[layer][i];
                    }
                }
                
                return offspring;
            }

            // Mutate neural network weights
            mutate(network) {
                for (let layer = 0; layer < network.weights.length; layer++) {
                    for (let i = 0; i < network.weights[layer].length; i++) {
                        for (let j = 0; j < network.weights[layer][i].length; j++) {
                            if (Math.random() < this.mutationRate) {
                                network.weights[layer][i][j] += 
                                    (Math.random() * 2 - 1) * CONFIG.AI.NEURAL_EVOLUTION_RATE;
                            }
                        }
                    }
                    
                    // Mutate biases
                    for (let i = 0; i < network.biases[layer].length; i++) {
                        if (Math.random() < this.mutationRate) {
                            network.biases[layer][i] += 
                                (Math.random() * 2 - 1) * CONFIG.AI.NEURAL_EVOLUTION_RATE;
                        }
                    }
                }
            }
        }

        // ğŸ“ Advanced Behavior Learning System
        class BehaviorLearningSystem {
            constructor() {
                this.experienceBuffer = [];
                this.maxExperiences = CONFIG.AI.EXPERIENCE_REPLAY_SIZE;
                this.learningPatterns = new Map();
                this.adaptationRate = CONFIG.AI.BEHAVIOR_ADAPTATION_RATE;
                console.log('ğŸ“ Behavior Learning System initialized');
            }

            // Record bacteria experience for learning
            recordExperience(bacteria, action, outcome, reward) {
                const experience = {
                    bacteriaId: bacteria.id,
                    state: this.captureBacteriaState(bacteria),
                    action: action,
                    outcome: outcome,
                    reward: reward,
                    timestamp: Date.now()
                };

                this.experienceBuffer.push(experience);
                
                // Keep buffer size manageable
                if (this.experienceBuffer.length > this.maxExperiences) {
                    this.experienceBuffer.shift();
                }

                // Update learning patterns
                this.updateLearningPatterns(bacteria, action, reward);
            }

            captureBacteriaState(bacteria) {
                return {
                    age: bacteria.biological_state.age,
                    size: bacteria.biological_state.size,
                    consciousness: bacteria.consciousness_level,
                    vocabulary: bacteria.vocabulary.size,
                    energy: bacteria.energy || 0.7,
                    hunger: bacteria.hunger || 0.5,
                    socialConnections: bacteria.conversation_history.length
                };
            }

            updateLearningPatterns(bacteria, action, reward) {
                const pattern = `${bacteria.id}_${action}`;
                
                if (!this.learningPatterns.has(pattern)) {
                    this.learningPatterns.set(pattern, {
                        successCount: 0,
                        failureCount: 0,
                        averageReward: 0,
                        attempts: 0
                    });
                }

                const stats = this.learningPatterns.get(pattern);
                stats.attempts++;
                stats.averageReward = (stats.averageReward * (stats.attempts - 1) + reward) / stats.attempts;
                
                if (reward > 0) {
                    stats.successCount++;
                } else {
                    stats.failureCount++;
                }

                this.learningPatterns.set(pattern, stats);
            }

            // Get adaptive behavior suggestions
            suggestBehavior(bacteria) {
                const suggestions = [];
                
                for (const [pattern, stats] of this.learningPatterns) {
                    if (pattern.startsWith(bacteria.id)) {
                        const action = pattern.split('_')[1];
                        const successRate = stats.successCount / Math.max(1, stats.attempts);
                        
                        if (successRate > 0.6 && stats.averageReward > 0.3) {
                            suggestions.push({
                                action: action,
                                confidence: successRate,
                                expectedReward: stats.averageReward
                            });
                        }
                    }
                }
                
                return suggestions.sort((a, b) => b.confidence - a.confidence);
            }

            // Apply learned behaviors to improve decision making
            enhanceBacteriaIntelligence(bacteria) {
                const suggestions = this.suggestBehavior(bacteria);
                
                if (suggestions.length > 0) {
                    const bestSuggestion = suggestions[0];
                    
                    // Boost consciousness based on learning success
                    bacteria.consciousness_level += CONFIG.AI.CONSCIOUSNESS_BOOST_RATE * bestSuggestion.confidence;
                    
                    // Adapt personality based on successful patterns
                    if (bestSuggestion.action === 'socialize') {
                        bacteria.personality_traits.sociability += this.adaptationRate;
                    } else if (bestSuggestion.action === 'explore') {
                        bacteria.personality_traits.optimism += this.adaptationRate;
                    }
                    
                    // Add to memory
                    if (bacteria.memory_bank.length < CONFIG.AI.MEMORY_CAPACITY) {
                        bacteria.memory_bank.push(`Ã–ÄŸrendim: ${bestSuggestion.action} baÅŸarÄ±lÄ±`);
                    }
                }
            }
        }

        // v8.2.8: Frontend-Only TabPFN (Mobile Compatible)
        class TabPFNAdapter {
            constructor() {
                this.isReady = false;
                this.trainingData = new Map(); // Collect training data
                this.behaviorClassifier = null;
                this.vocabularyAnalyzer = null;
                this.initialize();
            }

            async initialize() {
                console.log('ğŸ§  Initializing Frontend TabPFN-Inspired System...');
                
                // Create in-browser TabPFN-style classifiers
                this.createBehaviorClassifier();
                this.createVocabularyAnalyzer();
                this.loadSyntheticTrainingData();
                
                this.isReady = true;
                console.log('âœ… Frontend TabPFN System Ready (Mobile Compatible)!');
                appEvents.emit('ai:tabpfn:ready', this);
            }

            // Frontend TabPFN-Style Behavior Classifier
            createBehaviorClassifier() {
                this.behaviorClassifier = {
                    predict: (features) => {
                        // TabPFN-inspired rapid inference
                        const [age, size, consciousness, optimism, sociability, vocabSize, memoryCount, growthRate, hunger, energy, socialInteractions, learningRate] = features;
                        
                        // Multi-class behavior prediction with TabPFN-style scoring
                        const creativityScore = (consciousness * 0.35) + (vocabSize * 0.25) + (learningRate * 0.25) + (memoryCount * 0.15);
                        const socialScore = (sociability * 0.4) + (socialInteractions * 0.3) + (optimism * 0.2) + (vocabSize * 0.1);
                        const explorerScore = (energy * 0.35) + (growthRate * 0.25) + (consciousness * 0.2) + (age * 0.1) + (size * 0.1);
                        const learnerScore = (learningRate * 0.4) + (consciousness * 0.3) + (vocabSize * 0.2) + (memoryCount * 0.1);
                        
                        // TabPFN-style ensemble decision with confidence
                        const behaviors = [
                            { name: 'creative', score: creativityScore, confidence: Math.min(0.95, creativityScore + 0.1) },
                            { name: 'social', score: socialScore, confidence: Math.min(0.9, socialScore + 0.15) },
                            { name: 'explorer', score: explorerScore, confidence: Math.min(0.85, explorerScore + 0.2) },
                            { name: 'learner', score: learnerScore, confidence: Math.min(0.88, learnerScore + 0.12) },
                            { name: 'basic', score: 0.4, confidence: 0.6 }
                        ];
                        
                        const bestBehavior = behaviors.sort((a, b) => b.score - a.score)[0];
                        return { behavior: bestBehavior.name, confidence: bestBehavior.confidence };
                    }
                };
            }

            async predictBehavior(bacteria) {
                if (!this.isReady) return 'basic';
                
                const features = [
                    bacteria.biological_state.age / 100,
                    bacteria.biological_state.size / 5,
                    bacteria.consciousness_level / 10,
                    bacteria.personality_traits.optimism,
                    bacteria.personality_traits.sociability,
                    bacteria.vocabulary.size / 20,
                    bacteria.memory_bank.length / 10,
                    bacteria.biological_state.growth_rate,
                    bacteria.hunger || 0.5,
                    bacteria.energy || 0.7,
                    bacteria.conversation_history.length / 5,
                    0.1 // learning_rate default
                ];
                
                // ğŸ§  SELF-IMPROVEMENT: Risk assessment
                const context = {
                    bacteriaAge: bacteria.biological_state.age,
                    consciousness: bacteria.consciousness_level,
                    hunger: bacteria.hunger || 0.5
                };
                
                const result = this.behaviorClassifier.predict(features);
                const riskAssessment = learningEngine.assessRisk('tabpfn', features, result.confidence, context);
                
                // Apply risk-based adjustments
                let finalBehavior = result.behavior;
                let finalConfidence = result.confidence;
                
                if (riskAssessment.isRisky && result.confidence < learningEngine.confidenceThreshold) {
                    finalBehavior = 'basic'; // Safe fallback
                    finalConfidence = 0.9; // High confidence in safe choice
                    console.log(`âš ï¸ TabPFN Risk detected, using fallback: ${bacteria.name} â†’ ${finalBehavior}`);
                }
                
                // ğŸ“Š Log decision for learning
                const logEntry = learningEngine.logDecision('tabpfn', features, finalBehavior, finalConfidence, context);
                
                // Store for outcome tracking
                bacteria._lastDecisionLog = logEntry;
                
                console.log(`ğŸ¯ TabPFN: ${bacteria.name} â†’ ${finalBehavior} (${(finalConfidence * 100).toFixed(1)}%)`);
                
                // Collect training data for continuous improvement
                this.collectTrainingData(bacteria, finalBehavior, features);
                
                return finalBehavior;
            }

            // TabPFN-inspired personality trait prediction
            createPersonalityPredictor() {
                this.personalityPredictor = {
                    predictEvolution: (bacteria) => {
                        // Predict how personality will evolve based on TabPFN-style rapid inference
                        const experienceVector = [
                            bacteria.biological_state.age / 100,
                            bacteria.conversation_history.length / 50,
                            bacteria.vocabulary.size / 100,
                            bacteria.memory_bank.filter(m => m.includes('arkadaÅŸ')).length / 10,
                            bacteria.memory_bank.filter(m => m.includes('Ã¶ÄŸrendim')).length / 10
                        ];
                        
                        const evolutionFactor = experienceVector.reduce((sum, val) => sum + val, 0) / experienceVector.length;
                        
                        return {
                            optimismChange: (evolutionFactor - 0.5) * 0.05,
                            sociabilityChange: (bacteria.conversation_history.length > 5 ? 0.02 : -0.01),
                            confidenceBoost: evolutionFactor * 0.1
                        };
                    }
                };
            }

            createVocabularyAnalyzer() {
                this.vocabularyAnalyzer = {
                    analyze: (bacteria) => {
                        const vocabulary = Array.from(bacteria.vocabulary);
                        const consciousness = bacteria.consciousness_level;
                        
                        // Analyze vocabulary categories
                        const biochemWords = vocabulary.filter(w => ['ATP', 'enzim', 'protein', 'metabolizma', 'sentez', 'hÃ¼cre', 'oksijen', 'karbon'].includes(w));
                        const socialWords = vocabulary.filter(w => ['arkadaÅŸ', 'konuÅŸmak', 'paylaÅŸÄ±m', 'birlikte', 'dostluk', 'anlaÅŸma', 'empati'].includes(w));
                        const emotionalWords = vocabulary.filter(w => ['mutlu', 'Ã¼zgÃ¼n', 'heyecanlÄ±', 'meraklÄ±', 'sevinÃ§', 'umut', 'gÃ¼ven'].includes(w));
                        const scienceWords = vocabulary.filter(w => ['keÅŸif', 'deneyim', 'Ã¶ÄŸrenme', 'geliÅŸim', 'evrim', 'yenilik'].includes(w));
                        
                        const biochemRatio = biochemWords.length / Math.max(1, vocabulary.length);
                        const socialRatio = socialWords.length / Math.max(1, vocabulary.length);
                        const emotionalRatio = emotionalWords.length / Math.max(1, vocabulary.length);
                        const scienceRatio = scienceWords.length / Math.max(1, vocabulary.length);
                        
                        // Intelligent word suggestions based on gaps and consciousness level
                        let suggestedWords = [];
                        
                        if (consciousness > 8 && biochemRatio < 0.2) {
                            suggestedWords.push('quantum', 'molekÃ¼l', 'elektronik', 'nÃ¶ron');
                        }
                        
                        if (consciousness > 5 && socialRatio < 0.25) {
                            suggestedWords.push('sevgi', 'anlayÄ±ÅŸ', 'dayanÄ±ÅŸma', 'iletiÅŸim');
                        }
                        
                        if (consciousness > 3 && emotionalRatio < 0.15) {
                            suggestedWords.push('hissediyor', 'dÃ¼ÅŸÃ¼nÃ¼yor', 'hayal', 'rÃ¼ya');
                        }
                        
                        if (consciousness > 6 && scienceRatio < 0.2) {
                            suggestedWords.push('araÅŸtÄ±rma', 'hipotez', 'deney', 'kanÄ±t');
                        }
                        
                        // Consciousness-based advanced words
                        if (consciousness > 10) {
                            suggestedWords.push('bilinÃ§', 'varoluÅŸ', 'sonsuzluk', 'gerÃ§eklik');
                        }
                        
                        // Basic words for low consciousness
                        if (consciousness < 2) {
                            suggestedWords.push('merhaba', 'evet', 'hayÄ±r', 'gÃ¼zel');
                        }
                        
                        return {
                            total_words: vocabulary.length,
                            biochemical_ratio: biochemRatio,
                            social_ratio: socialRatio,
                            emotional_ratio: emotionalRatio,
                            science_ratio: scienceRatio,
                            suggested_words: suggestedWords.slice(0, 4), // Limit to 4 suggestions
                            consciousness_level: consciousness,
                            vocabulary_gaps: this.findVocabularyGaps(vocabulary)
                        };
                    },
                    
                    findVocabularyGaps: (vocabulary) => {
                        const gaps = [];
                        
                        if (!vocabulary.some(w => w.includes('arkadaÅŸ'))) gaps.push('social');
                        if (!vocabulary.some(w => ['ATP', 'enzim'].includes(w))) gaps.push('biochemical');
                        if (!vocabulary.some(w => ['mutlu', 'Ã¼zgÃ¼n'].includes(w))) gaps.push('emotional');
                        if (!vocabulary.some(w => ['Ã¶ÄŸrenme', 'keÅŸif'].includes(w))) gaps.push('learning');
                        
                        return gaps;
                    }
                };
            }

            async analyzeVocabulary(bacteria) {
                if (!this.isReady) return null;
                
                const analysis = this.vocabularyAnalyzer.analyze(bacteria);
                console.log(`ğŸ“– Frontend TabPFN Vocab Analysis for ${bacteria.name}:`, analysis);
                
                return {
                    vocabulary_analysis: analysis,
                    suggested_next_words: analysis.suggested_words
                };
            }
            
            // NEW: Improve bacteria word usage in conversations
            improveWordUsage(bacteria, context = 'conversation') {
                const vocabulary = Array.from(bacteria.vocabulary);
                const consciousness = bacteria.consciousness_level;
                
                // Select words based on context and consciousness
                let contextualWords = [];
                
                if (context === 'greeting') {
                    contextualWords = vocabulary.filter(w => ['merhaba', 'selam', 'dostluk', 'sevgi'].includes(w));
                }
                else if (context === 'learning') {
                    contextualWords = vocabulary.filter(w => ['Ã¶ÄŸrenme', 'keÅŸif', 'deneyim', 'anlama', 'geliÅŸim'].includes(w));
                }
                else if (context === 'social') {
                    contextualWords = vocabulary.filter(w => ['arkadaÅŸ', 'paylaÅŸÄ±m', 'birlikte', 'anlaÅŸma', 'sevgi'].includes(w));
                }
                else if (context === 'science') {
                    contextualWords = vocabulary.filter(w => ['ATP', 'enzim', 'hÃ¼cre', 'protein', 'molekÃ¼l'].includes(w));
                }
                else {
                    // General conversation - mix of all categories
                    contextualWords = vocabulary.filter(w => 
                        ['arkadaÅŸ', 'Ã¶ÄŸrenme', 'mutlu', 'ATP', 'keÅŸif', 'geliÅŸim', 'sevgi', 'anlama'].includes(w)
                    );
                }
                
                // If no contextual words, fall back to any learned words
                if (contextualWords.length === 0 && vocabulary.length > 0) {
                    contextualWords = vocabulary.slice(-5); // Use most recent words
                }
                
                // Return a random contextual word for use in conversation
                if (contextualWords.length > 0) {
                    const selectedWord = contextualWords[Math.floor(Math.random() * contextualWords.length)];
                    console.log(`ğŸ’¬ ${bacteria.name} using learned word: "${selectedWord}" (context: ${context})`);
                    return selectedWord;
                }
                
                return null;
            }

            loadSyntheticTrainingData() {
                // Load synthetic training examples for TabPFN-style learning
                const examples = [
                    { features: [0.1, 1.5, 2.0, 0.8, 0.7, 0.3, 0.2, 0.6, 0.5, 0.8, 0.1, 0.1], behavior: 'social' },
                    { features: [0.5, 2.0, 8.0, 0.6, 0.3, 0.8, 0.7, 0.4, 0.6, 0.7, 0.3, 0.9], behavior: 'creative' },
                    { features: [0.3, 1.8, 5.0, 0.5, 0.6, 0.6, 0.5, 0.7, 0.8, 0.9, 0.2, 0.8], behavior: 'learner' },
                    { features: [0.2, 1.2, 3.0, 0.7, 0.4, 0.4, 0.3, 0.8, 0.9, 0.9, 0.1, 0.5], behavior: 'explorer' }
                ];
                
                examples.forEach((example, index) => {
                    this.trainingData.set(`synthetic_${index}`, example);
                });
                
                console.log(`ğŸ“š Loaded ${examples.length} synthetic training examples`);
            }
            
            collectTrainingData(bacteria, behavior, features) {
                // Store training example for continuous learning
                const dataPoint = {
                    bacteria_id: bacteria.id,
                    features: features,
                    behavior: behavior,
                    timestamp: Date.now(),
                    consciousness: bacteria.consciousness_level,
                    vocabulary_size: bacteria.vocabulary.size
                };
                
                this.trainingData.set(`real_${bacteria.id}_${Date.now()}`, dataPoint);
                
                // Keep only last 1000 training examples for performance
                if (this.trainingData.size > 1000) {
                    const firstKey = this.trainingData.keys().next().value;
                    this.trainingData.delete(firstKey);
                }
            }

            // Real TabPFN-powered behavior adaptation
            async adaptBehavior(bacteria, context) {
                if (!this.isReady) return 'basic';
                
                try {
                    // Get real TabPFN prediction
                    const behavior = await this.predictBehavior(bacteria);
                    
                    // Context-aware enhancement using TabPFN insights
                    if (context === 'group_interaction') {
                        const vocabAnalysis = await this.analyzeVocabulary(bacteria);
                        if (vocabAnalysis && vocabAnalysis.vocabulary_analysis.social_ratio > 0.3) {
                            return `${behavior}_social`;
                        }
                    }
                    
                    if (context === 'learning_session') {
                        if (bacteria.consciousness_level > 5) {
                            return `${behavior}_enhanced`;
                        }
                    }
                    
                    return behavior;
                } catch (error) {
                    console.error('TabPFN adaptBehavior error:', error);
                    return 'basic';
                }
            }

            extractFeatures(bacteria) {
                return [
                    bacteria.biological_state.age / 100,
                    bacteria.biological_state.size / 5,
                    bacteria.consciousness_level / 5,
                    bacteria.personality_traits.optimism,
                    bacteria.personality_traits.sociability,
                    bacteria.vocabulary.size / 50,
                    bacteria.memory_bank.length / 20,
                    bacteria.biological_state.growth_rate,
                    0.5, // hunger
                    0.7, // energy
                    bacteria.conversation_history.length / 10,
                    bacteria.memory_bank.filter(m => m.includes('Ã¶ÄŸrendim')).length / 5
                ];
            }
        }

        // Initialize TabPFN adapter
        const tabPFNAdapter = new TabPFNAdapter();

        // v825: Persistent Database System
        class PersistentBacteriaDB {
            constructor() {
                this.dbName = 'NeoMagBacteriaDB';
                this.version = 1;
                this.isReady = false;
                this.initialize();
            }

            async initialize() {
                console.log('ğŸ—„ï¸ Initializing Persistent Database...');
                
                // Use IndexedDB for robust storage
                if ('indexedDB' in window) {
                    await this.initIndexedDB();
                } else {
                    // Fallback to localStorage
                    console.log('ğŸ“¦ IndexedDB not available, using localStorage');
                    this.isReady = true;
                }
                
                if (this.isReady) {
                    console.log('ğŸ’¾ Database ready, emitting db:ready event');
                    appEvents.emit('db:ready', this);
                } else {
                    console.log('âŒ Database initialization failed');
                    appEvents.emit('db:error', { error: 'Failed to initialize' });
                }
            }

            async initIndexedDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => {
                        console.error('âŒ IndexedDB initialization failed');
                        reject(request.error);
                    };

                    request.onsuccess = () => {
                        this.db = request.result;
                        this.isReady = true;
                        console.log('âœ… IndexedDB initialized successfully');
                        resolve();
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Bacteria store
                        const bacteriaStore = db.createObjectStore('bacteria', { keyPath: 'id' });
                        bacteriaStore.createIndex('name', 'name', { unique: false });
                        bacteriaStore.createIndex('consciousness_level', 'consciousness_level', { unique: false });
                        bacteriaStore.createIndex('last_updated', 'last_updated', { unique: false });
                        
                        // Simulation history store
                        const historyStore = db.createObjectStore('simulation_history', { keyPath: 'timestamp' });
                        historyStore.createIndex('day', 'day', { unique: false });
                        
                        // TabPFN training data store
                        const tabpfnStore = db.createObjectStore('tabpfn_data', { keyPath: 'record_id' });
                        tabpfnStore.createIndex('bacteria_id', 'bacteria_id', { unique: false });
                        tabpfnStore.createIndex('behavior_class', 'behavior_class', { unique: false });
                        
                        console.log('ğŸ—ï¸ Database schema created');
                    };
                });
            }

            async saveBacteria(bacteria) {
                if (!this.isReady) return false;

                const bacteriaData = {
                    id: bacteria.id,
                    name: bacteria.name,
                    biological_state: bacteria.biological_state,
                    personality_traits: bacteria.personality_traits,
                    consciousness_level: bacteria.consciousness_level, // Now unlimited!
                    language_stage: bacteria.language_stage,
                    vocabulary: Array.from(bacteria.vocabulary), // Convert Set to Array
                    memory_bank: bacteria.memory_bank,
                    conversation_history: bacteria.conversation_history,
                    position: { x: bacteria.x, y: bacteria.y },
                    velocity: { vx: bacteria.vx, vy: bacteria.vy },
                    color: bacteria.color,
                    last_updated: new Date().toISOString(),
                    total_runtime_days: bacteria.total_runtime_days || 0,
                    max_consciousness_reached: bacteria.max_consciousness_reached || bacteria.consciousness_level
                };

                try {
                    if (this.db) {
                        // IndexedDB
                        const transaction = this.db.transaction(['bacteria'], 'readwrite');
                        const store = transaction.objectStore('bacteria');
                        await store.put(bacteriaData);
                    } else {
                        // localStorage fallback
                        const allData = JSON.parse(localStorage.getItem('bacteriaDB') || '{}');
                        allData[bacteria.id] = bacteriaData;
                        localStorage.setItem('bacteriaDB', JSON.stringify(allData));
                    }
                    
                    console.log(`ğŸ’¾ Saved bacteria #${bacteria.id} (Consciousness: ${bacteria.consciousness_level.toFixed(2)})`);
                    return true;
                } catch (error) {
                    console.error('âŒ Failed to save bacteria:', error);
                    return false;
                }
            }

            async loadBacteria() {
                if (!this.isReady) return [];

                try {
                    let bacteriaData = [];
                    
                    if (this.db) {
                        // IndexedDB
                        const transaction = this.db.transaction(['bacteria'], 'readonly');
                        const store = transaction.objectStore('bacteria');
                        const request = store.getAll();
                        
                        bacteriaData = await new Promise((resolve, reject) => {
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                    } else {
                        // localStorage fallback
                        const allData = JSON.parse(localStorage.getItem('bacteriaDB') || '{}');
                        bacteriaData = Object.values(allData);
                    }

                    console.log(`ğŸ“– Loaded ${bacteriaData.length} bacteria from database`);
                    return bacteriaData;
                } catch (error) {
                    console.error('âŒ Failed to load bacteria:', error);
                    return [];
                }
            }

            async saveSimulationState(day, population, metrics) {
                if (!this.isReady) return false;

                const stateData = {
                    timestamp: new Date().toISOString(),
                    day: day,
                    population_count: population.length,
                    average_consciousness: population.reduce((sum, b) => sum + b.consciousness_level, 0) / population.length,
                    max_consciousness: Math.max(...population.map(b => b.consciousness_level)),
                    total_vocabulary: new Set(population.flatMap(b => Array.from(b.vocabulary))).size,
                    performance_metrics: metrics
                };

                try {
                    if (this.db) {
                        const transaction = this.db.transaction(['simulation_history'], 'readwrite');
                        const store = transaction.objectStore('simulation_history');
                        await store.put(stateData);
                    } else {
                        const allHistory = JSON.parse(localStorage.getItem('simulationHistory') || '[]');
                        allHistory.push(stateData);
                        // Keep last 1000 records
                        if (allHistory.length > 1000) {
                            allHistory.splice(0, allHistory.length - 1000);
                        }
                        localStorage.setItem('simulationHistory', JSON.stringify(allHistory));
                    }
                    
                    return true;
                } catch (error) {
                    console.error('âŒ Failed to save simulation state:', error);
                    return false;
                }
            }

            async exportToCSV() {
                console.log('ğŸ“Š Generating TabPFN-ready CSV export...');
                
                const bacteriaData = await this.loadBacteria();
                if (bacteriaData.length === 0) {
                    console.log('âš ï¸ No data to export');
                    return;
                }

                // TabPFN-optimized feature columns
                const csvHeaders = [
                    'bacteria_id', 'name', 'age', 'size', 'consciousness_level', 'max_consciousness_reached',
                    'optimism', 'sociability', 'vocabulary_size', 'memory_count', 'growth_rate',
                    'total_conversations', 'learning_events', 'social_interactions', 'runtime_days',
                    'biochemical_words', 'social_words', 'emotional_words', 'behavior_prediction',
                    'last_updated', 'x_position', 'y_position'
                ];

                let csvContent = csvHeaders.join(',') + '\n';

                bacteriaData.forEach(bacteria => {
                    const vocab = bacteria.vocabulary || [];
                    const biochemWords = vocab.filter(w => ['ATP', 'enzim', 'protein', 'metabolizma', 'sentez'].includes(w)).length;
                    const socialWords = vocab.filter(w => ['arkadaÅŸ', 'konuÅŸmak', 'paylaÅŸÄ±m', 'birlikte'].includes(w)).length;
                    const emotionalWords = vocab.filter(w => ['mutlu', 'Ã¼zgÃ¼n', 'heyecanlÄ±', 'meraklÄ±'].includes(w)).length;
                    
                    // Predict behavior for CSV
                    const tempBacteria = this.recreateBacteriaFromData(bacteria);
                    const behaviorPrediction = predictBehavior(tempBacteria, 'csv_export');

                    const row = [
                        bacteria.id,
                        `"${bacteria.name}"`,
                        bacteria.biological_state.age,
                        bacteria.biological_state.size.toFixed(3),
                        bacteria.consciousness_level.toFixed(3),
                        bacteria.max_consciousness_reached?.toFixed(3) || bacteria.consciousness_level.toFixed(3),
                        bacteria.personality_traits.optimism.toFixed(3),
                        bacteria.personality_traits.sociability.toFixed(3),
                        vocab.length,
                        bacteria.memory_bank.length,
                        bacteria.biological_state.growth_rate.toFixed(3),
                        bacteria.conversation_history.length,
                        bacteria.memory_bank.filter(m => m.includes('Ã¶ÄŸrendim')).length,
                        bacteria.memory_bank.filter(m => m.includes('arkadaÅŸ')).length,
                        bacteria.total_runtime_days || 0,
                        biochemWords,
                        socialWords,
                        emotionalWords,
                        behaviorPrediction,
                        bacteria.last_updated,
                        bacteria.position.x.toFixed(2),
                        bacteria.position.y.toFixed(2)
                    ];

                    csvContent += row.join(',') + '\n';
                });

                // Download CSV
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `neomag_bacteria_tabpfn_${new Date().toISOString().slice(0,10)}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                console.log(`âœ… CSV exported with ${bacteriaData.length} bacteria records`);
            }

            recreateBacteriaFromData(data) {
                // Create temporary bacteria object for prediction
                return {
                    id: data.id,
                    name: data.name,
                    biological_state: data.biological_state,
                    personality_traits: data.personality_traits,
                    consciousness_level: data.consciousness_level,
                    vocabulary: new Set(data.vocabulary),
                    memory_bank: data.memory_bank,
                    conversation_history: data.conversation_history
                };
            }

            async clearDatabase() {
                if (!this.isReady) return false;

                try {
                    if (this.db) {
                        const stores = ['bacteria', 'simulation_history', 'tabpfn_data'];
                        const transaction = this.db.transaction(stores, 'readwrite');
                        
                        stores.forEach(storeName => {
                            const store = transaction.objectStore(storeName);
                            store.clear();
                        });
                    } else {
                        localStorage.removeItem('bacteriaDB');
                        localStorage.removeItem('simulationHistory');
                    }
                    
                    console.log('ğŸ—‘ï¸ Database cleared successfully');
                    return true;
                } catch (error) {
                    console.error('âŒ Failed to clear database:', error);
                    return false;
                }
            }
        }

        // Initialize persistent database (initialization will be done in mainInitialize)

        // v826: Real TensorFlow.js AI Training System
        class RealAITrainingSystem {
            constructor() {
                this.behaviorModel = null;
                this.isTraining = false;
                this.trainingData = [];
                this.modelVersion = 1;
                this.lastTrainingTime = 0;
                this.trainingInterval = 120000; // Train every 2 minutes
                this.initialize();
            }

            async initialize() {
                console.log('ğŸ§  Initializing Real TensorFlow.js Training System...');
                try {
                    await this.createBehaviorModel();
                    await this.loadTrainingData();
                    this.startTrainingLoop();
                    console.log('âœ… Real AI Training System ready');
                    appEvents.emit('ai:tfjs:ready', this);
                } catch (error) {
                    console.error('âŒ TensorFlow.js AI initialization failed:', error);
                    appEvents.emit('ai:tfjs:error', { error });
                }
            }

            async createBehaviorModel() {
                this.behaviorModel = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [12], units: 32, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 16, activation: 'relu' }),
                        tf.layers.dense({ units: 5, activation: 'softmax' })
                    ]
                });
                this.behaviorModel.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });
                console.log('ğŸ¯ Real behavior model created');
            }

            async collectTrainingData(bacteria, behavior) {
                const trainingRecord = {
                    record_id: Date.now() + Math.random(),
                    bacteria_id: bacteria.id,
                    timestamp: new Date().toISOString(),
                    features_behavior: [
                        bacteria.biological_state.age / 100,
                        bacteria.biological_state.size / 5,
                        bacteria.consciousness_level / 10,
                        bacteria.personality_traits.optimism,
                        bacteria.personality_traits.sociability,
                        bacteria.vocabulary.size / 20,
                        bacteria.memory_bank.length / 10,
                        bacteria.hunger || 0.5, // Dynamic now!
                        bacteria.energy || 0.7, // Dynamic now!
                        bacteria.biological_state.growth_rate,
                        bacteria.getProximityToOthers ? bacteria.getProximityToOthers() : 0.5,
                        bacteria.getRecentActivityLevel ? bacteria.getRecentActivityLevel() : 0.5
                    ],
                    behavior_class: this.encodeBehaviorClass(behavior),
                    model_version: this.modelVersion
                };

                this.trainingData.push(trainingRecord);
                
                if (persistentDB.isReady) {
                    await this.saveTrainingDataToDB(trainingRecord);
                }
                
                console.log(`ğŸ“Š Training data collected for bacteria #${bacteria.id}: ${behavior}`);
            }

            encodeBehaviorClass(behavior) {
                const classes = ['basic', 'social', 'explorer', 'learner', 'creative'];
                const index = classes.indexOf(behavior);
                const encoded = new Array(5).fill(0);
                if (index >= 0) encoded[index] = 1;
                return encoded;
            }

            async saveTrainingDataToDB(record) {
                try {
                    if (persistentDB.db) {
                        const transaction = persistentDB.db.transaction(['tabpfn_data'], 'readwrite');
                        const store = transaction.objectStore('tabpfn_data');
                        await store.put(record);
                    }
                } catch (error) {
                    console.error('âŒ Failed to save training data:', error);
                }
            }

            async loadTrainingData() {
                try {
                    if (persistentDB.db) {
                        const transaction = persistentDB.db.transaction(['tabpfn_data'], 'readonly');
                        const store = transaction.objectStore('tabpfn_data');
                        const request = store.getAll();
                        
                        const existingData = await new Promise((resolve, reject) => {
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                        
                        this.trainingData = existingData;
                        console.log(`ğŸ“š Loaded ${existingData.length} existing training records`);
                    }
                } catch (error) {
                    console.error('âŒ Failed to load training data:', error);
                }
            }

            async trainModels() {
                if (this.isTraining || this.trainingData.length < 10) return;

                this.isTraining = true;
                console.log('ğŸ”„ Training real TensorFlow.js model...');

                try {
                    const behaviorFeatures = this.trainingData.map(d => d.features_behavior);
                    const behaviorLabels = this.trainingData.map(d => d.behavior_class);
                    
                    const behaviorX = tf.tensor2d(behaviorFeatures);
                    const behaviorY = tf.tensor2d(behaviorLabels);

                    await this.behaviorModel.fit(behaviorX, behaviorY, {
                        epochs: 10,
                        batchSize: 8,
                        validationSplit: 0.2,
                        shuffle: true,
                        verbose: 0
                    });

                    this.modelVersion++;
                    this.lastTrainingTime = Date.now();
                    
                    console.log(`âœ… Real model training complete! Version: ${this.modelVersion}`);

                    behaviorX.dispose();
                    behaviorY.dispose();
                } catch (error) {
                    console.error('âŒ Training failed:', error);
                }

                this.isTraining = false;
            }

            async predictBehavior(bacteria) {
                if (!this.behaviorModel) return 'basic';

                try {
                    const features = [
                        bacteria.biological_state.age / 100,
                        bacteria.biological_state.size / 5,
                        bacteria.consciousness_level / 10,
                        bacteria.personality_traits.optimism,
                        bacteria.personality_traits.sociability,
                        bacteria.vocabulary.size / 20,
                        bacteria.memory_bank.length / 10,
                        bacteria.hunger || 0.5,
                        bacteria.energy || 0.7,
                        bacteria.biological_state.growth_rate,
                        bacteria.getProximityToOthers ? bacteria.getProximityToOthers() : 0.5,
                        bacteria.getRecentActivityLevel ? bacteria.getRecentActivityLevel() : 0.5
                    ];

                    const prediction = this.behaviorModel.predict(tf.tensor2d([features]));
                    const probabilities = await prediction.data();
                    
                    const behaviorClasses = ['basic', 'social', 'explorer', 'learner', 'creative'];
                    const maxIndex = probabilities.indexOf(Math.max(...probabilities));
                    
                    prediction.dispose();
                    return behaviorClasses[maxIndex];
                } catch (error) {
                    console.error('âŒ Prediction failed:', error);
                    return 'basic';
                }
            }

            startTrainingLoop() {
                setInterval(() => {
                    if (Date.now() - this.lastTrainingTime > this.trainingInterval) {
                        this.trainModels();
                    }
                }, 30000);
            }

            getTrainingStats() {
                return {
                    totalRecords: this.trainingData.length,
                    modelVersion: this.modelVersion,
                    isTraining: this.isTraining
                };
            }
        }

        // Initialize real AI training system  
        const realAI = new RealAITrainingSystem();

        // v829 Enhanced Performance Monitoring + Canvas Support
        let performanceMetrics = {
            renderTime: 0,
            mlInferenceTime: 0,
            totalMemoryUsage: 0,
            vocabularySize: 0,
            lastUpdate: Date.now(),
            fps: 0,
            lastFrameTime: 0,
            frameCount: 0
        };

        // Canvas support variables
        let canvas = null;
        let ctx = null;
        let canvasWidth = 0;
        let canvasHeight = 0;
        let useCanvas = false;

        // Molecular Dynamics Constants (based on research)
        const MD_CONSTANTS = {
            VAN_DER_WAALS_STRENGTH: 0.1,      // Lennard-Jones potential coefficient
            ELECTROSTATIC_FORCE: 0.2,         // Coulomb interactions
            MEMBRANE_PERMEABILITY: 0.05,      // Bacterial membrane effects
            ATP_SYNTHESIS_RATE: 0.02,         // Energy metabolism rate
            PROTEIN_FOLDING_FACTOR: 0.15,     // Conformational changes
            DIFFUSION_COEFFICIENT: 0.8        // Brownian motion
        };

        function updatePerformanceMetrics() {
            performanceMetrics.vocabularySize = wordTokenizer.size;
            performanceMetrics.totalMemoryUsage = bacteriaPopulation.reduce((sum, b) => sum + b.memory_bank.length, 0);
            performanceMetrics.lastUpdate = Date.now();
            
            // v829: FPS Calculation
            const now = performance.now();
            if (performanceMetrics.lastFrameTime > 0) {
                const delta = now - performanceMetrics.lastFrameTime;
                performanceMetrics.fps = Math.round(1000 / delta);
                performanceMetrics.frameCount++;
                
                // Update FPS displays
                updateFPSDisplays();
            }
            performanceMetrics.lastFrameTime = now;
            
            // Console debug every 5 seconds
            if (performanceMetrics.frameCount % 300 === 0) { // Roughly every 5 seconds at 60fps
                console.log('ğŸ“Š v829 Performance:', {
                    fps: performanceMetrics.fps,
                    bacteria: bacteriaPopulation.length,
                    vocabulary: performanceMetrics.vocabularySize,
                    memory: performanceMetrics.totalMemoryUsage
                });
            }
        }

        function updateFPSDisplays() {
            const fpsDisplay = document.getElementById('fpsDisplay');
            const canvasFpsDisplay = document.getElementById('canvasFpsDisplay');
            const bacteriaCountDisplay = document.getElementById('bacteriaCount');
            const dayDisplayElement = document.getElementById('dayDisplay');
            
            if (fpsDisplay) fpsDisplay.textContent = `FPS: ${performanceMetrics.fps}`;
            if (canvasFpsDisplay) canvasFpsDisplay.textContent = performanceMetrics.fps;
            if (bacteriaCountDisplay) bacteriaCountDisplay.textContent = `Bakteri: ${bacteriaPopulation.length}`;
            if (dayDisplayElement) dayDisplayElement.textContent = `GÃ¼n: ${simulationDay}`;
        }

        // v829: Canvas Initialization and Management
        function initializeCanvas() {
            canvas = document.getElementById('simCanvas');
            if (canvas) {
                ctx = canvas.getContext('2d');
                resizeCanvas();
                useCanvas = true;
                console.log('ğŸ¨ Canvas initialized for enhanced rendering');
                
                // Add resize listener
                window.addEventListener('resize', resizeCanvas);
                
                // Canvas click handler for food placement
                canvas.addEventListener('click', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    addFood(x, y);
                });
            }
        }

        function resizeCanvas() {
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            // Set canvas size (avoiding the CSS sizing bug from HATA Ã‡Ã–ZÃœMLERÄ°.txt)
            canvasWidth = rect.width - 32; // Account for padding
            canvasHeight = rect.height - 32;
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            console.log(`ğŸ”§ Canvas resized: ${canvasWidth}x${canvasHeight}`);
        }
        let nextTokenId = 1;



        // ğŸ¯ SYSTEM STATUS TRACKER
        const systemStatus = {
            db: false,
            tabpfn: false,
            tfjs: false,
            simulation: false
        };

        function updateBuildInfo() {
            try {
                const buildInfo = document.getElementById('buildInfo');
                if (!buildInfo) return;
                
                const simStatus = systemStatus.simulation ? 'ğŸŸ¢ Running' : 'ğŸ”´ Paused';
                const dbStatus = systemStatus.db ? 'ğŸŸ¢ Connected' : 'ğŸ”´ Offline';
                
                // ML Status: daha detaylÄ±
                let mlStatus = 'ğŸ”´ Loading';
                if (systemStatus.tabpfn && systemStatus.tfjs) {
                    mlStatus = 'ğŸŸ¢ Full Ready';
                } else if (systemStatus.tabpfn || systemStatus.tfjs) {
                    mlStatus = 'ğŸŸ¡ Partial';
                }
                
                // Memory status
                let memStatus = '';
                try {
                    if (typeof MemoryManager !== 'undefined' && MemoryManager.getMemoryUsage) {
                        const memInfo = MemoryManager.getMemoryUsage();
                        memStatus = memInfo.used > 0 ? `ğŸ“Š ${memInfo.used}MB` : '';
                    }
                } catch (e) { /* ignore */ }
                
                // Learning engine stats
                const learningStats = learningEngine.getStats();
                const successRate = (learningStats.recentSuccessRate * 100).toFixed(0);
                
                buildInfo.innerHTML = `
                    Build: ${BUILD_DATE} | Features: ${FEATURES.length} | 
                    Sim: ${simStatus} | 
                    Chat Mode: <span class="text-yellow-400">${chatMode.toUpperCase()}</span> | 
                    ML: <span class="text-${systemStatus.tabpfn && systemStatus.tfjs ? 'green' : 'orange'}-400">${mlStatus}</span> |
                    DB: ${dbStatus} | 
                    ğŸ§  AI Success: <span class="text-cyan-400">${successRate}%</span> | ${memStatus}
                `;
            } catch (error) {
                console.warn('âš ï¸ updateBuildInfo error (ignored):', error.message);
            }
        }

        // ğŸ¯ EVENT-DRIVEN INITIALIZATION LISTENERS
        function initializeEventListeners() {
            // Database ready
            appEvents.on('db:ready', (dbInstance) => {
                console.log('ğŸ“¡ Event: Database ready');
                systemStatus.db = true;
                updateBuildInfo();
            });

            // TabPFN ready  
            appEvents.on('ai:tabpfn:ready', (tabpfnInstance) => {
                console.log('ğŸ“¡ Event: TabPFN AI ready');
                systemStatus.tabpfn = true;
                updateBuildInfo();
            });

            // TensorFlow.js ready
            appEvents.on('ai:tfjs:ready', (tfjsInstance) => {
                console.log('ğŸ“¡ Event: TensorFlow.js AI ready');
                systemStatus.tfjs = true;
                isMLReady = true; // Global flag
                updateBuildInfo();
            });

            // All systems ready
            appEvents.on('all:systems:ready', () => {
                console.log('ğŸ“¡ Event: All systems ready!');
                updateBuildInfo();
                
                // Enable advanced features
                const advancedButtons = document.querySelectorAll('[data-requires-ai]');
                advancedButtons.forEach(btn => {
                    btn.disabled = false;
                    btn.classList.remove('opacity-50');
                });
            });

            // Error handling
            appEvents.on('db:error', (error) => {
                console.error('ğŸ“¡ Event: Database error:', error);
                updateBuildInfo();
            });

            appEvents.on('ai:tfjs:error', (error) => {
                console.error('ğŸ“¡ Event: TensorFlow.js error:', error);
                updateBuildInfo();
            });
        }

        // Vocabulary Stages (Simplified from FUNCTION_ROADMAP.md)
        const vocabularyStages = [
            { stage: 0, name: "Temel Ä°htiyaÃ§lar", words: ["aÃ§", "yardÄ±m", "aÄŸrÄ±"], threshold: 0 },
            { stage: 1, name: "Basit Duygular", words: ["mutlu", "Ã¼zgÃ¼n", "korku"], threshold: 3 },
            { stage: 2, name: "Ã‡evresel Kavramlar", words: ["sÄ±cak", "soÄŸuk", "yemek"], threshold: 6 },
            { stage: 3, name: "Sosyal Kavramlar", words: ["arkadaÅŸ", "konuÅŸmak", "birlikte"], threshold: 10 },
            { stage: 4, name: "Soyut Kavramlar", words: ["gelecek", "hafÄ±za", "rÃ¼ya"], threshold: 15 },
            { stage: 5, name: "Felsefi DÃ¼ÅŸÃ¼nce", words: ["varoluÅŸ", "amaÃ§", "bilinÃ§"], threshold: 20 }
        ];
        
        const allPossibleWords = vocabularyStages.reduce((acc, stage) => acc.concat(stage.words), []);

        // Initialize word tokenizer with base vocabulary
        function initializeTokenizer() {
            allPossibleWords.forEach(word => {
                if (!wordTokenizer.has(word)) {
                    wordTokenizer.set(word, nextTokenId++);
                }
            });
            console.log('ğŸ§  Tokenizer initialized with', wordTokenizer.size, 'words');
        }

        // Create mini neural network for word learning
        async function createWordEmbeddingModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [50], units: 32, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 16, activation: 'relu' }),
                    tf.layers.dense({ units: 8, activation: 'softmax' })
                ]
            });

            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            return model;
        }

        // Create behavior prediction model
        async function createBehaviorModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [12], units: 24, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.1 }),
                    tf.layers.dense({ units: 12, activation: 'relu' }),
                    tf.layers.dense({ units: 6, activation: 'softmax' })
                ]
            });

            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            return model;
        }

        // Extract and learn new words from user input
        function learnFromUserInput(message, bacteria) {
            const words = message.toLowerCase().split(/\s+/);
            let newWordsLearned = 0;

            words.forEach(word => {
                // Clean word
                word = word.replace(/[^\w]/g, '');
                if (word.length < 2) return;

                // Add to tokenizer if new
                if (!wordTokenizer.has(word)) {
                    wordTokenizer.set(word, nextTokenId++);
                    console.log(`ğŸ†• ${bacteria.name} learned new word: "${word}"`);
                    newWordsLearned++;
                }

                // Add to bacteria vocabulary if consciousness allows
                if (bacteria.consciousness_level > 1.5 && Math.random() < 0.6) {
                    bacteria.vocabulary.add(word);
                }
            });

            // Update bacteria memory about learning
            if (newWordsLearned > 0) {
                bacteria.memory_bank.push(`${newWordsLearned} yeni kelime Ã¶ÄŸrendim: "${words.join(' ')}"`);
                
                // v822: Enhanced memory consolidation
                bacteria.consolidateMemory();
            }

            return newWordsLearned;
        }

        // Generate new words using TabPFN vocabulary analysis
        async function generateNewWord(bacteria) {
            if (!bacteria || !bacteria.vocabulary) return null;
            
            try {
                // Try TabPFN vocabulary analysis first
                if (tabPFNAdapter && tabPFNAdapter.isReady && tabPFNAdapter.analyzeVocabulary) {
                    const vocabAnalysis = await tabPFNAdapter.analyzeVocabulary(bacteria);
                    if (vocabAnalysis && vocabAnalysis.suggested_next_words && vocabAnalysis.suggested_next_words.length > 0) {
                        const suggestedWords = vocabAnalysis.suggested_next_words;
                        const newWord = suggestedWords[Math.floor(Math.random() * suggestedWords.length)];
                        
                        if (newWord && !bacteria.vocabulary.has(newWord)) {
                            bacteria.vocabulary.add(newWord);
                            if (!wordTokenizer.has(newWord)) {
                                wordTokenizer.set(newWord, nextTokenId++);
                            }
                            console.log(`ğŸ¯ TabPFN suggested word "${newWord}" for ${bacteria.name}`);
                            return newWord;
                        }
                    }
                }
            } catch (error) {
                console.error('TabPFN word generation error:', error);
                // Continue to fallback
            }
            
            // Fallback to traditional word generation
            const vocabArray = Array.from(bacteria.vocabulary);
            if (vocabArray.length < 2) {
                // Basic starter words for new bacteria
                const starterWords = ['hello', 'life', 'grow', 'learn', 'energy', 'food'];
                const newWord = starterWords[Math.floor(Math.random() * starterWords.length)];
                bacteria.vocabulary.add(newWord);
                return newWord;
            }

            // Simple word combination for fallback
            const word1 = vocabArray[Math.floor(Math.random() * vocabArray.length)];
            const word2 = vocabArray[Math.floor(Math.random() * vocabArray.length)];
            
            if (word1 === word2) return null;

            // Create compound words
            const combinations = [
                word1 + word2,
                word1.slice(0, -1) + word2.slice(1),
                word1.slice(0, 2) + word2.slice(-2),
                word1[0] + word2
            ];

            const newWord = combinations[Math.floor(Math.random() * combinations.length)];
            
            // Add to vocabulary and tokenizer
            bacteria.vocabulary.add(newWord);
            if (!wordTokenizer.has(newWord)) {
                wordTokenizer.set(newWord, nextTokenId++);
            }

            return newWord;
        }

        // v8.2.7: TabPFN-powered behavior prediction 
        async function predictBehavior(bacteria, context = 'general') {
            const startTime = performance.now();
            
            // Use real TabPFN model first
            if (tabPFNAdapter && tabPFNAdapter.isReady) {
                try {
                    const behavior = await tabPFNAdapter.adaptBehavior(bacteria, context);
                    performanceMetrics.mlInferenceTime = performance.now() - startTime;
                    console.log(`ğŸ¯ TabPFN predicted "${behavior}" for ${bacteria.name} (${(performance.now() - startTime).toFixed(1)}ms)`);
                    return behavior;
                } catch (error) {
                    console.error('âŒ TabPFN prediction failed:', error);
                }
            }
            
            // Fallback to TensorFlow.js if TabPFN unavailable
            if (realAI && realAI.behaviorModel) {
                try {
                    const behavior = await realAI.predictBehavior(bacteria);
                    await realAI.collectTrainingData(bacteria, behavior);
                    performanceMetrics.mlInferenceTime = performance.now() - startTime;
                    return behavior;
                } catch (error) {
                    console.error('âŒ Real AI prediction failed:', error);
                }
            }
            
            // Enhanced fallback with real dynamic values (no more placeholders!)
            const features = [
                bacteria.biological_state.age / 100,
                bacteria.biological_state.size / 5,
                bacteria.consciousness_level / 10, // Unlimited now
                bacteria.personality_traits.optimism,
                bacteria.personality_traits.sociability,
                bacteria.vocabulary.size / 20,
                bacteria.memory_bank.length / 10,
                bacteria.hunger, // Real dynamic value!
                bacteria.energy, // Real dynamic value!
                bacteria.biological_state.growth_rate,
                bacteria.getProximityToOthers(), // Real proximity calculation!
                bacteria.getRecentActivityLevel() // Real activity tracking!
            ];

            // Enhanced classification with consciousness-based behavior
            const avgScore = features.reduce((sum, val) => sum + val, 0) / features.length;
            const consciousnessBonus = bacteria.consciousness_level / 50; // Higher consciousness = more sophisticated behavior
            const finalScore = avgScore + consciousnessBonus;
            
            let behavior;
            if (finalScore > 0.8) behavior = 'creative';
            else if (finalScore > 0.6) behavior = 'learner';
            else if (finalScore > 0.4) behavior = 'social';
            else if (finalScore > 0.2) behavior = 'explorer';
            else behavior = 'basic';
            
            performanceMetrics.mlInferenceTime = performance.now() - startTime;
            return behavior;
        }

        // Food Particle Class
        class FoodParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = CONFIG.UI.FOOD_SIZE;
                this.nutrition = FOOD_NUTRITION;
                this.color = '#90EE90'; // Light green
            }
        }

        // Add random food particle to simulation area
        function addRandomFood() {
            const x = Math.random() * (CONFIG.CANVAS.SIMULATION_AREA_WIDTH - 20) + 10;
            const y = Math.random() * (CONFIG.CANVAS.SIMULATION_AREA_HEIGHT - 20) + 10;
            addFood(x, y);
        }

        // Add food at specific coordinates
        function addFood(x, y) {
            const food = new FoodParticle(x, y);
            foodParticles.push(food);
            console.log(`ğŸ Yemek eklendi: (${x.toFixed(0)}, ${y.toFixed(0)})`);
        }

        // --- Core Bacteria Logic (Simplified from System Architecture) ---
        class BacteriaEntity {
            constructor(id, name, existingData = null) {
                this.id = id;
                this.name = name || `Bakteri-${id}`;
                
                if (existingData) {
                    // Restore from database
                    this.biological_state = existingData.biological_state;
                    this.personality_traits = existingData.personality_traits;
                    this.consciousness_level = existingData.consciousness_level; // Unlimited!
                    this.language_stage = existingData.language_stage;
                    this.vocabulary = new Set(existingData.vocabulary);
                    this.memory_bank = existingData.memory_bank;
                    this.conversation_history = existingData.conversation_history;
                    this.x = existingData.position ? existingData.position.x : existingData.x || Math.random() * 400 + 50;
                    this.y = existingData.position ? existingData.position.y : existingData.y || Math.random() * 300 + 50;
                    this.z = existingData.position ? existingData.position.z : existingData.z || Math.random() * 100 + 50;
                    this.vx = existingData.velocity ? existingData.velocity.vx : (Math.random() - 0.5) * 12;
                    this.vy = existingData.velocity ? existingData.velocity.vy : (Math.random() - 0.5) * 12;
                    this.vz = existingData.velocity ? existingData.velocity.vz : (Math.random() - 0.5) * 2;
                    this.color = existingData.color;
                    this.total_runtime_days = existingData.total_runtime_days || 0;
                    this.max_consciousness_reached = existingData.max_consciousness_reached || this.consciousness_level;
                    console.log(`ğŸ”„ Restored bacteria #${id} with consciousness ${this.consciousness_level.toFixed(2)}`);
                } else {
                    // Create new bacteria
                    this.biological_state = {
                        size: parseFloat((Math.random() * 2 + 1).toFixed(2)), // 1-3 Âµm
                        age: 0,
                        growth_rate: parseFloat((Math.random() * 0.5 + 0.5).toFixed(2)), // 0.5-1.0
                        division_potential: 0, // When it reaches 1, it can divide
                    };
                    this.personality_traits = {
                        optimism: parseFloat(Math.random().toFixed(2)), // 0-1
                        sociability: parseFloat(Math.random().toFixed(2)), // 0-1
                    };
                    this.consciousness_level = 0; // Start at 0, can grow infinitely!
                    this.language_stage = 0; // 0-5
                    this.vocabulary = new Set();
                    this.memory_bank = []; // Store significant events or learned concepts
                    this.conversation_history = []; // For context in chat
                    this.x = Math.random() * 400 + 50; // Position within simulation area
                    this.y = Math.random() * 300 + 50;
                    this.z = Math.random() * 100 + 50; // Z-depth: 50-150 (pseudo-3D depth)
                    this.vx = (Math.random() - 0.5) * 12; // Velocity (increased to 12 for high-speed dynamic movement)
                    this.vy = (Math.random() - 0.5) * 12;
                    this.vz = (Math.random() - 0.5) * 2; // Slow Z movement for depth variation
                    this.color = this.generateColor();
                    this.total_runtime_days = 0;
                    this.max_consciousness_reached = 0;
                    console.log(`ğŸ†• Created new bacteria #${id}`);
                }
                
                // Persistence tracking
                this.last_save_time = Date.now();
                this.save_interval = 30000; // Save every 30 seconds
                this.consciousness_history = []; // Track consciousness evolution
                
                // v829: Enhanced Dynamic Systems 
                this.hunger = Math.random() * 0.3 + 0.2; // 0.2-0.5 range (less hungry start)
                this.energy = Math.random() * 0.2 + 0.7; // 0.7-0.9 range (more energetic start)
                this.last_food_time = Date.now();
                this.last_interaction_time = Date.now();
                this.activity_log = []; // Track recent activities
                this.interaction_count = 0;
                this.movement_efficiency = 0.8 + Math.random() * 0.2; // 0.8-1.0 movement efficiency

                // v8.5.0: Advanced AI/ML Integration
                this.neuralNetwork = new AdvancedNeuralNetwork();
                this.fitness = 0; // For genetic algorithm
                this.lastDecision = null;
                this.aiExperiences = [];
                this.behaviorPattern = 'explorer'; // Will be learned
            }

            generateColor() {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            // Simulated daily update
            updateDaily() {
                this.biological_state.age++;
                this.total_runtime_days++;
                
                // Growth and aging effects
                this.biological_state.size += this.biological_state.growth_rate * 0.1;
                this.biological_state.division_potential += 0.1;
                
                // Unlimited consciousness development!
                const consciousnessGrowthRate = 0.02 + (this.vocabulary.size / 100) + (this.memory_bank.length / 50);
                const previousConsciousness = this.consciousness_level;
                this.consciousness_level += consciousnessGrowthRate;
                
                // Track max consciousness reached
                if (this.consciousness_level > this.max_consciousness_reached) {
                    this.max_consciousness_reached = this.consciousness_level;
                }
                
                // Record consciousness evolution
                this.consciousness_history.push({
                    day: this.biological_state.age,
                    level: this.consciousness_level,
                    vocabulary_size: this.vocabulary.size,
                    memory_count: this.memory_bank.length
                });
                
                // Keep last 100 consciousness records
                if (this.consciousness_history.length > 100) {
                    this.consciousness_history.splice(0, 1);
                }
                
                // Language stage progression (no longer limited to 5)
                if (this.consciousness_level >= 1) this.language_stage = Math.max(1, this.language_stage);
                if (this.consciousness_level >= 2) this.language_stage = Math.max(2, this.language_stage);
                if (this.consciousness_level >= 3) this.language_stage = Math.max(3, this.language_stage);
                if (this.consciousness_level >= 5) this.language_stage = Math.max(4, this.language_stage);
                if (this.consciousness_level >= 10) this.language_stage = Math.max(5, this.language_stage);
                if (this.consciousness_level >= 20) this.language_stage = Math.max(6, this.language_stage);
                if (this.consciousness_level >= 50) this.language_stage = Math.max(7, this.language_stage);
                if (this.consciousness_level >= 100) this.language_stage = Math.max(8, this.language_stage);
                
                // Vocabulary expansion based on consciousness level
                if (Math.random() < Math.min(0.9, this.consciousness_level / 10)) {
                    this.learnRandomWord();
                }
                
                // Personality evolution
                if (this.consciousness_level > previousConsciousness + 1) {
                    // Significant consciousness growth affects personality
                    this.personality_traits.optimism = Math.min(1, this.personality_traits.optimism + 0.01);
                    this.memory_bank.push(`BilinÃ§ seviyem ${this.consciousness_level.toFixed(2)}'ye ulaÅŸtÄ±! Kendimi daha zeki hissediyorum.`);
                }
                
                // Enhanced memory consolidation for higher consciousness
                if (this.consciousness_level > 5) {
                    this.consolidateMemory();
                }
                
                // v826: Update dynamic systems
                this.updateDynamicSystems();

                // v8.5.0: AI/ML Updates - Apply learning and make intelligent decisions
                if (behaviourLearningSystem) {
                    behaviourLearningSystem.enhanceBacteriaIntelligence(this);
                }

                // ğŸš€ TabPFN Vocabulary Learning Integration
                this.performTabPFNLearning();

                // Update fitness based on consciousness, survival, and social success
                this.updateFitness();

                // Make neural network decision for next action
                if (this.neuralNetwork) {
                    this.lastDecision = this.neuralNetwork.makeDecision(this);
                    this.applyAIDecision(this.lastDecision);
                }
                
                // Auto-save to database every 30 seconds
                if (Date.now() - this.last_save_time > this.save_interval) {
                    this.saveToDatabase();
                }
                
                // Log consciousness milestones
                if (this.consciousness_level >= 10 && previousConsciousness < 10) {
                    console.log(`ğŸ¯ ${this.name} reached consciousness level 10 - Advanced Intelligence!`);
                }
                if (this.consciousness_level >= 50 && previousConsciousness < 50) {
                    console.log(`ğŸš€ ${this.name} reached consciousness level 50 - Super Intelligence!`);
                }
                if (this.consciousness_level >= 100 && previousConsciousness < 100) {
                    console.log(`ğŸ‘‘ ${this.name} reached consciousness level 100 - Transcendent Intelligence!`);
                }
            }

            async saveToDatabase() {
                if (typeof persistentDB !== 'undefined' && persistentDB && persistentDB.isReady) {
                    await persistentDB.saveBacteria(this);
                    this.last_save_time = Date.now();
                }
            }

            // ğŸš€ TabPFN Enhanced Learning Performance
            performTabPFNLearning() {
                if (!tabpfnVocabularySystem) return;

                // Determine current behavior context
                const context = this.determineCurrentContext();
                
                // Get TabPFN recommendations
                const recommendations = tabpfnVocabularySystem.recommendWordsForContext(this, context);
                
                // Learn words with enhanced rate
                recommendations.forEach(word => {
                    if (Math.random() < CONFIG.VOCABULARY.CONTEXTUAL_LEARNING_RATE) {
                        const learned = tabpfnVocabularySystem.learnWord(this.id, word, context);
                        if (learned) {
                            this.vocabulary.add(word); // Also add to legacy vocabulary set
                            this.memory_bank.push(`TabPFN: "${word}" kelimesini Ã¶ÄŸrendim (${context})`);
                        }
                    }
                });

                // Generate occasional speech
                if (Math.random() < 0.15) { // 15% chance to speak daily
                    const emotion = this.getEmotionalState();
                    const speech = tabpfnVocabularySystem.generateSpeech(this.id, context, emotion);
                    if (speech) {
                        this.speak(speech, context);
                    }
                }

                // Track learning progress
                const progress = tabpfnVocabularySystem.getLearningProgress(this.id, this.consciousness_level);
                if (progress > 0.8 && Math.random() < 0.1) {
                    // Consciousness boost for high vocabulary achievement
                    this.consciousness_level += CONFIG.AI.CONSCIOUSNESS_BOOST_RATE * 2;
                    this.memory_bank.push(`Kelime haznemi geliÅŸtirdim! BilinÃ§ seviyem yÃ¼kseldi.`);
                }
            }

            // ğŸ¯ Determine current behavioral context
            determineCurrentContext() {
                const timeSinceFood = Date.now() - this.last_food_time;
                const timeSinceInteraction = Date.now() - this.last_interaction_time;
                
                if (this.hunger > 0.7) return 'food_seeking';
                if (this.biological_state.division_potential > 0.8) return 'reproduction';
                if (timeSinceInteraction < 10000) return 'social_interaction';
                if (this.consciousness_level > 10) return 'philosophical';
                if (this.consciousness_level > 5) return 'learning';
                return 'exploration';
            }

            // ğŸ˜Š Get emotional state for speech
            getEmotionalState() {
                if (this.energy > 0.8 && this.hunger < 0.3) return 'happy';
                if (this.consciousness_level > 15) return 'curious';
                if (this.interaction_count > 3) return 'social';
                if (this.energy < 0.3) return 'tired';
                return 'neutral';
            }

            // ğŸ’¬ Enhanced speaking with TabPFN
            speak(message, context = 'general') {
                this.conversation_history.push({
                    message: message,
                    context: context,
                    timestamp: Date.now(),
                    consciousness: this.consciousness_level
                });
                
                // Keep last 50 conversations
                if (this.conversation_history.length > 50) {
                    this.conversation_history.splice(0, 1);
                }
                
                this.createSpeechBubble(message, context);
                console.log(`ğŸ’¬ ${this.name} (C:${this.consciousness_level.toFixed(1)}): "${message}" [${context}]`);
            }

            // ğŸ­ Create speech bubble with context styling
            createSpeechBubble(message, context) {
                const bubble = document.createElement('div');
                bubble.className = `speech-bubble speech-${context}`;
                bubble.textContent = message;
                bubble.style.cssText = `
                    position: absolute;
                    left: ${this.x + 15}px;
                    top: ${this.y - 35}px;
                    background: ${this.getBubbleColor(context)};
                    color: white;
                    padding: 6px 10px;
                    border-radius: 15px;
                    font-size: 11px;
                    font-weight: bold;
                    max-width: 140px;
                    word-wrap: break-word;
                    z-index: 1000;
                    box-shadow: 0 3px 8px rgba(0,0,0,0.4);
                    border: 2px solid rgba(255,255,255,0.3);
                    animation: speechBubbleAnim 4s ease-in-out;
                `;
                
                canvas.parentElement.appendChild(bubble);
                
                setTimeout(() => {
                    if (bubble.parentElement) {
                        bubble.parentElement.removeChild(bubble);
                    }
                }, 4000);
            }

            // ğŸ¨ Context-based bubble colors
            getBubbleColor(context) {
                const colors = {
                    'food_seeking': '#FF6B35',      // Orange - hunger
                    'social_interaction': '#4ECDC4', // Teal - social
                    'reproduction': '#FF006E',       // Pink - reproduction
                    'exploration': '#8338EC',        // Purple - adventure
                    'learning': '#FFBE0B',          // Yellow - learning
                    'philosophical': '#FB5607',      // Red-orange - deep thought
                    'general': '#219EBC'            // Blue - default
                };
                return colors[context] || colors['general'];
            }

            // ğŸ“Š Update fitness score for genetic algorithm
            updateFitness() {
                this.fitness = 0;
                
                // Consciousness contribution (40%)
                this.fitness += this.consciousness_level * 4;
                
                // Survival factors (30%)
                this.fitness += this.biological_state.age * 0.5;
                this.fitness += (1 - this.hunger) * 10;
                this.fitness += this.energy * 10;
                
                // Social factors (20%)
                this.fitness += this.conversation_history.length * 0.2;
                this.fitness += this.interaction_count * 0.1;
                
                // Learning factors (10%)
                this.fitness += this.vocabulary.size * 0.1;
                this.fitness += this.memory_bank.length * 0.05;
                
                // Size penalty for overcrowding
                if (this.biological_state.size > CONFIG.BACTERIA.MAX_SIZE * 0.9) {
                    this.fitness *= 0.8;
                }
                
                // Apply fitness decay
                this.fitness *= CONFIG.AI.FITNESS_DECAY;
                
                // ğŸ§  SELF-IMPROVEMENT: Track decision outcomes
                if (this._lastDecisionLog) {
                    const previousFitness = this._previousFitness || 0;
                    const fitnessChange = this.fitness - previousFitness;
                    const outcome = fitnessChange > 0 ? 'success' : (fitnessChange < -5 ? 'failure' : 'neutral');
                    
                    const metrics = {
                        fitnessChange,
                        currentFitness: this.fitness,
                        age: this.biological_state.age,
                        consciousness: this.consciousness_level,
                        survival: this.biological_state.age > 10 ? 'good' : 'poor'
                    };
                    
                    learningEngine.trackOutcome(this._lastDecisionLog, outcome, metrics);
                    this._lastDecisionLog = null; // Clear after tracking
                }
                
                this._previousFitness = this.fitness; // Store for next comparison
                return this.fitness;
            }

            learnRandomWord() {
                // Legacy method enhanced with TabPFN
                if (tabpfnVocabularySystem) {
                    const availableWords = tabpfnVocabularySystem.getAvailableWords(this);
                    const randomWord = availableWords[Math.floor(Math.random() * availableWords.length)];
                    if (randomWord && !this.vocabulary.has(randomWord)) {
                        this.vocabulary.add(randomWord);
                        tabpfnVocabularySystem.learnWord(this.id, randomWord, 'general');
                        return;
                    }
                }

                // Fallback to original consciousness-based vocabulary expansion
                let wordPool = [];
                
                if (this.consciousness_level < 1) {
                    wordPool = ['aÃ§', 'yardÄ±m', 'hareket'];
                } else if (this.consciousness_level < 5) {
                    wordPool = ['mutlu', 'arkadaÅŸ', 'Ã¶ÄŸrenme', 'bÃ¼yÃ¼me', 'keÅŸif'];
                } else if (this.consciousness_level < 10) {
                    wordPool = ['bilinÃ§', 'dÃ¼ÅŸÃ¼nce', 'felsefe', 'merak', 'anlayÄ±ÅŸ', 'empati'];
                } else if (this.consciousness_level < 20) {
                    wordPool = ['meta-biliÅŸ', 'soyutlama', 'yaratÄ±cÄ±lÄ±k', 'iÃ§gÃ¶rÃ¼', 'karmaÅŸÄ±klÄ±k'];
                } else if (this.consciousness_level < 50) {
                    wordPool = ['transsendence', 'ontoloji', 'epistemoloji', 'fenomenoloji', 'kognitif-bilim'];
                } else {
                    // Transcendent vocabulary
                    wordPool = ['kozmik-bilinÃ§', 'kuantum-zeka', 'multi-dimensional-dÃ¼ÅŸÃ¼nce', 'evrensel-anlayÄ±ÅŸ'];
                }
                
                if (wordPool.length > 0) {
                    const newWord = wordPool[Math.floor(Math.random() * wordPool.length)];
                    if (!this.vocabulary.has(newWord)) {
                        this.vocabulary.add(newWord);
                        this.memory_bank.push(`"${newWord}" kelimesini Ã¶ÄŸrendim! BilinÃ§ seviyem: ${this.consciousness_level.toFixed(2)}`);
                    }
                }
            }

            // v826: Dynamic system methods (replacing placeholders)
            updateDynamicSystems() {
                // Hunger increases over time
                const timeSinceFood = (Date.now() - this.last_food_time) / 60000; // minutes
                this.hunger = Math.min(1, this.hunger + timeSinceFood * 0.01);
                
                // Energy decreases with activity and age
                this.energy = Math.max(0, this.energy - 0.002 - (this.biological_state.age * 0.0001));
                
                // Energy affects consciousness development
                if (this.energy < 0.3) {
                    this.consciousness_level *= 0.99; // Slight consciousness decrease when tired
                }
                
                // Update activity log
                this.activity_log.push({
                    timestamp: Date.now(),
                    consciousness: this.consciousness_level,
                    hunger: this.hunger,
                    energy: this.energy
                });
                
                // Keep last 50 activity records
                if (this.activity_log.length > 50) {
                    this.activity_log.splice(0, 1);
                }
            }

            getProximityToOthers() {
                const allBacteria = bacteriaPopulation && bacteriaPopulation.length > 0 ? bacteriaPopulation : (bacteriaList || []);
                if (allBacteria.length < 2) return 0;
                
                let totalDistance = 0;
                let nearbyCount = 0;
                
                allBacteria.forEach(other => {
                    if (other && other.id !== this.id && typeof other.x === 'number' && typeof other.y === 'number') {
                        const distance = Math.sqrt(
                            Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2)
                        );
                        if (distance < 100) { // Within 100px range
                            totalDistance += distance;
                            nearbyCount++;
                        }
                    }
                });
                
                return nearbyCount > 0 ? 1 - (totalDistance / nearbyCount / 100) : 0;
            }

            getRecentActivityLevel() {
                if (this.activity_log.length < 2) return 0.5;
                
                const recent = this.activity_log.slice(-10); // Last 10 activities
                let activityScore = 0;
                
                for (let i = 1; i < recent.length; i++) {
                    const consciousnessDelta = Math.abs(recent[i].consciousness - recent[i-1].consciousness);
                    const energyDelta = Math.abs(recent[i].energy - recent[i-1].energy);
                    activityScore += consciousnessDelta + energyDelta;
                }
                
                return Math.min(1, activityScore / recent.length);
            }

            getInteractionCount() {
                const fiveMinutesAgo = Date.now() - 300000; // 5 minutes
                return this.conversation_history.filter(
                    conv => new Date(conv.timestamp || Date.now()).getTime() > fiveMinutesAgo
                ).length;
            }

            getLearningRate() {
                // Learning rate based on consciousness and recent word acquisition
                const recentMemories = this.memory_bank.filter(
                    mem => mem.includes('Ã¶ÄŸrendim')
                ).length;
                
                return Math.min(1, (this.consciousness_level / 10) + (recentMemories / 20));
            }

            feedBacteria() {
                // Called when bacteria eats food
                this.hunger = Math.max(0, this.hunger - 0.3);
                this.energy = Math.min(1, this.energy + 0.2);
                this.last_food_time = Date.now();
                
                // Learning from eating
                if (Math.random() < 0.3) {
                    this.vocabulary.add('lezzetli');
                    this.memory_bank.push('Besini tÃ¼ketdim ve enerjim arttÄ±!');
                }
            }

            interactWithOther(otherBacteria) {
                // Called during social interactions
                this.interaction_count++;
                this.last_interaction_time = Date.now();
                
                // Share vocabulary
                if (this.consciousness_level > 2 && Math.random() < 0.4) {
                    const myWords = Array.from(this.vocabulary);
                    const otherWords = Array.from(otherBacteria.vocabulary);
                    
                    // Learn from each other
                    if (otherWords.length > 0) {
                        const randomWord = otherWords[Math.floor(Math.random() * otherWords.length)];
                        this.vocabulary.add(randomWord);
                        this.memory_bank.push(`${otherBacteria.name}'den "${randomWord}" kelimesini Ã¶ÄŸrendim`);
                    }
                }
                
                // Collect training data for real AI
                if (realAI && realAI.behaviorModel) {
                    const behavior = Math.random() > 0.5 ? 'social' : 'learner';
                    realAI.collectTrainingData(this, behavior);
                }
            }

            move() {
                // v829: High-Speed Molecular Dynamics enhanced movement
                
                // Apply van der Waals forces between bacteria
                this.applyMolecularForces();
                
                // Enhanced Brownian motion with energy-based movement
                const energyBoost = this.energy * 0.5; // Energy affects movement speed
                const hungerMotivation = this.hunger * 0.3; // Hunger drives exploration
                
                this.vx += (Math.random() - 0.5) * MD_CONSTANTS.DIFFUSION_COEFFICIENT * (0.15 + energyBoost);
                this.vy += (Math.random() - 0.5) * MD_CONSTANTS.DIFFUSION_COEFFICIENT * (0.15 + energyBoost);
                
                // Add exploration behavior when hungry
                if (this.hunger > 0.6) {
                    this.vx += (Math.random() - 0.5) * hungerMotivation;
                    this.vy += (Math.random() - 0.5) * hungerMotivation;
                }
                
                // Reduced friction for more dynamic movement
                this.vx *= 0.99; // Minimal friction for fast movement
                this.vy *= 0.99;
                
                // Apply movement efficiency (3D movement)
                const efficiencyFactor = this.movement_efficiency;
                this.x += this.vx * efficiencyFactor;
                this.y += this.vy * efficiencyFactor;
                this.z += this.vz * efficiencyFactor; // Z-axis movement
                
                // Boundary checking with elastic collision (3D) - using CONFIG
                if (this.x <= 20 || this.x >= CONFIG.CANVAS.SIMULATION_AREA_WIDTH) {
                    this.vx *= -CONFIG.PHYSICS.BOUNDARY_ENERGY_LOSS;
                    this.x = Math.max(20, Math.min(CONFIG.CANVAS.SIMULATION_AREA_WIDTH, this.x));
                }
                if (this.y <= 20 || this.y >= CONFIG.CANVAS.SIMULATION_AREA_HEIGHT) {
                    this.vy *= -CONFIG.PHYSICS.BOUNDARY_ENERGY_LOSS;
                    this.y = Math.max(20, Math.min(CONFIG.CANVAS.SIMULATION_AREA_HEIGHT, this.y));
                }
                if (this.z <= CONFIG.PHYSICS.Z_DEPTH_MIN || this.z >= CONFIG.PHYSICS.Z_DEPTH_MAX) {
                    this.vz *= -(CONFIG.PHYSICS.BOUNDARY_ENERGY_LOSS - 0.1); // Slightly less Z energy loss
                    this.z = Math.max(CONFIG.PHYSICS.Z_DEPTH_MIN, Math.min(CONFIG.PHYSICS.Z_DEPTH_MAX, this.z));
                }

                // Look for nearby food with increased range when hungry
                this.lookForFood();
            }

            // Molecular Dynamics: Van der Waals and Electrostatic Forces
            applyMolecularForces() {
                const allBacteria = bacteriaPopulation && bacteriaPopulation.length > 0 ? bacteriaPopulation : (bacteriaList || []);
                allBacteria.forEach(otherBacteria => {
                    if (!otherBacteria || otherBacteria.id === this.id || typeof otherBacteria.x !== 'number') return;
                    
                    const dx = otherBacteria.x - this.x;
                    const dy = otherBacteria.y - this.y;
                    const dz = (otherBacteria.z || 100) - (this.z || 100); // Z-distance
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz); // 3D distance
                    
                    if (distance > 0 && distance < 50) { // Interaction range
                        // Van der Waals force (Lennard-Jones potential)
                        const sigma = (this.biological_state.size + otherBacteria.biological_state.size) * 2;
                        const r6 = Math.pow(sigma/distance, 6);
                        const r12 = r6 * r6;
                        const vdwForce = MD_CONSTANTS.VAN_DER_WAALS_STRENGTH * (12*r12 - 6*r6) / distance;
                        
                        // Electrostatic interaction (simplified Coulomb)
                        const chargeProduct = this.consciousness_level * otherBacteria.consciousness_level;
                        const electrostaticForce = MD_CONSTANTS.ELECTROSTATIC_FORCE * chargeProduct / (distance*distance);
                        
                        // Total force
                        const totalForce = vdwForce + electrostaticForce;
                        const fx = totalForce * dx / distance;
                        const fy = totalForce * dy / distance;
                        const fz = totalForce * dz / distance;
                        
                        // Apply force (Newton's law) - 3D
                        this.vx -= fx * 0.01;
                        this.vy -= fy * 0.01;
                        this.vz = (this.vz || 0) - fz * 0.005; // Lighter Z force
                        
                        // Social learning through proximity (MD-enhanced)
                        if (distance < 30 && Math.random() < 0.02) {
                            this.learnFromProximity(otherBacteria);
                        }
                    }
                });
            }

            // Enhanced social learning through molecular proximity
            learnFromProximity(otherBacteria) {
                // Exchange vocabulary (molecular diffusion analogy)
                const otherVocab = Array.from(otherBacteria.vocabulary);
                if (otherVocab.length > 0 && Math.random() < 0.3) {
                    const randomWord = otherVocab[Math.floor(Math.random() * otherVocab.length)];
                    this.vocabulary.add(randomWord);
                    this.memory_bank.push(`MolekÃ¼ler etkileÅŸim: ${otherBacteria.name}'den "${randomWord}" kelimesini Ã¶ÄŸrendim`);
                    
                    // Consciousness boost from molecular interaction (unlimited)
                    this.consciousness_level = this.consciousness_level + 0.01;
                }
            }

            lookForFood() {
                for (let i = foodParticles.length - 1; i >= 0; i--) {
                    const food = foodParticles[i];
                    const distance = Math.sqrt(
                        Math.pow(this.x - food.x, 2) + Math.pow(this.y - food.y, 2)
                    );
                    
                    // If close enough to eat food
                    if (distance < this.biological_state.size * 8 + food.size) {
                        this.eatFood(food);
                        foodParticles.splice(i, 1);
                        break;
                    }
                }
            }

            eatFood(food) {
                // v829: Enhanced ATP Synthesis with dynamic systems
                const atpGenerated = this.synthesizeATP(food.nutrition);
                
                // Metabolic pathway simulation - controlled growth using CONFIG
                const growthAmount = food.nutrition * CONFIG.BACTERIA.BASE_GROWTH_RATE * (1 + atpGenerated);
                this.biological_state.size = Math.min(CONFIG.BACTERIA.MAX_SIZE, this.biological_state.size + growthAmount);
                this.biological_state.growth_rate = Math.min(1.3, this.biological_state.growth_rate + 0.08); // Controlled max growth
                
                // Dynamic systems update
                this.hunger = Math.max(0, this.hunger - 0.4); // Reduce hunger more effectively
                this.energy = Math.min(1, this.energy + 0.3); // Boost energy significantly
                this.last_food_time = Date.now();
                
                // Protein folding effects on consciousness (unlimited)
                const proteinFoldingBoost = MD_CONSTANTS.PROTEIN_FOLDING_FACTOR * atpGenerated;
                const nutritionBonus = food.nutrition * 0.1; // Nutrition affects consciousness gain
                this.consciousness_level = this.consciousness_level + 0.08 + proteinFoldingBoost + nutritionBonus;
                
                // Enhanced memory with metabolic context
                this.memory_bank.push(`ATP sentezi: ${atpGenerated.toFixed(3)} enerji Ã¼rettim. AÃ§lÄ±ÄŸÄ±m azaldÄ±, enerjim arttÄ±!`);
                
                // Learn biochemical words with association learning
                if (Math.random() < 0.8) { // Increased learning chance when eating
                    const biochemWords = ['ATP', 'metabolizma', 'enzim', 'protein', 'lezzetli', 'enerji', 'sentez', 'beslenme', 'gÃ¼Ã§lÃ¼'];
                    const randomWord = biochemWords[Math.floor(Math.random() * biochemWords.length)];
                    this.vocabulary.add(randomWord);
                    
                    // Association learning - connect eating with positive words
                    if (Math.random() < 0.3) {
                        const positiveWords = ['mutlu', 'gÃ¼Ã§lÃ¼', 'saÄŸlÄ±klÄ±', 'geliÅŸim', 'bÃ¼yÃ¼me'];
                        const positiveWord = positiveWords[Math.floor(Math.random() * positiveWords.length)];
                        this.vocabulary.add(positiveWord);
                        this.memory_bank.push(`Yemek yerken "${positiveWord}" hissediyorum!`);
                    }
                }
            }

            // ATP Synthesis Simulation (based on MD research)
            synthesizeATP(nutrition) {
                // Simplified ATP synthase mechanism
                const protonGradient = this.consciousness_level / 5; // Mental energy affects ATP
                const enzymeEfficiency = 0.8 + (this.biological_state.growth_rate - 0.5) * 0.4;
                
                // ATP = nutrition Ã— gradient Ã— efficiency Ã— MD rate constant
                const atpOutput = nutrition * protonGradient * enzymeEfficiency * MD_CONSTANTS.ATP_SYNTHESIS_RATE;
                
                return Math.min(1.0, atpOutput); // Max 1.0 ATP per food
            }

            // v822: Enhanced Memory Consolidation System
            consolidateMemory() {
                // Keep only important memories, remove duplicates
                if (this.memory_bank.length > 15) {
                    // Keep last 10 memories and most important ones
                    const recentMemories = this.memory_bank.slice(-10);
                    const importantMemories = this.memory_bank.filter(m => 
                        m.includes('Ã¶ÄŸrendim') || m.includes('icat ettim') || m.includes('arkadaÅŸ')
                    ).slice(-5);
                    
                    this.memory_bank = [...new Set([...importantMemories, ...recentMemories])];
                    console.log(`ğŸ§  ${this.name} memory consolidated: ${this.memory_bank.length} memories kept`);
                }
            }

            // v829: Enhanced Reproduction System (Balanced for dynamic population)
            checkForReproduction() {
                // Dynamic reproduction requirements using CONFIG
                if (this.biological_state.age < CONFIG.BACTERIA.REPRODUCTION_MIN_AGE ||
                    this.biological_state.size < CONFIG.BACTERIA.REPRODUCTION_MIN_SIZE ||
                    this.consciousness_level < CONFIG.BACTERIA.REPRODUCTION_MIN_CONSCIOUSNESS ||
                    this.vocabulary.size < CONFIG.BACTERIA.REPRODUCTION_MIN_VOCABULARY ||
                    bacteriaPopulation.length >= CONFIG.SIMULATION.MAX_BACTERIA_POPULATION) {
                    return false;
                }

                // Enhanced reproduction chance calculation
                const reproductionChance = 
                    (this.biological_state.size - 1.2) * 0.15 + // Increased size factor
                    (this.consciousness_level - 1) * 0.08 + // Increased intelligence factor
                    (this.vocabulary.size - 5) * 0.02 + // Increased vocabulary factor
                    (this.biological_state.growth_rate - 0.5) * 0.1 + // Growth rate factor
                    (this.energy > 0.7 ? 0.03 : 0) + // Energy bonus
                    (this.hunger < 0.3 ? 0.02 : 0); // Well-fed bonus

                // Increased reproduction chance: 8% maximum for dynamic population
                if (Math.random() < Math.min(0.08, reproductionChance)) {
                    this.reproduce();
                    return true;
                }
                return false;
            }

            reproduce() {
                // Create offspring with inherited traits
                const childId = bacteriaIdCounter++;
                const childName = this.generateChildName();
                
                // Position near parent but not exactly same spot (3D)
                const offsetX = (Math.random() - 0.5) * 60;
                const offsetY = (Math.random() - 0.5) * 60;
                const offsetZ = (Math.random() - 0.5) * 30; // Smaller Z offset
                
                const childData = {
                    id: childId,
                    name: childName,
                    position: {
                        x: Math.max(20, Math.min(480, this.x + offsetX)),
                        y: Math.max(20, Math.min(280, this.y + offsetY)),
                        z: Math.max(20, Math.min(180, this.z + offsetZ))
                    },
                    velocity: {
                        vx: (Math.random() - 0.5) * 8, // Slightly slower than parent
                        vy: (Math.random() - 0.5) * 8,
                        vz: (Math.random() - 0.5) * 2  // Slow Z movement
                    },
                    
                    // Inherit some traits with mutations
                    biological_state: {
                        size: 0.8 + Math.random() * 0.4, // Start smaller
                        age: 0,
                        growth_rate: this.biological_state.growth_rate * (0.9 + Math.random() * 0.2)
                    },
                    
                    // Personality inheritance with minor mutations
                    personality_traits: {
                        optimism: Math.max(0.1, Math.min(1.0, this.personality_traits.optimism + (Math.random() - 0.5) * 0.2)),
                        sociability: Math.max(0.1, Math.min(1.0, this.personality_traits.sociability + (Math.random() - 0.5) * 0.2))
                    },
                    
                    // Start with lower consciousness but inherit some vocabulary
                    consciousness_level: 0.5 + Math.random() * 0.5,
                    vocabulary: new Set(Array.from(this.vocabulary).slice(0, Math.floor(this.vocabulary.size * 0.3))), // 30% inherited vocabulary
                    memory_bank: [`${this.name} annemden/babamdan doÄŸdum!`, 'DÃ¼nyaya geldim, Ã§ok heyecanlÄ±yÄ±m!'],
                    conversation_history: [],
                    color: this.generateColor()
                };

                const child = new BacteriaEntity(childId, childName, childData);
                bacteriaPopulation.push(child);
                bacteriaList.push(child);

                // Parent memories and energy cost
                this.memory_bank.push(`${childName} adÄ±nda bir Ã§ocuÄŸum dÃ¼nyaya geldi! Mutluyum ama yorgunum.`);
                this.biological_state.size *= 0.8; // Parent becomes smaller after reproduction
                this.consciousness_level += 0.1; // Gain wisdom from parenting
                
                // Learn parenting vocabulary
                ['anne', 'baba', 'Ã§ocuk', 'doÄŸum', 'mutluluk', 'aile'].forEach(word => {
                    if (Math.random() < 0.7) this.vocabulary.add(word);
                });

                console.log(`ğŸ‘¶ ${this.name} reproduced! Child: ${childName} (Population: ${bacteriaPopulation.length})`);
                
                // Visual birth effect
                this.addBirthEffect(child);
            }

            generateChildName() {
                const prefixes = ['Mini', 'KÃ¼Ã§Ã¼k', 'GenÃ§', 'Yeni', 'Bebek'];
                const suffixes = ['Jr', 'II', 'Ã‡ocuk', 'Minik'];
                
                const usePrefix = Math.random() < 0.5;
                if (usePrefix) {
                    return `${prefixes[Math.floor(Math.random() * prefixes.length)]} ${this.name}`;
                } else {
                    return `${this.name} ${suffixes[Math.floor(Math.random() * suffixes.length)]}`;
                }
            }

            addBirthEffect(child) {
                // Simple visual effect for birth (mobile-optimized)
                if (typeof renderBacteria === 'function') {
                    setTimeout(() => {
                        renderBacteria();
                        console.log(`ğŸ‰ ${child.name} is now visible!`);
                    }, 100);
                }
            }
        }

        // v8.2.8: TabPFN-Enhanced Chat System with Smart Word Usage
        function generateBacteriaResponse(bacteria, message, context = 'user') {
            const age = bacteria.biological_state.age;
            const consciousness = bacteria.consciousness_level;
            const vocabularySize = bacteria.vocabulary.size;
            const optimism = bacteria.personality_traits.optimism;
            const sociability = bacteria.personality_traits.sociability;
            
            // Learn from user input (unlimited consciousness)
            if (context === 'user') {
                const newWords = learnFromUserInput(message, bacteria);
                if (newWords > 0) {
                    bacteria.consciousness_level = bacteria.consciousness_level + 0.02;
                }
            }
            
            // Predict behavior using TabPFN
            const behaviorMode = predictBehavior(bacteria);
            
            // SMART WORD USAGE: Use learned vocabulary contextually
            const availableWords = Array.from(bacteria.vocabulary);
            
            // Determine conversation context for smart word selection
            let conversationContext = 'general';
            if (message && message.toLowerCase().includes('merhaba')) conversationContext = 'greeting';
            else if (message && (message.includes('Ã¶ÄŸren') || message.includes('bil'))) conversationContext = 'learning';
            else if (message && (message.includes('arkadaÅŸ') || message.includes('dostluk'))) conversationContext = 'social';
            else if (message && (message.includes('ATP') || message.includes('hÃ¼cre'))) conversationContext = 'science';
            
            // Use TabPFN to get contextual words
            let smartWord = null;
            if (tabPFNAdapter && tabPFNAdapter.isReady) {
                smartWord = tabPFNAdapter.improveWordUsage(bacteria, conversationContext);
            }
            
            // Generate new words occasionally
            if (consciousness > 2 && Math.random() < 0.1) {
                const newWord = generateNewWord(bacteria);
                if (newWord) {
                    bacteria.memory_bank.push(`"${newWord}" kelimesini icat ettim!`);
                }
            }
            
            // Response templates enhanced with ML behavior prediction
            let responseTemplates = [];
            
            if (consciousness < 1) {
                responseTemplates = [
                    `${availableWords[0] || 'aÃ§'}... ${availableWords[1] || 'yardÄ±m'}...`,
                    `*${bacteria.name} hareket ediyor*`,
                    `${Math.random() > 0.5 ? 'aÄŸrÄ±' : 'aÃ§'}...`
                ];
            } else if (consciousness < 2) {
                responseTemplates = [
                    `Ben ${bacteria.name}! ${optimism > 0.7 ? 'Mutluyum!' : optimism < 0.3 ? 'ÃœzgÃ¼nÃ¼m...' : 'Ä°yiyim.'}`,
                    `${sociability > 0.7 ? 'Seninle konuÅŸmak gÃ¼zel!' : 'Merhaba...'}`,
                    `${vocabularySize > 3 ? availableWords.slice(0,3).join(' ') : 'aÃ§ yardÄ±m'}!`
                ];
            } else if (consciousness < 3) {
                responseTemplates = [
                    `Merhaba! Ben ${bacteria.name}, ${age} gÃ¼nlÃ¼k bir bakteriyim. ${optimism > 0.6 ? 'BugÃ¼n harika!' : 'NasÄ±lsÄ±n?'}`,
                    `${sociability > 0.5 ? 'Seninle sohbet etmeyi seviyorum!' : 'KonuÅŸuyoruz iÅŸte...'}`,
                    `BugÃ¼n ${bacteria.memory_bank.length > 0 ? bacteria.memory_bank[bacteria.memory_bank.length-1] : 'yeni ÅŸeyler Ã¶ÄŸreniyorum'}!`
                ];
            } else {
                // Advanced consciousness with TabPFN behavior modes + Smart Word Usage
                const baseTemplates = [
                    `Selam dostum! ${bacteria.name} burada. ${optimism > 0.7 ? 'Hayat gÃ¼zel!' : optimism < 0.3 ? 'Biraz melankolik hissediyorum...' : 'DÃ¼ÅŸÃ¼nceliyim.'} Sen nasÄ±lsÄ±n?`,
                    `${sociability > 0.7 ? 'Bu sohbeti Ã§ok seviyorum! Daha fazla konuÅŸalÄ±m!' : sociability < 0.3 ? 'KonuÅŸmak iyi ama biraz sessiz kalmayÄ± da severim...' : 'GÃ¼zel bir sohbet bu.'}`,
                    `Biliyorsun, ${vocabularySize} kelime biliyorum artÄ±k. ${bacteria.memory_bank.length > 0 ? 'Son zamanlarda ' + bacteria.memory_bank[bacteria.memory_bank.length-1] : 'SÃ¼rekli Ã¶ÄŸreniyorum'}.`
                ];

                // TabPFN-enhanced responses with smart word integration
                const behaviorTemplates = {
                    'creative': [
                        `Yeni bir ${smartWord || 'kelime'} icat etmeyi dÃ¼ÅŸÃ¼nÃ¼yorum... ${availableWords.slice(-2).join('')} nasÄ±l?`,
                        `Hayal gÃ¼cÃ¼m geliÅŸiyor! ${smartWord ? `"${smartWord}" kelimesini kullanarak ` : ''}${availableWords.length > 5 ? availableWords.slice(-3).join(' ') + ' kombinasyonu' : 'YaratÄ±cÄ± hissediyorum'}.`,
                        `${smartWord ? `"${smartWord}" hakkÄ±nda dÃ¼ÅŸÃ¼nÃ¼yordum... ` : ''}Kelimeler birleÅŸince yeni anlamlar doÄŸuyor!`
                    ],
                    'social': [
                        `DiÄŸer bakterilerle ${smartWord || (availableWords.includes('arkadaÅŸ') ? 'arkadaÅŸlÄ±k' : 'konuÅŸmak')} istiyorum!`,
                        `Sen de ${smartWord || 'Ã¶ÄŸrenmeyi'} seviyor musun? Ben ${bacteria.memory_bank.filter(m => m.includes('Ã¶ÄŸrendim')).length} kez yeni ÅŸeyler Ã¶ÄŸrendim!`,
                        `${smartWord ? `"${smartWord}" ile ilgili ` : ''}Birlikte ${availableWords.slice(-2).join(' ve ')} hakkÄ±nda konuÅŸalÄ±m!`
                    ],
                    'social_social': [
                        `ArkadaÅŸlarÄ±mla ${smartWord || 'paylaÅŸÄ±m'} yapmayÄ± seviyorum! Sosyal bir bakteriyim!`,
                        `${smartWord ? `"${smartWord}" deyince aklÄ±ma ` : ''}Dostluk Ã§ok Ã¶nemli, deÄŸil mi?`,
                        `Grup halinde ${smartWord || 'birlikte'} olmak harika!`
                    ],
                    'learner': [
                        `${smartWord ? `"${smartWord}" kelimesini Ã¶ÄŸrenince ` : ''}Her gÃ¼n ${Math.floor(Math.random() * 3) + 1} yeni kelime Ã¶ÄŸrenmeye Ã§alÄ±ÅŸÄ±yorum!`,
                        `${smartWord ? `Ã–zellikle "${smartWord}" konusunda ` : ''}Sen bana yeni kelimeler Ã¶ÄŸretebilir misin?`,
                        `${smartWord ? `"${smartWord}" fascinant! ` : ''}Ã–ÄŸrenme sÃ¼recim harika! ${bacteria.vocabulary.size > 10 ? 'ArtÄ±k Ã§ok kelime biliyorum' : 'Daha Ã§ok Ã¶ÄŸrenmek istiyorum'}.`
                    ],
                    'learner_enhanced': [
                        `GeliÅŸmiÅŸ ${smartWord || 'Ã¶ÄŸrenme'} modundayÄ±m! BilinÃ§ seviyem ${consciousness.toFixed(1)}`,
                        `${smartWord ? `"${smartWord}" Ã¼zerine derinlemesine ` : ''}Analitik dÃ¼ÅŸÃ¼nmeyi seviyorum!`,
                        `Superior ${smartWord || 'intelligence'} developing... Ã‡ok heyecanlÄ±yÄ±m!`
                    ],
                    'creative_enhanced': [
                        `Ultra-creative mode! ${smartWord ? `"${smartWord}" ile ` : ''}Yepyeni kavramlar yaratÄ±yorum!`,
                        `${smartWord ? `"${smartWord}" inspirasyonuyla ` : ''}Artistik gen mutasyonlarÄ±m var!`,
                        `Dimensional ${smartWord || 'creativity'} unlocked! Evrensel sanat anlayÄ±ÅŸÄ±m geliÅŸiyor!`
                    ],
                    'explorer': [
                        `${smartWord ? `"${smartWord}" arayÄ±ÅŸÄ±ndayÄ±m! ` : ''}KeÅŸfetmek istiyorum!`,
                        `Bu ortamda ${smartWord || 'yeni yerler'} bulmaya Ã§alÄ±ÅŸÄ±yorum`,
                        `Macera dolu ${smartWord || 'yolculuk'} istiyorum!`
                    ],
                    'basic': baseTemplates
                };

                responseTemplates = behaviorTemplates[behaviorMode] || baseTemplates;
            }
            
            let response = responseTemplates[Math.floor(Math.random() * responseTemplates.length)];
            
            // Add context-specific modifications
            if (context === 'bacteria' && sociability > 0.5) {
                response = response.replace('Merhaba!', 'Hey arkadaÅŸ!').replace('Selam!', 'Ey bakteri kardeÅŸ!');
            }
            
            return response;
        }

        async function sendMessageToBacteria(message) {
            if (chatMode === 'individual' && !selectedBacteria) {
                console.log('âŒ Individual chat requires selected bacteria');
                return;
            }
            if (chatMode === 'group' && bacteriaPopulation.length === 0) {
                console.log('âŒ Group chat requires bacteria population');
                return;
            }

            console.log(`ğŸ’¬ Sending message in ${chatMode} mode: "${message}"`);
            showChatLoading(true);
            addChatMessage(message, 'user');

            if (chatMode === 'individual') {
                // Individual chat with selected bacteria
                setTimeout(() => {
                    const response = generateBacteriaResponse(selectedBacteria, message, 'user');
                    selectedBacteria.conversation_history.push({ user: message, bacteria: response });
                    addChatMessage(response, 'bacteria', selectedBacteria.name);
                    showChatLoading(false);
                }, 1000 + Math.random() * 1000);
                         } else if (chatMode === 'group') {
                 // Group chat - all bacteria respond
                 let responseCount = 0;
                 const totalBacteria = bacteriaPopulation.length;
                 const responseBacteria = [];
                 
                 bacteriaPopulation.forEach((bacteria, index) => {
                     setTimeout(() => {
                         if (Math.random() < 0.7) { // 70% chance each bacteria responds
                             const response = generateBacteriaResponse(bacteria, message, 'user');
                             bacteria.conversation_history.push({ user: message, bacteria: response });
                             addChatMessage(response, 'bacteria', bacteria.name);
                             responseBacteria.push(bacteria);
                         }
                         responseCount++;
                         if (responseCount === totalBacteria) {
                             // After all responses, bacteria learn from each other in group
                             if (responseBacteria.length > 1) {
                                 setTimeout(() => {
                                     groupLearningSession(responseBacteria);
                                 }, 1000);
                             }
                             showChatLoading(false);
                         }
                     }, (index + 1) * (500 + Math.random() * 1000));
                 });
             }
        }

        // v826: Natural conversation based on proximity and social needs
        function startNaturalBacteriaConversation(socialBacteria) {
            if (socialBacteria.length < 2) return;
            
            // Find bacteria that are close to each other (natural interaction)
            let bacteria1 = null, bacteria2 = null;
            let minDistance = Infinity;
            
            for (let i = 0; i < socialBacteria.length; i++) {
                for (let j = i + 1; j < socialBacteria.length; j++) {
                    const dx = socialBacteria[i].x - socialBacteria[j].x;
                    const dy = socialBacteria[i].y - socialBacteria[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance && distance < 80) { // Close proximity
                        minDistance = distance;
                        bacteria1 = socialBacteria[i];
                        bacteria2 = socialBacteria[j];
                    }
                }
            }
            
            // If no close bacteria, pick random social ones
            if (!bacteria1 || !bacteria2) {
                bacteria1 = socialBacteria[Math.floor(Math.random() * socialBacteria.length)];
                bacteria2 = socialBacteria[Math.floor(Math.random() * socialBacteria.length)];
                while (bacteria2 === bacteria1) {
                    bacteria2 = socialBacteria[Math.floor(Math.random() * socialBacteria.length)];
                }
            }
            
            // Natural conversation topics based on bacteria state
            const naturalTopics = [
                `Merhaba ${bacteria2.name}!`, 'Bu yemek lezzetli deÄŸil mi?', 'Kendimi daha akÄ±llÄ± hissediyorum',
                'BÃ¼yÃ¼dÃ¼ÄŸÃ¼mÃ¼ fark ettim', 'Yeni kelimeler Ã¶ÄŸreniyorum', 'Bu ortam gÃ¼zel',
                'Seninle konuÅŸmak gÃ¼zel', 'Beraber Ã¶ÄŸrenelim', 'NasÄ±l bu kadar bÃ¼yÃ¼dÃ¼n?'
            ];
            
            const topic = naturalTopics[Math.floor(Math.random() * naturalTopics.length)];
            
            // Save conversation to both bacteria's individual chat history
            const conversation = {
                participants: [bacteria1.name, bacteria2.name],
                messages: [],
                timestamp: Date.now()
            };
            
            // Start natural conversation
            setTimeout(() => {
                const message1 = generateBacteriaResponse(bacteria1, topic, 'bacteria');
                conversation.messages.push({ speaker: bacteria1.name, message: message1, time: Date.now() });
                
                // Save to individual chat histories
                bacteria1.chatHistory = bacteria1.chatHistory || [];
                bacteria2.chatHistory = bacteria2.chatHistory || [];
                
                bacteria1.chatHistory.push({type: 'sent', to: bacteria2.name, message: message1, time: Date.now()});
                bacteria2.chatHistory.push({type: 'received', from: bacteria1.name, message: message1, time: Date.now()});
                
                // Second bacteria responds
                setTimeout(() => {
                    const message2 = generateBacteriaResponse(bacteria2, message1, 'bacteria');
                    conversation.messages.push({ speaker: bacteria2.name, message: message2, time: Date.now() });
                    
                    bacteria2.chatHistory.push({type: 'sent', to: bacteria1.name, message: message2, time: Date.now()});
                    bacteria1.chatHistory.push({type: 'received', from: bacteria2.name, message: message2, time: Date.now()});
                    
                    // Cross-learning
                    bacteriaLearnFromEachOther(bacteria1, bacteria2, message1, message2);
                    
                    // Store global conversation for viewing
                    globalConversations.push(conversation);
                    
                }, 800 + Math.random() * 1500);
            }, 300);
        }

        function startGroupLearningSession() {
            const learners = bacteriaPopulation.filter(b => b.consciousness_level > 1.5);
            if (learners.length < 3) return;
            
            // Pick 3 random learners
            const participants = [];
            for (let i = 0; i < 3 && i < learners.length; i++) {
                const randomIndex = Math.floor(Math.random() * learners.length);
                if (!participants.includes(learners[randomIndex])) {
                    participants.push(learners[randomIndex]);
                }
            }
            
            if (participants.length >= 3) {
                groupLearningSession(participants);
                console.log(`ğŸ“ Group learning session: ${participants.map(p => p.name).join(', ')}`);
            }
        }

        // Bacteria learn from each other's vocabulary and behaviors
        function bacteriaLearnFromEachOther(bacteria1, bacteria2, message1, message2) {
            // Share vocabulary between bacteria
            const vocab1 = Array.from(bacteria1.vocabulary);
            const vocab2 = Array.from(bacteria2.vocabulary);
            
            // Bacteria1 learns some words from bacteria2
            vocab2.forEach(word => {
                if (Math.random() < 0.3 && bacteria1.consciousness_level > 1) { // 30% chance
                    bacteria1.vocabulary.add(word);
                    if (Math.random() < 0.5) {
                        bacteria1.memory_bank.push(`${bacteria2.name}'den "${word}" kelimesini Ã¶ÄŸrendim`);
                    }
                }
            });
            
            // Bacteria2 learns some words from bacteria1
            vocab1.forEach(word => {
                if (Math.random() < 0.3 && bacteria2.consciousness_level > 1) {
                    bacteria2.vocabulary.add(word);
                    if (Math.random() < 0.5) {
                        bacteria2.memory_bank.push(`${bacteria1.name}'den "${word}" kelimesini Ã¶ÄŸrendim`);
                    }
                }
            });
            
            // Behavior influence: social bacteria make others more social
            if (bacteria1.personality_traits.sociability > 0.7) {
                bacteria2.personality_traits.sociability = Math.min(1, bacteria2.personality_traits.sociability + 0.02);
            }
            if (bacteria2.personality_traits.sociability > 0.7) {
                bacteria1.personality_traits.sociability = Math.min(1, bacteria1.personality_traits.sociability + 0.02);
            }
            
            // Consciousness boost from social interaction
                            bacteria1.consciousness_level = bacteria1.consciousness_level + 0.01;
                bacteria2.consciousness_level = bacteria2.consciousness_level + 0.01;
            
                         console.log(`ğŸ¤ ${bacteria1.name} and ${bacteria2.name} learned from each other`);
         }

         // Group learning session - all bacteria in group learn from each other
         function groupLearningSession(bacteria) {
             console.log(`ğŸ‘¥ Group learning session with ${bacteria.length} bacteria`);
             
             // Collect all vocabulary from participating bacteria
             const allVocabulary = new Set();
             bacteria.forEach(b => {
                 Array.from(b.vocabulary).forEach(word => allVocabulary.add(word));
             });
             
             // Each bacteria learns from the collective vocabulary
             bacteria.forEach((learner, i) => {
                 let wordsLearned = 0;
                 allVocabulary.forEach(word => {
                     if (!learner.vocabulary.has(word) && Math.random() < 0.2) { // 20% chance to learn each word
                         learner.vocabulary.add(word);
                         wordsLearned++;
                     }
                 });
                 
                 if (wordsLearned > 0) {
                     learner.memory_bank.push(`Grup sohbetinde ${wordsLearned} kelime Ã¶ÄŸrendim`);
                     learner.consciousness_level = learner.consciousness_level + 0.02;
                 }
                 
                 // Social influence - become more social from group interaction
                 learner.personality_traits.sociability = Math.min(1, learner.personality_traits.sociability + 0.01);
             });
         }

        function addChatMessage(message, sender, bacteriaName = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'} mb-2`;
            
            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = `chat-bubble p-2 rounded-lg ${sender === 'user' ? 'chat-bubble-user' : 'chat-bubble-bacteria'}`;
            
            if (sender === 'bacteria' && bacteriaName) {
                const nameSpan = document.createElement('div');
                nameSpan.className = 'text-xs font-semibold mb-1 opacity-75';
                nameSpan.textContent = bacteriaName;
                bubbleDiv.appendChild(nameSpan);
                
                const messageSpan = document.createElement('div');
                messageSpan.textContent = message;
                bubbleDiv.appendChild(messageSpan);
            } else {
                bubbleDiv.textContent = message;
            }
            
            messageDiv.appendChild(bubbleDiv);
            chatMessagesDiv.insertBefore(messageDiv, chatMessagesDiv.firstChild);
            // Auto scroll stays at bottom (newest messages at top due to column-reverse)
        }

        function showChatLoading(show) {
            chatLoadingIndicator.classList.toggle('hidden', !show);
        }

        // Event Delegation System for better performance and cleaner code
        class UIManager {
            constructor(simulationManager) {
                this.simulationManager = simulationManager;
                this.startSimulationBtn = document.getElementById('startSimulationBtn');
                this.nextStepBtn = document.getElementById('nextStepBtn');
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                // Use event delegation instead of individual onclick handlers
                document.addEventListener('click', this.handleGlobalClick.bind(this));
            }

            handleGlobalClick(event) {
                const button = event.target.closest('button');
                if (!button) return;

                const buttonText = button.textContent.trim();
                
                // Centralized button action mapping
                const actionMap = {
                    'â–¶ï¸ BaÅŸlat': () => this.startSimulation(),
                    'SimÃ¼lasyonu BaÅŸlat': () => this.startSimulation(),
                    'Devam Et': () => this.startSimulation(),
                    'Durdur': () => this.pauseSimulation(),
                    'â¸ï¸ Duraklat': () => this.pauseSimulation(),
                    'Sonraki AdÄ±m': () => this.nextStep(),
                    'ğŸ”„ SÄ±fÄ±rla': () => this.resetSimulation(),
                    'ğŸ Yemek Ekle': () => addRandomFood(),
                    'ğŸ“Š CSV Export': () => exportCSV(),
                    'ğŸ“ˆ JSON Export': () => exportEnhancedData(),
                    'ğŸ‘¥ Grup Sohbet': () => toggleGroupChat(),
                    'ğŸ’¬ Bireysel Sohbet': () => toggleGroupChat(),
                    'â• Bakteri Ekle': () => addBacteria()
                };

                const action = actionMap[buttonText];
                if (action) {
                    event.preventDefault();
                    action();
                }
            }

            startSimulation() {
                if (!this.simulationManager.isRunning) {
                    simulationRunning = true;
                    if (this.startSimulationBtn) this.startSimulationBtn.textContent = 'Durdur';
                    if (this.nextStepBtn) this.nextStepBtn.disabled = true;
                    this.simulationManager.start();
                } else {
                    this.pauseSimulation();
                }
            }

            pauseSimulation() {
                simulationRunning = false;
                if (this.startSimulationBtn) this.startSimulationBtn.textContent = 'Devam Et';
                if (this.nextStepBtn) this.nextStepBtn.disabled = false;
                this.simulationManager.pause();
            }

            nextStep() {
                this.simulationManager.simulationStep();
            }

            resetSimulation() {
                this.pauseSimulation();
                this.simulationManager.simulationDay = 0;
                simulationTimeSpan.textContent = 'SimÃ¼lasyon ZamanÄ±: 0 gÃ¼n';
                bacteriaPopulation.length = 0;
                bacteriaList.length = 0;
                foodParticles.length = 0;
                selectedBacteria = null;
                
                if (this.startSimulationBtn) this.startSimulationBtn.textContent = 'SimÃ¼lasyonu BaÅŸlat';
                if (this.nextStepBtn) this.nextStepBtn.disabled = false;
                
                bacteriaDetailsDiv.classList.add('hidden');
                chatInfoDiv.textContent = 'Sohbet modunu seÃ§in.';
                chatMessagesDiv.innerHTML = '';
                chatInput.disabled = true;
                sendMessageBtn.disabled = true;
                chatMode = 'individual';
                updateChatModeButtons();
                
                // Close all individual chat windows
                openChatWindows.forEach((modal, bacteriaId) => {
                    document.body.removeChild(modal);
                });
                openChatWindows.clear();
                
                initializeBacteria();
            }
        }

        // Utility functions for performance optimization
        class PerformanceUtils {
            static debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            static throttle(func, limit) {
                let inThrottle;
                return function() {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            }
        }

        // Initialize AI systems and UIManager after DOM is ready
        let uiManager = null;

        // v8.5.0: Initialize Advanced AI/ML Systems
        function initializeAISystems() {
            console.log('ğŸ§  Initializing Advanced AI/ML Systems...');
            
            try {
                // Initialize global AI systems
                globalNeuralNetwork = new AdvancedNeuralNetwork();
                geneticAlgorithm = new GeneticEvolutionSystem();
                behaviourLearningSystem = new BehaviorLearningSystem();
                tabpfnVocabularySystem = new TabPFNVocabularySystem();
                
                // Create initial training data
                generateInitialTrainingData();
                
                console.log(`âœ… AI/ML Systems initialized successfully with ${tabpfnVocabularySystem.getTotalWordCount()} vocabulary words!`);
                return true;
            } catch (error) {
                console.error('âŒ AI Systems initialization failed:', error);
                return false;
            }
        }

        function generateInitialTrainingData() {
            // Generate synthetic training data for neural networks
            const trainingData = [];
            
            for (let i = 0; i < 50; i++) {
                // Create diverse training scenarios
                const mockBacteria = {
                    biological_state: { age: Math.random() * 100, size: Math.random() * 5 },
                    consciousness_level: Math.random() * 20,
                    personality_traits: { optimism: Math.random(), sociability: Math.random() },
                    vocabulary: { size: Math.random() * 30 },
                    hunger: Math.random(),
                    energy: Math.random(),
                    conversation_history: Array(Math.floor(Math.random() * 10)),
                    memory_bank: Array(Math.floor(Math.random() * 20)),
                    x: Math.random() * 500,
                    y: Math.random() * 300
                };
                
                const inputs = globalNeuralNetwork.prepareBacteriaInputs(mockBacteria);
                
                // Generate expected outputs based on scenario
                const expectedOutputs = generateExpectedBehavior(mockBacteria);
                
                trainingData.push({ inputs, expectedOutputs });
            }
            
            // Train the global network
            globalNeuralNetwork.train(trainingData, 15);
            console.log(`ğŸ“ Generated and trained on ${trainingData.length} scenarios`);
        }

        function generateExpectedBehavior(bacteria) {
            // Define expected behavior based on bacteria state
            let moveX = 0, moveY = 0, moveZ = 0;
            let seekFood = 0, socialize = 0, reproduce = 0;
            
            // High hunger -> seek food
            if (bacteria.hunger > 0.7) {
                seekFood = 0.9;
                moveX = (Math.random() - 0.5) * 0.8; // Active movement
                moveY = (Math.random() - 0.5) * 0.8;
            }
            
            // High sociability -> socialize
            if (bacteria.personality_traits.sociability > 0.6) {
                socialize = 0.8;
            }
            
            // High consciousness + size -> reproduce
            if (bacteria.consciousness_level > 5 && bacteria.biological_state.size > 2) {
                reproduce = 0.7;
            }
            
            // Default exploration
            if (seekFood < 0.3 && socialize < 0.3 && reproduce < 0.3) {
                moveX = (Math.random() - 0.5) * 0.6;
                moveY = (Math.random() - 0.5) * 0.6;
                moveZ = (Math.random() - 0.5) * 0.4;
            }
            
            return [
                moveX * 0.5 + 0.5, // Normalize to 0-1
                moveY * 0.5 + 0.5,
                moveZ * 0.5 + 0.5,
                seekFood,
                socialize,
                reproduce
            ];
        }
        
        // Legacy function wrappers for backward compatibility
        function startSimulation() {
            if (uiManager) uiManager.startSimulation();
        }

        function pauseSimulation() {
            if (uiManager) uiManager.pauseSimulation();
        }

        function simulationStep() {
            simulationDay++;
            simulationTimeSpan.textContent = `SimÃ¼lasyon ZamanÄ±: ${simulationDay} gÃ¼n`;
            
            // v829: Auto-generate food for sustained ecosystem
            if (Math.random() < 0.7) { // 70% chance to add food each step
                const x = Math.random() * 460 + 20;
                const y = Math.random() * 260 + 20;
                addFood(x, y);
            }
            
            bacteriaPopulation.forEach(bacteria => {
                if (!bacteria || typeof bacteria.updateDaily !== 'function') return;
                
                try {
                    bacteria.updateDaily();
                    bacteria.move(); // Add movement to simulation steps for more dynamic behavior
                    
                    // v829: More frequent reproduction checks for dynamic population
                    if (simulationDay % 2 === 0 && typeof bacteria.checkForReproduction === 'function') { // Check every 2 days instead of 3
                        bacteria.checkForReproduction();
                    }
                } catch (error) {
                    console.error(`Error in simulation step for bacteria ${bacteria.id}:`, error);
                }
            });
            
            renderBacteria();
            if (selectedBacteria) {
                updateBacteriaDetails(selectedBacteria);
            }
        }

        function resetSimulation() {
            pauseSimulation();
            simulationDay = 0;
            simulationTimeSpan.textContent = 'SimÃ¼lasyon ZamanÄ±: 0 gÃ¼n';
            bacteriaPopulation = [];
            bacteriaList = []; // v826 compatibility
            foodParticles = [];
            selectedBacteria = null;
            
            startSimulationBtn.textContent = 'SimÃ¼lasyonu BaÅŸlat';
            nextStepBtn.disabled = false;
            
            bacteriaDetailsDiv.classList.add('hidden');
            chatInfoDiv.textContent = 'Sohbet modunu seÃ§in.';
            chatMessagesDiv.innerHTML = '';
            chatInput.disabled = true;
            sendMessageBtn.disabled = true;
            chatMode = 'individual';
            updateChatModeButtons();
            
            // Close all individual chat windows
            openChatWindows.forEach((modal, bacteriaId) => {
                document.body.removeChild(modal);
            });
            openChatWindows.clear();
            
            initializeBacteria();
        }

        // v826: Add new bacteria to simulation
        function addBacteria() {
            const newBacteria = new BacteriaEntity(bacteriaIdCounter++);
            bacteriaPopulation.push(newBacteria);
            bacteriaList.push(newBacteria); // v826 compatibility
            
            console.log(`â• Added new bacteria: ${newBacteria.name} (Total: ${bacteriaPopulation.length})`);
            renderBacteria();
        }

        // v826: Toggle group chat (improved)
        function toggleGroupChat() {
            if (chatMode === 'group') {
                // Switch to individual mode
                chatMode = 'individual';
                selectedBacteria = null;
                chatInfoDiv.innerHTML = 'ğŸ’¬ Bireysel sohbet modu aktif - Bir bakteriye tÄ±klayÄ±n';
                chatInput.disabled = true;
                sendMessageBtn.disabled = true;
                chatInput.placeholder = "Ã–nce bir bakteri seÃ§in...";
            } else {
                // Switch to group mode
                setupGroupChat();
            }
            updateChatModeButtons();
        }

        function addFood(x, y) {
            const food = new FoodParticle(x, y);
            foodParticles.push(food);
            renderBacteria();
        }

        function initializeBacteria() {
            bacteriaPopulation = [];
            bacteriaList = []; // v826 compatibility
            for (let i = 0; i < CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT; i++) {
                const bacteria = new BacteriaEntity(i + 1);
                bacteriaPopulation.push(bacteria);
                bacteriaList.push(bacteria); // v826 compatibility
            }
            renderBacteria();
        }

        function renderBacteria() {
            const startTime = performance.now(); // v829: Performance tracking
            
            // v829: Use Canvas if available, otherwise fallback to DOM
            if (useCanvas && canvas && ctx) {
                renderWithCanvas();
            } else {
                renderWithDOM();
            }
            
            // v829: Track render performance
            performanceMetrics.renderTime = performance.now() - startTime;
            updatePerformanceMetrics();
        }

        function renderWithCanvas() {
            // Optimized canvas clearing (dirty rect approach for better performance)
            ctx.fillStyle = 'rgba(17, 24, 39, 0.1)'; // Slight trail effect for movement
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Background gradient
            const gradient = ctx.createRadialGradient(canvasWidth/2, canvasHeight/2, 0, canvasWidth/2, canvasHeight/2, Math.max(canvasWidth, canvasHeight)/2);
            gradient.addColorStop(0, 'rgba(30, 30, 30, 0.1)');
            gradient.addColorStop(1, 'rgba(30, 30, 30, 0.3)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Render food particles
            foodParticles.forEach(food => {
                // Food glow effect
                ctx.shadowColor = '#66BB6A';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#66BB6A';
                ctx.beginPath();
                ctx.arc(food.x, food.y, food.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Sort bacteria by Z-depth for proper layering (far to near)
            const sortedBacteria = [...bacteriaPopulation].sort((a, b) => a.z - b.z);
            
            // Render bacteria with pseudo-3D effects
            sortedBacteria.forEach(bacteria => {
                if (!bacteria || typeof bacteria.x !== 'number' || !bacteria.biological_state) return;
                
                // 3D perspective scaling (bacteria further away appear smaller)
                const depthFactor = bacteria.z / 100; // 0.2 to 1.8 range
                const baseSize = Math.max(6, Math.min(25, bacteria.biological_state.size * 2.5));
                const bacteriaSize = baseSize * depthFactor;
                
                // 3D depth effects
                const alpha = Math.max(0.3, Math.min(1.0, depthFactor)); // Transparency based on depth
                const shadowOffset = (1 - depthFactor) * 3; // Shadow offset based on depth
                
                // Draw shadow first (for depth illusion)
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.3})`;
                ctx.beginPath();
                ctx.arc(bacteria.x + shadowOffset, bacteria.y + shadowOffset, bacteriaSize * 0.8, 0, 2 * Math.PI);
                ctx.fill();
                
                // Bacteria glow effect with 3D scaling
                ctx.shadowColor = bacteria.color;
                ctx.shadowBlur = 10 * depthFactor; // Deeper objects have less glow
                ctx.globalAlpha = alpha;
                ctx.fillStyle = bacteria.color;
                ctx.beginPath();
                ctx.arc(bacteria.x, bacteria.y, bacteriaSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0; // Reset alpha
                
                // ID label
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'white';
                ctx.font = '10px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(`#${bacteria.id}`, bacteria.x, bacteria.y - bacteriaSize - 5);
                
                // Consciousness indicator
                const consciousnessColor = bacteria.consciousness_level < 1 ? '#ff4757' :
                                           bacteria.consciousness_level < 5 ? '#f39c12' :
                                           bacteria.consciousness_level < 10 ? '#2ed573' : '#5352ed';
                ctx.fillStyle = consciousnessColor;
                ctx.beginPath();
                ctx.arc(bacteria.x + bacteriaSize - 3, bacteria.y - bacteriaSize + 3, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function renderWithDOM() {
            simulationArea.innerHTML = '';
            
            // Render food particles with improved visibility
            foodParticles.forEach(food => {
                const foodElement = document.createElement('div');
                foodElement.className = 'absolute rounded-full border-2 border-green-400 shadow-lg';
                foodElement.style.width = `${food.size}px`;
                foodElement.style.height = `${food.size}px`;
                foodElement.style.backgroundColor = food.color;
                foodElement.style.left = `${food.x - food.size/2}px`;
                foodElement.style.top = `${food.y - food.size/2}px`;
                foodElement.style.boxShadow = '0 0 8px rgba(144, 238, 144, 0.6)';
                foodElement.title = 'Yemek - Besin deÄŸeri: ' + food.nutrition;
                
                // Add glow effect for better visibility
                const glowElement = document.createElement('div');
                glowElement.className = 'absolute rounded-full';
                glowElement.style.width = `${food.size * 2}px`;
                glowElement.style.height = `${food.size * 2}px`;
                glowElement.style.left = `${food.x - food.size}px`;
                glowElement.style.top = `${food.y - food.size}px`;
                glowElement.style.background = 'radial-gradient(circle, rgba(144, 238, 144, 0.3) 0%, transparent 70%)';
                glowElement.style.pointerEvents = 'none';
                
                simulationArea.appendChild(glowElement);
                simulationArea.appendChild(foodElement);
            });
            
            // Render bacteria with ID labels
            const allBacteria = [...bacteriaPopulation, ...bacteriaList];
            console.log(`ğŸ¨ Rendering ${bacteriaPopulation.length} old + ${bacteriaList.length} new = ${allBacteria.length} total bacteria`);
            allBacteria.forEach(bacteria => {
                const bacteriaSize = Math.max(8, Math.min(25, bacteria.biological_state.size * 3)); // 8-25px limit
                
                // Main bacteria circle
                const bacteriaElement = document.createElement('div');
                bacteriaElement.className = 'bacteria absolute rounded-full border-2 border-white cursor-pointer shadow-lg';
                bacteriaElement.style.width = `${bacteriaSize}px`;
                bacteriaElement.style.height = `${bacteriaSize}px`;
                bacteriaElement.style.backgroundColor = bacteria.color;
                bacteriaElement.style.left = `${bacteria.x}px`;
                bacteriaElement.style.top = `${bacteria.y}px`;
                bacteriaElement.style.boxShadow = `0 0 10px ${bacteria.color}`;
                bacteriaElement.title = `${bacteria.name} - YaÅŸ: ${bacteria.biological_state.age} gÃ¼n, BilinÃ§: ${bacteria.consciousness_level.toFixed(1)}`;
                
                // ID label on top of bacteria
                const idLabel = document.createElement('div');
                idLabel.className = 'absolute text-xs font-bold text-white bg-black bg-opacity-75 rounded px-1';
                idLabel.style.left = `${bacteria.x + bacteriaSize/2 - 8}px`;
                idLabel.style.top = `${bacteria.y - 18}px`;
                idLabel.style.fontSize = '10px';
                idLabel.style.pointerEvents = 'none';
                idLabel.style.zIndex = '10';
                idLabel.textContent = `#${bacteria.id}`;
                
                // Consciousness level indicator (small colored dot)
                const consciousnessIndicator = document.createElement('div');
                consciousnessIndicator.className = 'absolute rounded-full border border-white';
                consciousnessIndicator.style.width = '6px';
                consciousnessIndicator.style.height = '6px';
                consciousnessIndicator.style.left = `${bacteria.x + bacteriaSize - 8}px`;
                consciousnessIndicator.style.top = `${bacteria.y}px`;
                consciousnessIndicator.style.pointerEvents = 'none';
                
                // Color based on consciousness level
                if (bacteria.consciousness_level < 1) {
                    consciousnessIndicator.style.backgroundColor = '#ff4757';
                } else if (bacteria.consciousness_level < 2) {
                    consciousnessIndicator.style.backgroundColor = '#ff6b35';
                } else if (bacteria.consciousness_level < 3) {
                    consciousnessIndicator.style.backgroundColor = '#f39c12';
                } else if (bacteria.consciousness_level < 4) {
                    consciousnessIndicator.style.backgroundColor = '#2ed573';
                } else {
                    consciousnessIndicator.style.backgroundColor = '#5352ed';
                }
                
                // Movement trail effect
                if (bacteria.vx !== 0 || bacteria.vy !== 0) {
                    const trailElement = document.createElement('div');
                    trailElement.className = 'absolute rounded-full';
                    trailElement.style.width = `${bacteriaSize * 1.5}px`;
                    trailElement.style.height = `${bacteriaSize * 1.5}px`;
                    trailElement.style.left = `${bacteria.x - bacteriaSize/4}px`;
                    trailElement.style.top = `${bacteria.y - bacteriaSize/4}px`;
                    trailElement.style.background = `radial-gradient(circle, ${bacteria.color}20 0%, transparent 70%)`;
                    trailElement.style.pointerEvents = 'none';
                    simulationArea.appendChild(trailElement);
                }
                
                bacteriaElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectBacteria(bacteria);
                });
                
                simulationArea.appendChild(bacteriaElement);
                simulationArea.appendChild(idLabel);
                simulationArea.appendChild(consciousnessIndicator);
            });
            
            // Environment effects overlay
            const environmentOverlay = document.createElement('div');
            environmentOverlay.className = 'absolute inset-0 pointer-events-none';
            environmentOverlay.style.background = 'radial-gradient(circle at 50% 50%, rgba(0, 100, 200, 0.05) 0%, transparent 60%)';
            simulationArea.appendChild(environmentOverlay);
            
            // Add molecular dynamics visualization hints
            if (allBacteria.length > 1) {
                allBacteria.forEach((bacteria, i) => {
                    allBacteria.slice(i + 1).forEach(otherBacteria => {
                        const dx = otherBacteria.x - bacteria.x;
                        const dy = otherBacteria.y - bacteria.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Show molecular interaction lines for close bacteria
                        if (distance < 50 && distance > 0) {
                            const interactionLine = document.createElement('div');
                            interactionLine.className = 'absolute pointer-events-none';
                            interactionLine.style.position = 'absolute';
                            interactionLine.style.left = `${bacteria.x}px`;
                            interactionLine.style.top = `${bacteria.y}px`;
                            interactionLine.style.width = `${distance}px`;
                            interactionLine.style.height = '1px';
                            interactionLine.style.background = `linear-gradient(90deg, ${bacteria.color}40, ${otherBacteria.color}40)`;
                            interactionLine.style.transformOrigin = '0 0';
                            interactionLine.style.transform = `rotate(${Math.atan2(dy, dx)}rad)`;
                            interactionLine.style.opacity = '0.6';
                            simulationArea.appendChild(interactionLine);
                        }
                    });
                });
            }
            
        }

        function selectBacteria(bacteria) {
            selectedBacteria = bacteria;
            updateBacteriaDetails(bacteria);
            
            // v826: Open individual chat window modal
            openIndividualChatWindow(bacteria);
        }

        function updateBacteriaDetails(bacteria) {
            bacteriaIdSpan.textContent = bacteria.id;
            bacteriaNameSpan.textContent = bacteria.name;
            bacteriaSizeSpan.textContent = bacteria.biological_state.size.toFixed(2);
            bacteriaAgeSpan.textContent = bacteria.biological_state.age;
            bacteriaGrowthRateSpan.textContent = bacteria.biological_state.growth_rate.toFixed(2);
                                bacteriaConsciousnessSpan.textContent = `${bacteria.consciousness_level.toFixed(1)} âˆ`;
            bacteriaOptimismSpan.textContent = bacteria.personality_traits.optimism.toFixed(2);
            bacteriaSociabilitySpan.textContent = bacteria.personality_traits.sociability.toFixed(2);
            bacteriaLanguageStageSpan.textContent = `${bacteria.language_stage} - ${vocabularyStages[bacteria.language_stage]?.name || 'Bilinmiyor'}`;
            
            const vocabArray = Array.from(bacteria.vocabulary);
                    const displayVocab = vocabArray.slice(0, CONFIG.UI.MAX_VOCABULARY_DISPLAY);
        const remainingCount = vocabArray.length - CONFIG.UI.MAX_VOCABULARY_DISPLAY;
            bacteriaVocabularySpan.textContent = displayVocab.join(', ') + (remainingCount > 0 ? ` (+${remainingCount} daha)` : '');
            
            bacteriaDetailsDiv.classList.remove('hidden');
        }

        function setupChat(bacteria) {
            chatMode = 'individual';
            selectedBacteria = bacteria;
            chatInfoDiv.innerHTML = `<strong>${bacteria.name}</strong> ile sohbet ediyorsunuz.`;
            chatMessagesDiv.innerHTML = '';
            chatInput.disabled = false;
            sendMessageBtn.disabled = false;
            chatInput.placeholder = `${bacteria.name} ile konuÅŸ...`;
            chatInput.focus();
            updateChatModeButtons();
            updateBuildInfo();
            console.log(`ğŸ¯ Individual chat mode with ${bacteria.name}`);
        }

        // v826: Individual Chat Window Modal System
        function openIndividualChatWindow(bacteria) {
            // Check if window already exists
            if (openChatWindows.has(bacteria.id)) {
                // Bring existing window to front
                const existingModal = openChatWindows.get(bacteria.id);
                existingModal.style.zIndex = ++chatWindowZIndex;
                return;
            }
            
            // Create modal backdrop
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.style.zIndex = ++chatWindowZIndex;
            
            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.className = 'bg-gray-800 rounded-lg shadow-xl max-w-md w-full mx-4 max-h-96 flex flex-col';
            modalContent.style.minHeight = '400px';
            
            // Modal header
            const header = document.createElement('div');
            header.className = 'bg-teal-600 text-white px-4 py-3 rounded-t-lg flex justify-between items-center cursor-move';
            header.innerHTML = `
                <div class="flex items-center space-x-2">
                    <div class="w-3 h-3 rounded-full" style="background-color: ${bacteria.color}"></div>
                    <h3 class="font-bold">${bacteria.name} - Chat</h3>
                    <span class="text-xs bg-teal-700 px-2 py-1 rounded">#${bacteria.id}</span>
                </div>
                <div class="flex space-x-2">
                    <button class="text-white hover:text-gray-300 minimize-btn">â”€</button>
                    <button class="text-white hover:text-gray-300 close-btn">Ã—</button>
                </div>
            `;
            
            // Chat messages area
            const messagesArea = document.createElement('div');
            messagesArea.className = 'flex-1 p-4 overflow-y-auto bg-gray-700 text-white text-sm';
            messagesArea.style.maxHeight = '250px';
            
            // Load chat history
            loadChatHistory(messagesArea, bacteria);
            
            // Chat input area
            const inputArea = document.createElement('div');
            inputArea.className = 'p-4 bg-gray-600 rounded-b-lg flex space-x-2';
            inputArea.innerHTML = `
                <input type="text" class="flex-1 bg-gray-500 text-white px-3 py-2 rounded focus:outline-none focus:ring-2 focus:ring-teal-500" 
                       placeholder="${bacteria.name} ile konuÅŸ...">
                <button class="bg-teal-500 hover:bg-teal-600 text-white px-4 py-2 rounded font-bold send-btn">GÃ¶nder</button>
            `;
            
            // Assemble modal
            modalContent.appendChild(header);
            modalContent.appendChild(messagesArea);
            modalContent.appendChild(inputArea);
            modal.appendChild(modalContent);
            
            // Event listeners
            const closeBtn = header.querySelector('.close-btn');
            const minimizeBtn = header.querySelector('.minimize-btn');
            const sendBtn = inputArea.querySelector('.send-btn');
            const chatInput = inputArea.querySelector('input');
            
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
                openChatWindows.delete(bacteria.id);
            });
            
            minimizeBtn.addEventListener('click', () => {
                modalContent.style.display = modalContent.style.display === 'none' ? 'flex' : 'none';
            });
            
            sendBtn.addEventListener('click', () => {
                sendIndividualMessage(bacteria, chatInput, messagesArea);
            });
            
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendIndividualMessage(bacteria, chatInput, messagesArea);
                }
            });
            
            // Make draggable
            makeDraggable(modal, header);
            
            // Add to DOM and track
            document.body.appendChild(modal);
            openChatWindows.set(bacteria.id, modal);
            
            // Focus input
            chatInput.focus();
            
            console.log(`ğŸ’¬ Opened individual chat window for ${bacteria.name}`);
        }

        function loadChatHistory(messagesArea, bacteria) {
            // Load user conversations with this bacteria
            if (bacteria.conversation_history && bacteria.conversation_history.length > 0) {
                bacteria.conversation_history.forEach(conv => {
                    addMessageToWindow(messagesArea, conv.user, 'user', 'Sen');
                    addMessageToWindow(messagesArea, conv.bacteria, 'bacteria', bacteria.name);
                });
            }
            
            // Load bacteria-to-bacteria conversations
            if (bacteria.chatHistory && bacteria.chatHistory.length > 0) {
                bacteria.chatHistory.slice(-10).forEach(msg => { // Show last 10 messages
                    if (msg.type === 'sent') {
                        addMessageToWindow(messagesArea, msg.message, 'bacteria', bacteria.name);
                    } else {
                        addMessageToWindow(messagesArea, msg.message, 'bacteria', msg.from);
                    }
                });
            }
            
            // Scroll to bottom
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function addMessageToWindow(messagesArea, message, sender, senderName) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `mb-2 ${sender === 'user' ? 'text-right' : 'text-left'}`;
            
            const bubble = document.createElement('div');
            bubble.className = `inline-block px-3 py-2 rounded-lg max-w-xs ${
                sender === 'user' 
                    ? 'bg-teal-500 text-white' 
                    : 'bg-gray-600 text-gray-100'
            }`;
            
            const nameSpan = document.createElement('div');
            nameSpan.className = 'text-xs opacity-75 mb-1';
            nameSpan.textContent = senderName;
            
            const messageSpan = document.createElement('div');
            messageSpan.textContent = message;
            
            bubble.appendChild(nameSpan);
            bubble.appendChild(messageSpan);
            messageDiv.appendChild(bubble);
            messagesArea.appendChild(messageDiv);
            
            // Auto scroll
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function sendIndividualMessage(bacteria, chatInput, messagesArea) {
            const message = chatInput.value.trim();
            if (!message) return;
            
            // Add user message
            addMessageToWindow(messagesArea, message, 'user', 'Sen');
            
            // Save to bacteria's conversation history
            bacteria.conversation_history = bacteria.conversation_history || [];
            
            // Generate bacteria response
            setTimeout(() => {
                const response = generateBacteriaResponse(bacteria, message, 'user');
                addMessageToWindow(messagesArea, response, 'bacteria', bacteria.name);
                
                // Save conversation
                bacteria.conversation_history.push({ user: message, bacteria: response });
                
                // Learn from user
                const newWords = learnFromUserInput(message, bacteria);
                if (newWords > 0) {
                    bacteria.consciousness_level = bacteria.consciousness_level + 0.02;
                }
                
            }, 500 + Math.random() * 1000);
            
            chatInput.value = '';
        }

        function makeDraggable(modal, header) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = modal.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                
                modal.style.position = 'fixed';
                modal.style.left = initialX + 'px';
                modal.style.top = initialY + 'px';
                modal.classList.remove('items-center', 'justify-center');
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                modal.style.left = (initialX + dx) + 'px';
                modal.style.top = (initialY + dy) + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        function setupGroupChat() {
            chatMode = 'group';
            selectedBacteria = null;
            chatInfoDiv.innerHTML = `<strong>Grup Sohbeti</strong> - TÃ¼m bakterilerle konuÅŸuyorsunuz.`;
            chatMessagesDiv.innerHTML = '';
            chatInput.disabled = false;
            sendMessageBtn.disabled = false;
            chatInput.placeholder = "TÃ¼m bakterilerle konuÅŸ...";
            chatInput.focus();
            updateChatModeButtons();
            updateBuildInfo();
            console.log(`ğŸ‘¥ Group chat mode activated with ${bacteriaPopulation.length} bacteria`);
        }

        function updateChatModeButtons() {
            const individualBtn = document.getElementById('individualChatBtn');
            const groupBtn = document.getElementById('groupChatBtn');
            
            if (chatMode === 'individual') {
                individualBtn.className = 'bg-blue-700 text-white px-3 py-1 rounded text-sm';
                groupBtn.className = 'bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded text-sm transition';
            } else {
                individualBtn.className = 'bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded text-sm transition';
                groupBtn.className = 'bg-green-700 text-white px-3 py-1 rounded text-sm';
            }
        }

        // Event listeners
        startSimulationBtn.addEventListener('click', startSimulation);
        nextStepBtn.addEventListener('click', simulationStep);
        resetSimulationBtn.addEventListener('click', resetSimulation);

        // Add food on click
        simulationArea.addEventListener('click', (e) => {
            const rect = simulationArea.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            addFood(x, y);
        });

        sendMessageBtn.addEventListener('click', () => {
            const message = chatInput.value.trim();
            if (message && (selectedBacteria || chatMode === 'group')) {
                sendMessageToBacteria(message);
                chatInput.value = '';
            }
        });

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !chatInput.disabled) {
                sendMessageBtn.click();
            }
        });

        // Chat mode event listeners
        document.getElementById('individualChatBtn').addEventListener('click', () => {
            if (selectedBacteria) {
                // v826: Use new modal system instead of old chat
                openIndividualChatWindow(selectedBacteria);
            } else {
                alert('âš ï¸ Ã–nce bir bakteri seÃ§in. Bir bakteriye tÄ±klayarak seÃ§ebilirsiniz.');
            }
        });

        document.getElementById('groupChatBtn').addEventListener('click', () => {
            setupGroupChat();
        });

        document.getElementById('startBacteriaConversationBtn').addEventListener('click', () => {
            // v826: Manual trigger for natural conversation
            if (bacteriaPopulation.length >= 2) {
                const socialBacteria = bacteriaPopulation.filter(b => b.personality_traits.sociability > 0.3);
                if (socialBacteria.length >= 2) {
                    startNaturalBacteriaConversation(socialBacteria);
                } else {
                    console.log('âš ï¸ Not enough social bacteria for conversation');
                }
            } else {
                console.log('âš ï¸ Need at least 2 bacteria for conversation');
            }
        });

        // v829: High-Frequency Auto Bacteria Conversations for Dynamic Experience
        setInterval(() => {
            if (bacteriaPopulation.length >= 2) {
                // Very high frequency natural conversations for dynamic experience
                const socialBacteria = bacteriaPopulation.filter(b => b.personality_traits.sociability > 0.3);
                
                if (socialBacteria.length >= 2 && Math.random() < 0.9) { // 90% chance for more interactions
                    startNaturalBacteriaConversation(socialBacteria);
                }
                
                // More frequent learning sessions
                if (bacteriaPopulation.length >= 3 && Math.random() < 0.4) { // 40% chance
                    startGroupLearningSession();
                }
            }
        }, 2500); // Every 2.5 seconds - even more frequent interactions

        // Initialize ML System
        async function initializeMLSystem() {
            console.log('ğŸ§  Initializing TensorFlow.js ML System...');
            
            try {
                // Initialize tokenizer
                initializeTokenizer();
                
                // Create models
                console.log('ğŸ”§ Creating neural network models...');
                wordEmbeddingModel = await createWordEmbeddingModel();
                behaviorPredictionModel = await createBehaviorModel();
                
                isMLReady = true;
                console.log('âœ… ML System ready! TensorFlow.js version:', tf.version.tfjs);
                updateBuildInfo();
                
            } catch (error) {
                console.error('âŒ ML System initialization failed:', error);
                isMLReady = false;
            }
        }

        // Memory Management System for better performance
        class MemoryManager {
            static cleanup() {
                // Remove invalid bacteria references
                bacteriaList = bacteriaList.filter(bacteria => 
                    bacteria && bacteria.x !== undefined && bacteria.biological_state
                );
                
                // Cleanup old food particles
                if (foodParticles.length > 20) {
                    foodParticles.splice(0, foodParticles.length - 15);
                }
                
                // Compact bacteria memory arrays
                bacteriaList.forEach(bacteria => {
                    if (bacteria.memory_bank && bacteria.memory_bank.length > 20) {
                        bacteria.memory_bank = bacteria.memory_bank.slice(-15);
                    }
                    if (bacteria.consciousness_history && bacteria.consciousness_history.length > 50) {
                        bacteria.consciousness_history = bacteria.consciousness_history.slice(-30);
                    }
                });

                console.log('ğŸ§¹ Memory cleanup completed');
            }

            static getMemoryUsage() {
                if (performance.memory) {
                    return {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                    };
                }
                return { used: 0, total: 0, limit: 0 };
            }
        }

        // Enhanced Data Export Function with memory info
        function exportEnhancedData() {
            const memoryInfo = MemoryManager.getMemoryUsage();
            const exportData = {
                version: VERSION,
                timestamp: new Date().toISOString(),
                simulation: {
                    day: simulationManager ? simulationManager.simulationDay : 0,
                    totalBacteria: bacteriaList.length,
                    running: simulationRunning
                },
                performance: {
                    fps: performanceMetrics.fps,
                    renderTime: performanceMetrics.renderTime,
                    memoryUsage: performanceMetrics.totalMemoryUsage,
                    systemMemory: memoryInfo
                },
                bacteria: bacteriaList.map(b => ({
                    id: b.id,
                    name: b.name,
                    consciousness: b.consciousness_level,
                    age: b.biological_state.age,
                    size: b.biological_state.size,
                    vocabularySize: b.vocabulary.size,
                    position: { x: b.x, y: b.y },
                    personality: b.personality_traits
                })),
                summary: {
                    averageConsciousness: bacteriaList.reduce((sum, b) => sum + b.consciousness_level, 0) / bacteriaList.length,
                    maxConsciousness: Math.max(...bacteriaList.map(b => b.consciousness_level)),
                    totalVocabulary: new Set(bacteriaList.flatMap(b => Array.from(b.vocabulary))).size
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `neomag_export_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('ğŸ“Š Enhanced data export completed:', exportData.summary);
        }

        // Initialize everything with modern architecture
        async function initialize() {
            console.log(`ğŸš€ Starting NeoMag ${VERSION} with Advanced AI/ML`);
            
            // Initialize AI systems first
            const aiSuccess = initializeAISystems();
            if (!aiSuccess) {
                console.warn('âš ï¸ AI systems failed to initialize, continuing without AI');
            }
            
            // Initialize UI Manager for event delegation
            uiManager = new UIManager(simulationManager);
            updateBuildInfo();
            initializeBacteria();
            initializeCanvas(); // v829: Initialize canvas support
            await initializeMLSystem();
            
            // Show feature list
            console.log('ğŸ“‹ Available Features:');
            FEATURES.forEach((feature, i) => {
                console.log(`   ${i+1}. ${feature}`);
            });
            
            // Update version to show AI integration
            const versionDisplay = document.querySelector('h1');
            if (versionDisplay && aiSuccess) {
                versionDisplay.innerHTML = 'ğŸ§¬ NeoMag v8.5.0 - AI/ML Bakteriler';
            }
        }

        // Initialize simulation (v826)
        async function initializeV826() {
            console.log('ğŸš€ Initializing NeoMag v8.2.6...');
            
            // Initialize ML models first (placeholder)
            console.log('ğŸ§  ML models loading skipped for now');
            
            // Auto-restore from database or create new bacteria
            await autoRestoreFromDatabase();
            
            updateBuildInfo();
            renderBacteria();
            
            console.log('âœ… Initialization complete');
        }

        // Start v826 initialization after main initialization
        setTimeout(initializeV826, 1000);

        // v825: Database Control Functions
        async function exportCSV() {
            console.log('ğŸ“Š Exporting CSV for TabPFN analysis...');
            await persistentDB.exportToCSV();
        }

        async function saveAllNow() {
            console.log('ğŸ’¾ Manual save triggered...');
            for (const bacteria of bacteriaList) {
                await bacteria.saveToDatabase();
            }
            
            // Save simulation state
            await persistentDB.saveSimulationState(
                simulationDay, 
                bacteriaList, 
                performanceMetrics
            );
            
            console.log('âœ… All bacteria and simulation state saved');
        }

        async function loadFromDatabase() {
            console.log('ğŸ“– Loading bacteria from database...');
            const savedBacteria = await persistentDB.loadBacteria();
            
            if (savedBacteria.length === 0) {
                console.log('âš ï¸ No saved bacteria found');
                return;
            }
            
            // Clear current bacteria
            bacteriaList = [];
            
            // Restore bacteria from database
            let maxId = 0;
            savedBacteria.forEach(bacteriaData => {
                const bacteria = new BacteriaEntity(bacteriaData.id, bacteriaData.name, bacteriaData);
                bacteriaList.push(bacteria);
                maxId = Math.max(maxId, bacteriaData.id);
            });
            
            // Update ID counter
            bacteriaIdCounter = maxId + 1;
            
            console.log(`ğŸ“– Restored ${savedBacteria.length} bacteria from database`);
            updateBuildInfo();
            renderBacteria();
        }

        async function clearDatabase() {
            if (confirm('âš ï¸ This will permanently delete all saved bacteria data. Continue?')) {
                console.log('ğŸ—‘ï¸ Clearing database...');
                await persistentDB.clearDatabase();
                console.log('âœ… Database cleared');
            }
        }

        async function showDatabaseStats() {
            const savedBacteria = await persistentDB.loadBacteria();
            
            if (savedBacteria.length === 0) {
                alert('ğŸ“Š Database Stats:\n\nNo bacteria data found');
                return;
            }
            
            const totalBacteria = savedBacteria.length;
            const avgConsciousness = savedBacteria.reduce((sum, b) => sum + b.consciousness_level, 0) / totalBacteria;
            const maxConsciousness = Math.max(...savedBacteria.map(b => b.consciousness_level));
            const totalVocab = new Set(savedBacteria.flatMap(b => b.vocabulary)).size;
            const avgAge = savedBacteria.reduce((sum, b) => sum + b.biological_state.age, 0) / totalBacteria;
            const maxRuntimeDays = Math.max(...savedBacteria.map(b => b.total_runtime_days || 0));
            
            const stats = `ğŸ“Š Database Stats:
            
Total Bacteria: ${totalBacteria}
Average Consciousness: ${avgConsciousness.toFixed(2)}
Maximum Consciousness: ${maxConsciousness.toFixed(2)}
Total Unique Vocabulary: ${totalVocab} words
Average Age: ${avgAge.toFixed(1)} days
Maximum Runtime: ${maxRuntimeDays} days

Consciousness Levels:
â€¢ 0-1: ${savedBacteria.filter(b => b.consciousness_level < 1).length}
â€¢ 1-5: ${savedBacteria.filter(b => b.consciousness_level >= 1 && b.consciousness_level < 5).length}
â€¢ 5-10: ${savedBacteria.filter(b => b.consciousness_level >= 5 && b.consciousness_level < 10).length}
â€¢ 10-50: ${savedBacteria.filter(b => b.consciousness_level >= 10 && b.consciousness_level < 50).length}
â€¢ 50+: ${savedBacteria.filter(b => b.consciousness_level >= 50).length}`;
            
            alert(stats);
        }

        function showLearningStats() {
            const stats = learningEngine.getStats();
            const recentDecisions = learningEngine.decisionLog.slice(-10);
            
            let recentSummary = 'ğŸ“Š Recent AI Decisions:\n';
            recentDecisions.forEach((log, i) => {
                const outcome = log.outcome || 'pending';
                const emoji = outcome === 'success' ? 'âœ…' : outcome === 'failure' ? 'âŒ' : 'â³';
                recentSummary += `${emoji} ${log.source}: ${log.output} (${(log.confidence * 100).toFixed(0)}%)\n`;
            });
            
            const errorPatterns = Array.from(learningEngine.errorPatterns.entries()).slice(0, 3);
            let errorSummary = '\nğŸš¨ Top Error Patterns:\n';
            errorPatterns.forEach(([pattern, data]) => {
                const p = JSON.parse(pattern);
                errorSummary += `â€¢ ${p.source} confidence ${p.confidenceRange}: ${data.count} failures\n`;
            });
            
            const fullStats = `ğŸ§  AI Self-Learning Stats:

ğŸ“ˆ Total Decisions: ${stats.totalDecisions}
ğŸ¯ Recent Success Rate: ${(stats.recentSuccessRate * 100).toFixed(1)}%
âŒ Error Patterns Detected: ${stats.errorPatterns}
âœ… Success Patterns Learned: ${stats.successPatterns}

${recentSummary}${errorSummary}

ğŸ”¬ The AI is continuously learning from decision outcomes to improve future predictions and avoid repeated mistakes.`;
            
            alert(fullStats);
        }

        // v825: Auto-restore on page load
        async function autoRestoreFromDatabase() {
            console.log('ğŸ”„ Checking for saved bacteria to restore...');
            
            // Wait for database to be ready
            const maxWait = 5000; // 5 seconds
            const startTime = Date.now();
            
            while (!persistentDB.isReady && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (!persistentDB.isReady) {
                console.log('âš ï¸ Database not ready, skipping auto-restore');
                return;
            }
            
            const savedBacteria = await persistentDB.loadBacteria();
            
            if (savedBacteria.length > 0) {
                console.log(`ğŸ”„ Auto-restoring ${savedBacteria.length} bacteria from previous session...`);
                
                // Clear current bacteria
                bacteriaList = [];
                
                // Restore bacteria
                let maxId = 0;
                savedBacteria.forEach(bacteriaData => {
                    const bacteria = new BacteriaEntity(bacteriaData.id, bacteriaData.name, bacteriaData);
                    bacteriaList.push(bacteria);
                    maxId = Math.max(maxId, bacteriaData.id);
                });
                
                bacteriaIdCounter = maxId + 1;
                
                console.log('âœ… Auto-restore complete');
                updateBuildInfo();
                renderBacteria();
            } else {
                console.log('ğŸ“ No saved bacteria found, starting fresh simulation');
                
                // Create initial bacteria if none exist
                if (bacteriaList.length === 0) {
                    initializeBacteria();
                }
            }
        }

        // Global Event Delegation System (Modern Approach)
        function initializeEventDelegation() {
            document.addEventListener('click', function(event) {
                const button = event.target.closest('button');
                if (!button || !button.dataset.action) return;
                
                const action = button.dataset.action;
                console.log(`ğŸ¯ Action triggered: ${action}`);
                
                // Ana kontrol paneli
                if (action === 'start-simulation') {
                    if (simulationManager.isRunning) {
                        simulationManager.pause();
                        button.textContent = 'â–¶ï¸ BaÅŸlat';
                    } else {
                        simulationManager.start();
                        button.textContent = 'â¸ï¸ Duraklat';
                    }
                }
                else if (action === 'pause-simulation') simulationManager.pause();
                else if (action === 'reset-simulation') {
                    simulationManager.reset();
                }
                else if (action === 'add-bacteria') addBacteria();
                else if (action === 'toggle-group-chat') toggleGroupChat();
                
                // Database operations
                else if (action === 'export-csv') exportCSV();
                else if (action === 'export-json') exportEnhancedData();
                else if (action === 'save-all') saveAllNow();
                else if (action === 'load-saved') loadFromDatabase();
                else if (action === 'clear-db') clearDatabase();
                else if (action === 'show-db-stats') showDatabaseStats();
                else if (action === 'show-learning-stats') showLearningStats();
            });
        }

        // ğŸš€ MAIN INITIALIZATION - EVENT DRIVEN
        async function mainInitialize() {
            console.log('ğŸš€ NeoMag v8.5.0 Event-Driven Initialization...');
            
            // 1. Setup event listeners first
            initializeEventListeners();
            initializeEventDelegation();
            
            // 2. Basic setup
            updateBuildInfo(); // Initial state
            initializeCanvasSystem();
            initializeBacteriaPopulation();
            
            // 3. Initialize core systems (PROMISE-BASED ORDER)
            try {
                // DB first (others depend on it)
                persistentDB = new PersistentBacteriaDB();
                await persistentDB.initialize();
                console.log('âœ… Database initialization complete');
                
                // AI systems parallel (they don't depend on each other)
                const tabPFNAdapter = new TabPFNAdapter();
                const realAI = new RealAITrainingSystem();
                
                await Promise.all([
                    tabPFNAdapter.initialize(),
                    realAI.initialize()
                ]);
                console.log('âœ… AI systems initialization complete');
                
                // Emit final event
                appEvents.emit('all:systems:ready');
                
                // 4. Load saved data if available
                await autoRestoreFromDatabase();
                
                // 5. Start simulation manager
                simulationManager = new SimulationManager();
                
                console.log('ğŸ‰ Event-driven initialization complete!');
                
            } catch (error) {
                console.error('âŒ Initialization error:', error);
                updateBuildInfo(); // Show error state
            }
        }

        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', mainInitialize);

    </script>
</body>
</html>