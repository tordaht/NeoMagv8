<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mnBac v9.6.2 - System Readiness & GitHub Pages Fix</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Note: Tailwind CDN is used for rapid prototyping. For production, use PostCSS or CLI installation -->
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <style>
        /* CSS Variables for better maintainability */
        :root {
            --color-primary: #3D5AFE;
            --color-secondary: #00C853;
            --color-accent: #FFC107;
            --color-bg-dark: #121212;
            --color-bg-panel: #1E1E1E;
            --color-text-light: #E0E0E0;
            --color-text-muted: #B0B0B0;
            --color-border: #333;
            --radius-lg: 12px;
            --radius-sm: 6px;
            --transition-fast: 0.2s ease;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .bacteria {
            transition: all 0.5s ease-in-out;
            cursor: pointer;
        }
        .bacteria:hover {
            transform: scale(1.1);
        }
        .chat-bubble {
            max-width: 70%;
            word-wrap: break-word;
        }
        .chat-bubble-user {
            background-color: #3b82f6; /* blue-500 */
            color: white;
        }
        .chat-bubble-bacteria {
            background-color: #e5e7eb; /* gray-200 */
            color: #1f2937; /* gray-800 */
        }
        .smooth-scroll {
            scroll-behavior: smooth;
        }
        /* Custom scrollbar for chat */
        #chatMessages::-webkit-scrollbar {
            width: 8px;
        }
        #chatMessages::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #chatMessages::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        #chatMessages::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Loading spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 5px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
            
        /* üé≠ TabPFN Speech Bubble Animations */
        @keyframes speechBubbleAnim {
            0% { 
                transform: scale(0.8) translateY(10px); 
                opacity: 0; 
            }
            15% { 
                transform: scale(1.05) translateY(-5px); 
                opacity: 1; 
            }
            20% { 
                transform: scale(1) translateY(0px); 
                opacity: 1; 
            }
            80% { 
                transform: scale(1) translateY(0px); 
                opacity: 1; 
            }
            100% { 
                transform: scale(0.9) translateY(-10px); 
                opacity: 0; 
            }
        }

        /* üí¨ SPEECH BUBBLE SYSTEM - Modern Design */
        .speech-bubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 16px;
            border-radius: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            min-width: 150px;
            max-width: 300px;
            word-wrap: break-word;
            opacity: 0.95;
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .speech-bubble:hover {
            transform: scale(1.02) translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.4);
            opacity: 1;
        }

        .speech-content {
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
            line-height: 1.4;
        }

        .speech-content strong {
            color: #FFD700;
            font-weight: 600;
            font-size: 13px;
        }

        /* Speech bubble arrow pointing down */
        .speech-arrow {
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-top: 12px solid #667eea;
            filter: drop-shadow(0 3px 6px rgba(0,0,0,0.2));
        }

        /* Context-specific bubble styles */
        .speech-food_seeking {
            border-left: 4px solid #FFD700;
        }

        .speech-social_interaction {
            border-left: 4px solid #00FFFF;
        }

        .speech-philosophical {
            border-left: 4px solid #FF4500;
            font-style: italic;
        }

        .speech-learning {
            border-left: 4px solid #32CD32;
        }

        </style>
    </head>
<body class="bg-gray-900 text-gray-100 flex flex-col min-h-screen">

    <!-- Header -->
    <header class="bg-gray-800 shadow-lg p-4 sticky top-0 z-50">
        <div class="flex justify-between items-center">
            <h1 class="text-2xl font-bold text-teal-400">üß¨ mnBac v9.6.2 - System Readiness & GitHub Pages Fix</h1>
            <div class="flex gap-2 text-xs">
                <div class="bg-green-600 text-white px-2 py-1 rounded" id="fpsDisplay">FPS: --</div>
                <div class="bg-blue-600 text-white px-2 py-1 rounded" id="bacteriaCount">Bakteri: 0</div>
                <div class="bg-purple-600 text-white px-2 py-1 rounded" id="dayDisplay">G√ºn: 0</div>
            </div>
        </div>
        <div class="text-center text-xs text-teal-300 mt-1">
            üì± Mobile Ready TabPFN | üéØ Smart Word Usage | ‚ö° < 1 Second Predictions | üß† Single HTML Solution
        </div>
        <div id="buildInfo" class="text-center text-xs text-gray-400 mt-1">
            Build: Loading...
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow container mx-auto p-2 sm:p-4 grid grid-cols-1 lg:grid-cols-3 gap-4">
        
        <!-- Sol Panel Sim√ºlasyon ve Detaylar -->
        <div class="lg:col-span-2 bg-gray-800 p-4 rounded-lg shadow-xl flex flex-col">
            <h2 class="text-xl font-semibold mb-3 text-teal-300 border-b border-gray-700 pb-2">Sim√ºlasyon Alanƒ±</h2>
            <div id="simulationArea" class="bg-gray-700 rounded-md p-4 relative h-[400px] w-full overflow-hidden cursor-crosshair border-2 border-gray-600">
                <!-- Canvas akan buraya eklendi -->
                <canvas id="simCanvas" class="w-full h-full absolute top-0 left-0"></canvas>
                <div class="absolute top-2 left-2 text-xs text-teal-300 bg-gray-800 bg-opacity-75 px-2 py-1 rounded">
                    üçé Yemek eklemek i√ßin tƒ±klayƒ±n | üß¨ Bakteriler i√ßin tƒ±klayƒ±n
                </div>
                <div class="absolute top-2 right-2 text-xs text-blue-300 bg-gray-800 bg-opacity-75 px-2 py-1 rounded">
                    ‚öóÔ∏è Molek√ºler Dinamik Sim√ºlasyonu | FPS: <span id="canvasFpsDisplay">--</span>
                </div>
            </div>
            <div class="mt-4 p-3 bg-gray-750 rounded-md">
                <h3 class="text-lg font-semibold mb-2 text-teal-300">Kontrol Paneli</h3>
                <div class="flex space-x-2">
                    <!-- ESKƒ∞ BUTTONLAR KALDIRILDI - YENƒ∞ EVENT DElEGATƒ∞ON Sƒ∞STEMƒ∞ KULLANILIYOR -->
                    <p class="text-sm text-gray-400">Kontrol butonlarƒ± a≈üaƒüƒ±da ‚¨áÔ∏è</p>
                </div>
                <p id="simulationTime" class="mt-2 text-sm text-gray-400">Sim√ºlasyon Zamanƒ±: 0 g√ºn</p>
            </div>
            <div id="bacteriaDetails" class="mt-4 p-3 bg-gray-750 rounded-md hidden">
                <h3 class="text-lg font-semibold mb-2 text-teal-300" id="detailsHeader">Bakteri Detaylarƒ±</h3>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 text-sm">
                    <p><strong>ID:</strong> <span id="bacteriaId" class="text-gray-300"></span></p>
                    <p><strong>ƒ∞sim:</strong> <span id="bacteriaName" class="text-gray-300"></span></p>
                    <p><strong>Boyut:</strong> <span id="bacteriaSize" class="text-gray-300"></span> ¬µm</p>
                    <p><strong>Ya≈ü:</strong> <span id="bacteriaAge" class="text-gray-300"></span> g√ºn</p>
                    <p><strong>B√ºy√ºme Hƒ±zƒ±:</strong> <span id="bacteriaGrowthRate" class="text-gray-300"></span></p>
                    <p><strong>Bilin√ß Seviyesi:</strong> <span id="bacteriaConsciousness" class="text-gray-300"></span></p>
                    <p><strong>Ki≈üilik (ƒ∞yimserlik):</strong> <span id="bacteriaOptimism" class="text-gray-300"></span></p>
                    <p><strong>Ki≈üilik (Sosyallik):</strong> <span id="bacteriaSociability" class="text-gray-300"></span></p>
                    <p><strong>Dil A≈üamasƒ±:</strong> <span id="bacteriaLanguageStage" class="text-gray-300"></span></p>
                    <p><strong>Kelime Haznesi:</strong> <span id="bacteriaVocabulary" class="text-gray-300 break-all"></span></p>
                </div>
            </div>
        </div>

        <!-- Saƒü Panel Sohbet -->
        <div class="bg-gray-800 p-4 rounded-lg shadow-xl flex flex-col max-h-[80vh] lg:max-h-full">
            <h2 class="text-xl font-semibold mb-3 text-teal-300 border-b border-gray-700 pb-2">Bakteri Sohbet Merkezi</h2>
            
            <!-- Chat Mode Selector -->
            <div class="mb-3 flex space-x-2">
                <button id="individualChatBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm transition">Tekil Sohbet</button>
                <button id="groupChatBtn" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm transition">Grup Sohbeti</button>
                <button id="startBacteriaConversationBtn" class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded text-sm transition">Bakteriler Konu≈üsun</button>
            </div>
            
            <div id="chatInfo" class="mb-2 text-sm text-gray-400">Sohbet modunu se√ßin.</div>
            <div id="chatMessages" class="flex-grow bg-gray-700 rounded-md p-3 overflow-y-auto mb-3 smooth-scroll space-y-2 h-64 min-h-[16rem] max-h-[20rem]" style="display: flex; flex-direction: column-reverse;">
                <!-- Sohbet mesajlarƒ± buraya eklenecek -->
            </div>
            <div id="chatLoadingIndicator" class="hidden text-center py-2">
                <div class="loader"></div>
                <p class="text-sm text-gray-400">Bakteri d√º≈ü√ºn√ºyor...</p>
            </div>
            <div class="flex">
                <input type="text" id="chatInput" class="flex-grow bg-gray-600 text-gray-200 border border-gray-500 rounded-l-lg p-2 focus:ring-teal-500 focus:border-teal-500 outline-none" placeholder="Mesajƒ±nƒ±zƒ± yazƒ±n..." disabled>
                <button id="sendMessageBtn" class="bg-teal-500 hover:bg-teal-600 text-white font-bold p-2 rounded-r-lg transition duration-150 ease-in-out" disabled>G√∂nder</button>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-gray-800 text-center p-3 text-sm text-gray-500">
        NeoMag v8.0.0 - Sim√ºlasyon Aray√ºz√º Prototipi
    </footer>

    <!-- Controls -->
    <div class="bg-gray-800 p-4 rounded-lg mb-4">
        <div class="flex flex-wrap gap-2 mb-4">
            <button id="startSimulationBtn" data-action="start-simulation" class="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-lg text-lg font-bold">
                ‚ñ∂Ô∏è Sim√ºlasyonu Ba≈ülat
            </button>
            <button data-action="pause-simulation" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded">
                ‚è∏Ô∏è Duraklat
            </button>
            <button data-action="reset-simulation" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">
                üîÑ Reset
            </button>
            <button data-action="add-bacteria" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">
                ‚ûï Bakteri Ekle
            </button>
            <button data-action="toggle-group-chat" class="bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded">
                üí¨ Grup Chat
            </button>
        </div>
        
        <!-- v825: Database Controls -->
        <div class="flex flex-wrap gap-2 mb-2">
            <button data-action="export-csv" class="bg-cyan-600 hover:bg-cyan-700 px-3 py-1 rounded text-sm">
                üìä CSV Export
            </button>
            <button data-action="export-json" class="bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded text-sm">
                üìà JSON Export
            </button>
            <button data-action="save-all" class="bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded text-sm">
                üíæ Save All
            </button>
            <button data-action="load-saved" class="bg-teal-600 hover:bg-teal-700 px-3 py-1 rounded text-sm">
                üìñ Load Saved
            </button>
            <button data-action="clear-db" class="bg-red-500 hover:bg-red-600 px-3 py-1 rounded text-sm">
                üóëÔ∏è Clear DB
            </button>
            <button data-action="show-db-stats" class="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm">
                üìà DB Stats
            </button>
            <button data-action="show-learning-stats" class="bg-purple-600 hover:bg-purple-700 px-3 py-1 rounded text-sm">
                üß† AI Learning
            </button>
            <button data-action="clear-learning-db" class="bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-sm">
                üß¨ Clear Learning
            </button>
            <button data-action="show-diversity-stats" class="bg-teal-600 hover:bg-teal-700 px-3 py-1 rounded text-sm">
                üé≠ Word Diversity
            </button>
            <button data-action="reset-diversity" class="bg-orange-600 hover:bg-orange-700 px-3 py-1 rounded text-sm">
                üîÑ Reset Diversity
            </button>
            <button data-action="show-language-stats" class="bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded text-sm">
                üß† Language Stats
            </button>
            <button data-action="peer-dialogue" class="bg-pink-600 hover:bg-pink-700 px-3 py-1 rounded text-sm">
                üó£Ô∏è Peer Dialogue
            </button>
            <button data-action="debug-system" class="bg-yellow-600 hover:bg-yellow-700 px-3 py-1 rounded text-sm">
                üîß Debug System
            </button>
            <button data-action="test-conversation" class="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-sm">
                üß™ Test Conversation
            </button>
            <button data-action="force-auto-conversation" class="bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-sm">
                üöÄ FORCE Auto Talk
            </button>
        </div>
        
        <div class="text-xs text-gray-300">
            üßæ Persistent Database: Auto-save every 30s | ‚ôæÔ∏è Unlimited Consciousness | üìä TabPFN-ready CSV | üé® Canvas Rendering
        </div>
    </div>

    <script>
        // DOM Elements
        const simulationArea = document.getElementById('simulationArea');
        const bacteriaDetailsDiv = document.getElementById('bacteriaDetails');
        const detailsHeader = document.getElementById('detailsHeader');
        const bacteriaIdSpan = document.getElementById('bacteriaId');
        const bacteriaNameSpan = document.getElementById('bacteriaName');
        const bacteriaSizeSpan = document.getElementById('bacteriaSize');
        const bacteriaAgeSpan = document.getElementById('bacteriaAge');
        const bacteriaGrowthRateSpan = document.getElementById('bacteriaGrowthRate');
        const bacteriaConsciousnessSpan = document.getElementById('bacteriaConsciousness');
        const bacteriaOptimismSpan = document.getElementById('bacteriaOptimism');
        const bacteriaSociabilitySpan = document.getElementById('bacteriaSociability');
        const bacteriaLanguageStageSpan = document.getElementById('bacteriaLanguageStage');
        const bacteriaVocabularySpan = document.getElementById('bacteriaVocabulary');

        const chatInfoDiv = document.getElementById('chatInfo');
        const chatMessagesDiv = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const chatLoadingIndicator = document.getElementById('chatLoadingIndicator');

        const startSimulationBtn = document.getElementById('startSimulationBtn');
        const nextStepBtn = document.getElementById('nextStepBtn');
        const resetSimulationBtn = document.getElementById('resetSimulationBtn');
        const simulationTimeSpan = document.getElementById('simulationTime');

        // Simulation State
        let bacteriaPopulation = [];
        let bacteriaList = []; // v826 compatibility
        let bacteriaIdCounter = 1; // v826 ID tracking
        let foodParticles = [];
        let selectedBacteria = null;
        let simulationRunning = false;
        let simulationDay = 0; // Global simulation day counter
        
        // Initialize persistentDB early (null safety)
        var persistentDB = null;
        
        // üéØ EVENT-DRIVEN INITIALIZATION SYSTEM
        class SimpleEventEmitter {
            constructor() {
                this.listeners = {};
            }
            
            on(event, callback) {
                if (!this.listeners[event]) {
                    this.listeners[event] = [];
                }
                this.listeners[event].push(callback);
            }
            
            emit(event, data) {
                if (this.listeners[event]) {
                    this.listeners[event].forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error(`üö® Event callback error for '${event}':`, error);
                        }
                    });
                }
            }
            
            off(event, callback) {
                if (this.listeners[event]) {
                    this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
                }
            }
        }
        
        // Global event system
        const appEvents = new SimpleEventEmitter();
        
        // Initialize AI Learning Engine globally
        let learningEngine = null;
        
        // üß† SELF-IMPROVEMENT SYSTEM
        class SystemLearningEngine {
            constructor() {
                this.decisionLog = [];
                this.errorPatterns = new Map();
                this.successPatterns = new Map();
                this.confidenceThreshold = 0.7;
                this.maxLogSize = 1000;
                this.isLearning = true;
            }
            
            // Log AI decision with context
            logDecision(source, input, output, confidence, context = {}) {
                const logEntry = {
                    timestamp: Date.now(),
                    source, // 'tabpfn', 'tfjs', 'genetic' etc.
                    input: this.sanitizeInput(input),
                    output,
                    confidence,
                    context,
                    outcome: null // Will be filled later
                };
                
                this.decisionLog.push(logEntry);
                
                // Keep log size manageable
                if (this.decisionLog.length > this.maxLogSize) {
                    this.decisionLog.shift();
                }
                
                return logEntry;
            }
            
            // Track the outcome of a decision
            trackOutcome(logEntry, outcome, metrics = {}) {
                if (logEntry && typeof logEntry === 'object') {
                    logEntry.outcome = outcome; // 'success', 'failure', 'neutral'
                    logEntry.metrics = metrics; // age, consciousness change, survival etc.
                    
                    this.updatePatterns(logEntry);
                }
            }
            
            updatePatterns(logEntry) {
                const pattern = this.extractPattern(logEntry);
                const patternKey = JSON.stringify(pattern);
                
                if (logEntry.outcome === 'success') {
                    const current = this.successPatterns.get(patternKey) || { count: 0, confidence: 0 };
                    current.count++;
                    current.confidence = (current.confidence * (current.count - 1) + logEntry.confidence) / current.count;
                    this.successPatterns.set(patternKey, current);
                } else if (logEntry.outcome === 'failure') {
                    const current = this.errorPatterns.get(patternKey) || { count: 0, avgConfidence: 0 };
                    current.count++;
                    current.avgConfidence = (current.avgConfidence * (current.count - 1) + logEntry.confidence) / current.count;
                    this.errorPatterns.set(patternKey, current);
                }
            }
            
            extractPattern(logEntry) {
                // Extract key features that might indicate success/failure patterns
                return {
                    source: logEntry.source,
                    inputType: typeof logEntry.input,
                    confidenceRange: Math.floor(logEntry.confidence * 10) / 10,
                    contextSize: Object.keys(logEntry.context).length
                };
            }
            
            // Check if a decision might be risky based on learned patterns
            assessRisk(source, input, confidence, context = {}) {
                const pattern = {
                    source,
                    inputType: typeof input,
                    confidenceRange: Math.floor(confidence * 10) / 10,
                    contextSize: Object.keys(context).length
                };
                
                const patternKey = JSON.stringify(pattern);
                const errorPattern = this.errorPatterns.get(patternKey);
                
                if (errorPattern && errorPattern.count > 3) {
                    return {
                        isRisky: true,
                        riskLevel: Math.min(errorPattern.count / 10, 1),
                        suggestion: 'Consider using fallback or lower confidence threshold'
                    };
                }
                
                return { isRisky: false, riskLevel: 0 };
            }
            
            sanitizeInput(input) {
                // Prevent circular references and limit size
                try {
                    return JSON.parse(JSON.stringify(input));
                } catch {
                    return { type: typeof input, size: String(input).length };
                }
            }
            
            getStats() {
                return {
                    totalDecisions: this.decisionLog.length,
                    errorPatterns: this.errorPatterns.size,
                    successPatterns: this.successPatterns.size,
                    recentSuccessRate: this.calculateRecentSuccessRate()
                };
            }
            
            calculateRecentSuccessRate() {
                const recent = this.decisionLog.slice(-50); // Last 50 decisions
                const withOutcome = recent.filter(log => log.outcome);
                const successes = withOutcome.filter(log => log.outcome === 'success');
                return withOutcome.length > 0 ? successes.length / withOutcome.length : 0;
            }
        }
        
        // Global learning engine - initialization will be done in mainInitialize()
        // learningEngine is already declared as let above
        
        // üé® CANVAS SYSTEM INITIALIZATION
        function initializeCanvasSystem() {
            const canvas = document.getElementById('simCanvas');
            if (!canvas) {
                console.warn('Canvas element not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            // üéØ STATƒ∞K SIZE ATAMASI KALDIRILDI - resizeCanvas() kullanƒ±lacak
            // canvas.width ve canvas.height artƒ±k dinamik olarak ayarlanƒ±yor
            
            console.log('‚úÖ Canvas system initialized');
        }
        
        // üß¨ BACTERIA POPULATION INITIALIZATION
        function initializeBacteriaPopulation() {
            bacteriaPopulation = [];
            bacteriaList = [];
            
            for (let i = 0; i < CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT; i++) {
                const bacteria = new BacteriaEntity(bacteriaIdCounter, `Bakteri-${bacteriaIdCounter}`);
                bacteriaPopulation.push(bacteria);
                bacteriaList.push(bacteria); // v826 compatibility
                bacteriaIdCounter++;
            }
            
            console.log(`‚úÖ ${CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT} bacteria initialized`);
        }
        // Simulation State Management
        class SimulationManager {
            constructor() {
                this.isRunning = false;
                this.simulationDay = 0;
                this.lastFrameTime = 0;
                this.lastSimulationStep = 0;
                this.frameCount = 0;
                this.fpsDisplay = document.getElementById('fpsDisplay');
                this.gameLoop = this.gameLoop.bind(this);
                
                // üó£Ô∏è Enhanced Peer Communication System
                this.stepCount = 0;
                this.CHAT_INTERVAL = 5; // Her 5 adƒ±mda peer chat
                this.GROUP_CHAT_INTERVAL = 15; // Her 15 adƒ±mda grup sohbeti
                this.speechBubbles = new Map(); // Konu≈üma balonlarƒ± tracking
                
                // Mood-based vocabulary lists
                this.POSITIVE_WORDS = new Set([
                    'iyi', 'mutlu', 'ho≈ü', 'g√ºzel', 'harika', 'm√ºkemmel', 'sevgi', 
                    'dostluk', 'ne≈üe', 'umut', 'ba≈üarƒ±', 'kazan√ß', 'b√ºy√ºme', 'geli≈üim'
                ]);
                
                this.NEGATIVE_WORDS = new Set([
                    'k√∂t√º', '√ºzg√ºn', 'berbat', 'korkun√ß', 'ba≈üarƒ±sƒ±z', 'kayƒ±p', 
                    'aƒürƒ±', 'acƒ±', 'kƒ±rƒ±k', 'yalnƒ±z', 'depresif', 'karanlƒ±k'
                ]);
            }

            gameLoop(timestamp) {
                if (!this.isRunning) return;
                
                // Calculate FPS
                this.frameCount++;
                const deltaTime = timestamp - this.lastFrameTime;
                
                // Update FPS display every second with memory info
                if (deltaTime >= CONFIG.UI.FPS_UPDATE_INTERVAL) {
                    const fps = Math.round(this.frameCount / (deltaTime / 1000));
                    const memInfo = MemoryManager.getMemoryUsage();
                    const displayText = memInfo.used > 0 
                        ? `FPS: ${fps} | MEM: ${memInfo.used}MB`
                        : `FPS: ${fps}`;
                    if (this.fpsDisplay) this.fpsDisplay.textContent = displayText;
                    
                    // Header bilgilerini g√ºncelle (G√ºn ve Bakteri Sayƒ±sƒ±)
                    const dayDisplay = document.getElementById('dayDisplay');
                    const bacteriaCountDisplay = document.getElementById('bacteriaCount');
                    if (dayDisplay) dayDisplay.textContent = `G√ºn: ${this.simulationDay}`;
                    if (bacteriaCountDisplay) bacteriaCountDisplay.textContent = `Bakteri: ${bacteriaPopulation.length}`;
                    
                    this.frameCount = 0;
                    this.lastFrameTime = timestamp;
                }
                
                // Run simulation step at intervals
                if (timestamp - this.lastSimulationStep >= CONFIG.SIMULATION.STEP_INTERVAL) {
                    this.simulationStep();
                    this.lastSimulationStep = timestamp;
                }
                
                // Render (every frame for smooth animation)
                renderBacteria();
                
                requestAnimationFrame(this.gameLoop);
            }

            start() {
                if (this.isRunning) return;
                this.isRunning = true;
                this.lastFrameTime = performance.now();
                this.lastSimulationStep = performance.now();
                requestAnimationFrame(this.gameLoop);
                systemStatus.simulation = true;
                appEvents.emit('simulation:started');
                console.log('üöÄ Simulation started with requestAnimationFrame');
            }

            pause() {
                this.isRunning = false;
                systemStatus.simulation = false;
                appEvents.emit('simulation:paused');
                console.log('‚è∏Ô∏è Simulation paused');
            }

            reset() {
                this.pause();
                this.simulationDay = 0;
                simulationDay = 0;
                bacteriaPopulation = [];
                bacteriaList = [];
                foodParticles = [];
                selectedBacteria = null;
                bacteriaIdCounter = 1;
                console.log('üîÑ Simulation reset completed');
            }

            simulationStep() {
                this.simulationDay++;
                this.stepCount++; // üó£Ô∏è Peer communication tracking
                simulationDay = this.simulationDay; // Global ile senkronize
                simulationTimeSpan.textContent = `Sim√ºlasyon Zamanƒ±: ${this.simulationDay} g√ºn`;
                
                // Auto-generate food for sustained ecosystem
                if (Math.random() < CONFIG.SIMULATION.AUTO_FOOD_GENERATION_CHANCE) {
                    addRandomFood();
                }
                
                // üó£Ô∏è Enhanced Peer Communication System
                if (bacteriaPopulation.length >= 2) {
                    // Regular peer chats
                    if (this.stepCount % this.CHAT_INTERVAL === 0) {
                        this.runPeerChats();
                    }
                    
                    // Group therapy sessions
                    if (this.stepCount % this.GROUP_CHAT_INTERVAL === 0) {
                        this.runGroupChat();
                    }
                    
                    // Support for depressed bacteria
                    this.checkDepressedBacteria();
                }
                
                bacteriaPopulation.forEach((bacteria, index) => {
                    if (!bacteria || typeof bacteria.updateDaily !== 'function') {
                        console.warn(`‚ö†Ô∏è Invalid bacteria at index ${index}, removing...`);
                        return;
                    }
                    
                    try {
                        bacteria.updateDaily();
                        bacteria.move();
                        
                        // More frequent reproduction checks for dynamic population
                        if (this.simulationDay % 2 === 0 && typeof bacteria.checkForReproduction === 'function') {
                            bacteria.checkForReproduction();
                        }
                    } catch (error) {
                        console.error(`‚ùå Error in simulation step for bacteria ${bacteria.id}:`, error);
                        // Remove problematic bacteria to prevent further errors
                        bacteriaPopulation.splice(index, 1);
                    }
                });
                
                // Remove dead or invalid bacteria
                bacteriaPopulation = bacteriaPopulation.filter(bacteria => 
                    bacteria && typeof bacteria.x === 'number' && bacteria.biological_state
                );
                
                // Periodic memory cleanup (every 100 simulation steps)
                if (this.simulationDay % 100 === 0) {
                    MemoryManager.cleanup();
                }
                
                if (selectedBacteria) {
                    updateBacteriaDetails(selectedBacteria);
                }
            }
            
            // üó£Ô∏è Enhanced Peer Communication Methods
            
            /**
             * Her bakteri rastgele bir e≈ü se√ßer ve sohbet eder
             */
            async runPeerChats() {
                const socialBacteria = bacteriaPopulation.filter(b => 
                    b.consciousness_level > 0.5 && b.personality_traits.sociability > 0.3
                );
                
                if (socialBacteria.length < 2) return;
                
                // Her bakteriye partner bul ve konu≈ü
                for (const bacteria of socialBacteria) {
                    if (Math.random() < 0.7) { // %70 ≈üans ile konu≈üma
                        const partner = this.getRandomNeighbor(bacteria, socialBacteria);
                        if (partner) {
                            await this.exchangeDialog(bacteria, partner);
                        }
                    }
                }
                
                console.log(`üó£Ô∏è Peer chats completed: ${socialBacteria.length} bacteria participated`);
            }
            
            /**
             * Rastgele kom≈üu bakteri se√ß (proximity veya random)
             */
            getRandomNeighbor(bacteria, pool = bacteriaPopulation) {
                const others = pool.filter(x => x !== bacteria);
                if (others.length === 0) return null;
                
                // Yakƒ±nlƒ±k bazlƒ± se√ßim (%30 ≈üans)
                if (Math.random() < 0.3) {
                    const nearby = others.filter(other => {
                        const dx = bacteria.x - other.x;
                        const dy = bacteria.y - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance < 100; // 100px yakƒ±nlƒ±k
                    });
                    
                    if (nearby.length > 0) {
                        return nearby[Math.floor(Math.random() * nearby.length)];
                    }
                }
                
                // Random se√ßim
                return others[Math.floor(Math.random() * others.length)];
            }
            
            /**
             * ƒ∞ki bakteri arasƒ± √ßift y√∂nl√º diyalog
             */
            async exchangeDialog(bacteriaA, bacteriaB) {
                try {
                    // A'dan B'ye mesaj
                    const contextA = this.getBacteriaContext(bacteriaA);
                    const messageA = await this.generatePeerMessage(bacteriaA, contextA);
                    
                    // B mesajƒ± √∂ƒürenir ve mood etkilenir
                    this.learnFromPeer(bacteriaB, messageA, bacteriaA);
                    this.renderSpeechBubble(bacteriaA, messageA, 3000);
                    
                    // B'den A'ya cevap (kƒ±sa gecikme)
                    setTimeout(async () => {
                        const contextB = this.getBacteriaContext(bacteriaB);
                        const messageB = await this.generatePeerMessage(bacteriaB, contextB);
                        
                        this.learnFromPeer(bacteriaA, messageB, bacteriaB);
                        this.renderSpeechBubble(bacteriaB, messageB, 3000);
                    }, 500 + Math.random() * 1000);
                    
                } catch (error) {
                    console.warn('‚ö†Ô∏è Peer dialog failed:', error);
                }
            }
            
            /**
             * Bakterinin mevcut context'ini belirle
             */
                         getBacteriaContext(bacteria) {
                 // Mood'a g√∂re context se√ß (personality_traits.mood kullan)
                 if (bacteria.personality_traits.mood < 0.3) return 'sad';
                 if (bacteria.personality_traits.mood > 0.7) return 'happy';
                 if (bacteria.energy && bacteria.energy < 0.3) return 'hungry';
                 if (bacteria.biological_state.energy < 0.3) return 'hungry';
                 if (bacteria.consciousness_level > 2.0) return 'philosophical';
                 if (bacteria.personality_traits.sociability > 0.7) return 'social';
                 
                 const contexts = ['general', 'friendly', 'curious', 'learning'];
                 return contexts[Math.floor(Math.random() * contexts.length)];
             }
            
            /**
             * Peer mesajƒ± √ºret (Enhanced Morphological System v2.7 veya fallback)
             */
            async generatePeerMessage(bacteria, context) {
                // Enhanced Morphological System v2.7 kullan
                if (window.generateEnhancedMorphSentence && bacteria.consciousness_level >= 0.8) {
                    try {
                        const mood = bacteria.personality_traits.mood || 0.5;
                        const contextEmbed = { context: context };
                        
                        return await window.generateEnhancedMorphSentence(
                            contextEmbed,
                            'simple',
                            {
                                emotionalTone: mood > 0.7 ? 'mutlu' : mood < 0.3 ? 'h√ºz√ºnl√º' : 'normal',
                                complexity: bacteria.consciousness_level > 1.5 ? 'complex' : 'simple',
                                consciousness: bacteria.consciousness_level,
                                enableStyle: mood > 0.4,
                                enableComposition: mood > 0.6,
                                mood: mood
                            }
                        );
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Enhanced morphology failed, using fallback');
                    }
                }
                
                // Fallback - basit mesaj √ºretimi
                return this.generateSimplePeerMessage(bacteria, context);
            }
            
            /**
             * Basit peer mesajƒ± (fallback)
             */
            generateSimplePeerMessage(bacteria, context) {
                                 const templates = {
                     'sad': ['Moralim bozuk...', 'Kendimi k√∂t√º hissediyorum', 'Yardƒ±ma ihtiyacƒ±m var'],
                     'happy': ['Harika hissediyorum!', 'Bu g√ºn √ßok g√ºzel!', 'Seninle konu≈ümak g√ºzel'],
                     'hungry': ['Acƒ±ktƒ±m...', 'Yemek arƒ±yorum', 'Enerji lazƒ±m'],
                     'philosophical': ['Varolu≈ü hakkƒ±nda d√º≈ü√ºn√ºyorum', 'Bilin√ß nedir?', 'B√ºy√ºmek g√ºzel'],
                     'social': ['Merhaba arkada≈ü!', 'Nasƒ±lsƒ±n?', 'Birlikte takƒ±lalƒ±m'],
                     'general': ['Selam!', 'Ne yapƒ±yorsun?', 'G√ºzel g√ºn'],
                     'friendly': ['Arkada≈üƒ±m!', 'Seni g√∂rmek g√ºzel', 'Beraber olalƒ±m'],
                     'curious': ['Bu nedir?', '√ñƒürenmek istiyorum', 'Merak ediyorum'],
                     'learning': ['Yeni ≈üeyler √∂ƒüreniyorum', 'Akƒ±llanƒ±yorum', 'Geli≈üiyorum'],
                     'supportive': ['√úz√ºlme arkada≈ü!', 'Her ≈üey d√ºzelecek', 'Yanƒ±ndayƒ±m', 'Moralini bozma', 'Birlikte g√º√ßl√ºy√ºz'],
                     'group_social': ['Herkese merhaba!', 'G√ºzel bir grup', 'Hep birlikte g√ºzeliz', 'Bu sohbet √ßok ho≈ü']
                 };
                
                const contextTemplates = templates[context] || templates['general'];
                const template = contextTemplates[Math.floor(Math.random() * contextTemplates.length)];
                
                // Vocabulary'den kelime ekle
                if (bacteria.vocabulary && bacteria.vocabulary.size > 0) {
                    const vocab = Array.from(bacteria.vocabulary);
                    const randomWord = vocab[Math.floor(Math.random() * vocab.length)];
                    return `${template} ${randomWord}!`;
                }
                
                return template;
            }
            
            /**
             * Peer'den √∂ƒürenme ve mood etkile≈üimi
             */
            learnFromPeer(receiver, message, sender) {
                // Kelimeleri √ßƒ±kar ve √∂ƒüren
                const words = message.toLowerCase()
                    .replace(/[^\w√ßƒüƒ±√∂≈ü√º√¢√Æ√ª\s]/g, ' ')
                    .split(/\s+/)
                    .filter(word => word.length > 2);
                
                // Yeni kelimeleri vocabulary'ye ekle
                let newWordsLearned = 0;
                words.forEach(word => {
                    if (!receiver.vocabulary.has(word) && Math.random() < 0.4) { // %40 √∂ƒürenme ≈üansƒ±
                        receiver.vocabulary.add(word);
                        newWordsLearned++;
                    }
                });
                
                // Mood analizi ve g√ºncelleme
                let moodDelta = 0;
                words.forEach(word => {
                    if (this.POSITIVE_WORDS.has(word)) {
                        moodDelta += 0.05;
                    } else if (this.NEGATIVE_WORDS.has(word)) {
                        moodDelta -= 0.03;
                    }
                });
                
                // Sosyal etkile≈üim bonus
                moodDelta += 0.02; // Konu≈ümak genel olarak mood artƒ±rƒ±r
                
                                 // Mood g√ºncelle (0-1 arasƒ± sƒ±nƒ±rla) - personality_traits.mood kullan
                 receiver.personality_traits.mood = Math.max(0, Math.min(1, receiver.personality_traits.mood + moodDelta));
                
                // Consciousness artƒ±≈üƒ± (peer learning bonus)
                if (newWordsLearned > 0) {
                    receiver.consciousness_level += newWordsLearned * 0.01;
                }
                
                // Persistent Learning'e kaydet
                if (window.persistentLearning) {
                    window.persistentLearning.recordInteraction(
                        message,
                        `Learned from ${sender.name}`,
                        'peer_learning',
                        receiver.id
                    );
                }
                
                                 console.log(`üß† ${receiver.name} learned ${newWordsLearned} words from ${sender.name}, mood: ${receiver.personality_traits.mood.toFixed(2)}`);
            }
            
            /**
             * Grup sohbeti (3-4 bakteri)
             */
            async runGroupChat() {
                const activeBacteria = bacteriaPopulation.filter(b => 
                    b.consciousness_level > 1.0 && b.personality_traits.sociability > 0.4
                );
                
                if (activeBacteria.length < 3) return;
                
                // 3-4 bakteri se√ß
                const groupSize = Math.min(4, activeBacteria.length);
                const group = this.shuffleArray(activeBacteria).slice(0, groupSize);
                
                console.log(`üë• Group chat started with: ${group.map(b => b.name).join(', ')}`);
                
                // Her bakteri sƒ±rayla konu≈üur
                for (let i = 0; i < group.length; i++) {
                    const speaker = group[i];
                    const context = 'group_social';
                    
                    const message = await this.generatePeerMessage(speaker, context);
                    this.renderSpeechBubble(speaker, message, 4000);
                    
                    // Diƒüer grup √ºyeleri √∂ƒürenir
                    group.filter(b => b !== speaker).forEach(listener => {
                        this.learnFromPeer(listener, message, speaker);
                    });
                    
                    // Kƒ±sa gecikme
                    await new Promise(resolve => setTimeout(resolve, 800));
                }
            }
            
            /**
             * Depresif bakterilere destek
             */
                         async checkDepressedBacteria() {
                 const depressedBacteria = bacteriaPopulation.filter(b => b.personality_traits.mood < 0.3);
                
                for (const depressed of depressedBacteria) {
                    // Pozitif bakteri bul
                                         const supporter = bacteriaPopulation.find(b => 
                         b !== depressed && 
                         b.personality_traits.mood > 0.6 && 
                         b.personality_traits.sociability > 0.5
                     );
                    
                    if (supporter && Math.random() < 0.3) { // %30 ≈üans ile destek
                        const supportMessage = await this.generatePeerMessage(supporter, 'supportive');
                        this.learnFromPeer(depressed, supportMessage, supporter);
                        this.renderSpeechBubble(supporter, `‚Üí ${depressed.name}: ${supportMessage}`, 4000);
                        
                                                 // Extra mood boost for support
                         depressed.personality_traits.mood = Math.min(1, depressed.personality_traits.mood + 0.1);
                        
                        console.log(`üíù ${supporter.name} supported depressed ${depressed.name}`);
                    }
                }
            }
            
            /**
             * üéØ √ñZELLƒ∞K 2: Konu≈üma balonu render (isim + mesaj)
             */
            renderSpeechBubble(bacteria, message, duration = 3000) {
                // Previous bubble'ƒ± temizle
                if (this.speechBubbles.has(bacteria.id)) {
                    clearTimeout(this.speechBubbles.get(bacteria.id).timeout);
                }
                
                // Bubble element olu≈ütur veya g√ºncelle
                let bubble = document.getElementById(`speech-${bacteria.id}`);
                if (!bubble) {
                    bubble = document.createElement('div');
                    bubble.id = `speech-${bacteria.id}`;
                    bubble.className = 'speech-bubble';
                    bubble.style.cssText = `
                        position: absolute;
                        background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(240, 248, 255, 0.9));
                        border: 1px solid #3b82f6;
                        border-radius: 12px;
                        padding: 6px 10px;
                        font-size: 11px;
                        max-width: 140px;
                        word-wrap: break-word;
                        z-index: 1000;
                        pointer-events: auto;
                        box-shadow: 0 3px 8px rgba(0,0,0,0.15);
                        cursor: pointer;
                        transition: all 0.3s ease, opacity 0.8s ease, transform 0.8s ease;
                        opacity: 1;
                        transform: scale(1) translateY(0);
                    `;
                    
                    // üéØ Bubble'a tƒ±klayƒ±nca bakteriyi se√ß
                    bubble.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        selectedBacteria = bacteria;
                        console.log(`üéØ Speech bubble'dan bakteri se√ßildi: ${bacteria.name}`);
                        
                        // UI'yi g√ºncelle
                        showBacteriaDetails(selectedBacteria);
                        highlightSelectedBacteria(bacteria);
                        
                        // Chat modunu individual'a √ßevir
                        if (chatMode !== 'individual') {
                            chatMode = 'individual';
                            updateChatModeButtons();
                            updateChatUI();
                        }
                        
                        // G√∂rsel feedback
                        bubble.style.transform = 'scale(1.1)';
                        bubble.style.borderColor = '#22c55e';
                        setTimeout(() => {
                            bubble.style.transform = 'scale(1)';
                            bubble.style.borderColor = '#3b82f6';
                        }, 300);
                    });
                    
                    // Hover efektleri
                    bubble.addEventListener('mouseenter', () => {
                        bubble.style.transform = 'scale(1.05)';
                        bubble.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
                    });
                    
                    bubble.addEventListener('mouseleave', () => {
                        bubble.style.transform = 'scale(1)';
                        bubble.style.boxShadow = '0 3px 8px rgba(0,0,0,0.15)';
                    });
                    
                    simulationArea.appendChild(bubble);
                }
                
                // üéØ ƒ∞sim + mesaj i√ßeriƒüini olu≈ütur
                const nameDiv = document.createElement('div');
                nameDiv.style.cssText = `
                    font-weight: bold;
                    color: #1e40af;
                    font-size: 9px;
                    margin-bottom: 2px;
                    border-bottom: 1px solid rgba(59, 130, 246, 0.3);
                    padding-bottom: 1px;
                `;
                nameDiv.textContent = bacteria.name;
                
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    color: #374151;
                    line-height: 1.2;
                `;
                messageDiv.textContent = message.substring(0, 45) + (message.length > 45 ? '...' : '');
                
                // Bubble i√ßeriƒüini temizle ve yeniden olu≈ütur
                bubble.innerHTML = '';
                bubble.appendChild(nameDiv);
                bubble.appendChild(messageDiv);
                
                // Pozisyon g√ºncelle (bakterinin biraz √ºst√ºnde)
                bubble.style.left = `${bacteria.x - 20}px`;
                bubble.style.top = `${bacteria.y - 35}px`;
                bubble.style.display = 'block';
                
                // üé≠ Entrance animasyonu
                bubble.style.opacity = '0';
                bubble.style.transform = 'scale(0.5) translateY(10px)';
                
                // Hemen entrance animasyonunu ba≈ülat
                setTimeout(() => {
                    bubble.style.opacity = '1';
                    bubble.style.transform = 'scale(1) translateY(0)';
                }, 10);
                
                // üé≠ G√ºzel fade out animasyonu
                const timeout = setTimeout(() => {
                    if (bubble && bubble.parentNode) {
                        // 1. Yukarƒ± kaydƒ±rma ve fade out ba≈ülat
                        bubble.style.opacity = '0';
                        bubble.style.transform = 'scale(0.8) translateY(-10px)';
                        bubble.style.pointerEvents = 'none';
                        
                        // 2. Animasyon tamamlandƒ±ktan sonra temizle
                        setTimeout(() => {
                            if (bubble && bubble.parentNode) {
                                bubble.style.display = 'none';
                                bubble.style.opacity = '1';
                                bubble.style.transform = 'scale(1) translateY(0)';
                                bubble.style.pointerEvents = 'auto';
                            }
                        }, 800); // Transition s√ºresi kadar bekle
                    }
                    this.speechBubbles.delete(bacteria.id);
                }, duration - 800); // Animasyon s√ºresini duration'dan √ßƒ±kar
                
                this.speechBubbles.set(bacteria.id, { bubble, timeout });
            }
            
            /**
             * Array karƒ±≈ütƒ±rma utility
             */
            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
        }

        // Global simulation manager (will be initialized in mainInitialize)
        let simulationManager = null;

        // Configuration Constants (centralized for better maintainability)
        const CONFIG = {
            SIMULATION: {
                INITIAL_BACTERIA_COUNT: 10,
                STEP_INTERVAL: 500, // ms - 6x faster simulation
                MAX_BACTERIA_POPULATION: 20,
                AUTO_FOOD_GENERATION_CHANCE: 0.7
            },
            BACTERIA: {
                MAX_SIZE: 3.5,
                BASE_GROWTH_RATE: 0.08,
                REPRODUCTION_MIN_AGE: 3,
                REPRODUCTION_MIN_SIZE: 1.2,
                REPRODUCTION_MIN_CONSCIOUSNESS: 1.0,
                REPRODUCTION_MIN_VOCABULARY: 5
            },
            CANVAS: {
                // ‚úÖ V8.7.4: ALL STATIC SIZES REMOVED - FULLY DYNAMIC NOW!
                // No static width/height - canvas uses 100% responsive sizing
                // SIMULATION_AREA_* COMPLETELY REMOVED - only DYNAMIC_BOUNDARIES used
            },
            UI: {
                MAX_VOCABULARY_DISPLAY: 10,
                FOOD_SIZE: 8,
                FPS_UPDATE_INTERVAL: 1000,
                PERFORMANCE_LOG_INTERVAL: 10000
            },
            PHYSICS: {
                INTERACTION_RANGE: 50,
                Z_DEPTH_MIN: 20,
                Z_DEPTH_MAX: 180,
                BOUNDARY_ENERGY_LOSS: 0.9
            },
            AI: {
                NEURAL_NETWORK_LAYERS: [12, 16, 12, 6], // Input, Hidden1, Hidden2, Output
                LEARNING_RATE: 0.15,
                MEMORY_CAPACITY: 100,
                EXPERIENCE_REPLAY_SIZE: 30,
                GENETIC_MUTATION_RATE: 0.12,
                FITNESS_DECAY: 0.92,
                BEHAVIOR_ADAPTATION_RATE: 0.1,
                NEURAL_EVOLUTION_RATE: 0.05,
                DECISION_THRESHOLD: 0.6,
                CONSCIOUSNESS_BOOST_RATE: 0.02
            },
            VOCABULARY: {
                TABPFN_ACCELERATION: true,
                CONTEXTUAL_LEARNING_RATE: 0.25,
                PROGRESSIVE_UNLOCK_THRESHOLD: 0.8,
                SOCIAL_LEARNING_MULTIPLIER: 1.5,
                CONSCIOUSNESS_WORD_RATIO: 0.1 // Words per consciousness level
            }
        };

        // Version and Build Info (moved up to prevent hoisting issues)  
        const VERSION = 'v9.6.2 GitHub Pages Fix';
        const BUILD_DATE = new Date().toISOString().slice(0,19);
        const FEATURES = [
            'Frontend-Only TabPFN (Mobile Compatible)',
            'Smart Contextual Word Usage',
            'Intelligent Vocabulary Management',
            'TabPFN-Style Behavior Classification',
            'Enhanced Conversation Intelligence',
            'Single HTML File Solution',
            'Real-time < 1 Second Predictions',
            'Dynamic AI Model Training',
            'Live Training Data Collection',
            'Dynamic Hunger & Energy Systems',
            'Persistent Database System',
            'Unlimited Consciousness Levels',
            'CSV Data Export/Import',
            'State Restoration',
            'Enhanced Environment Visualization',
            'Bacteria ID Labels',
            'Cross-Bacteria Learning',
            'Group Chat System',
            'Molecular Dynamics Simulation',
            'High-Speed Movement & Dynamics',
            'Auto Food Generation',
            'Enhanced Reproduction System'
        ];
        const FOOD_NUTRITION = 0.5;

        // Chat State
        let chatMode = 'individual'; // 'individual', 'group'
        let bacteriaConversationTimer = null;
        let lastBacteriaConversationTime = 0;
        
        // v826: Individual Chat Windows System
        let globalConversations = []; // All bacteria-to-bacteria conversations
        let openChatWindows = new Map(); // bacteria.id -> modal element
        let chatWindowZIndex = 1000;

        // Advanced AI/ML State  
        let wordEmbeddingModel = null;
        let behaviorPredictionModel = null;
        let isMLReady = false;
        let wordTokenizer = new Map();
        let globalNeuralNetwork = null;
        let geneticAlgorithm = null;
        let behaviourLearningSystem = null;
        let tabpfnVocabularySystem = null;

        // üé≠ JOKE SYSTEM CONFIGURATION
        const JOKE_CONFIG = {
            PREDEFINED_JOKE_CHANCE: 0.7,      // 70% chance for predefined jokes
            JOKE_COOLDOWN: 15000,              // 15 seconds cooldown between jokes
            JOKE_MORALE_BOOST: 0.1,            // 10% morale boost from jokes
            MAX_JOKE_DISTANCE: 100,            // Maximum distance to hear jokes
            MIN_CONSCIOUSNESS_FOR_JOKES: 3,    // Minimum consciousness to tell jokes
            JOKE_SUCCESS_THRESHOLD: 0.5        // Minimum success rate for joke attempts
        };

        // üé≠ MATHEMATICAL COMEDY THEORY SYSTEM v8.6.1
        // Based on Incongruity Theory + Surprisal + Sigmoid Modeling
        const COMEDY_MATH_CONFIG = {
            // Incongruity (Surprisal) Parameters
            MIN_SURPRISAL: 1.0, // Minimum surprisal bits for comedy effect
            MAX_SURPRISAL: 4.0, // Maximum useful surprisal
            SURPRISAL_WEIGHT: 1.2, // Œ± parameter for incongruity influence
            
            // Sigmoid Function Parameters for Joke Probability
            MOOD_WEIGHT: 1.0, // Œ≥ parameter for mood influence  
            SOCIABILITY_WEIGHT: 0.8, // Œ¥ parameter for social influence
            CONSCIOUSNESS_THRESHOLD: 2.5,
            MIN_MOOD_THRESHOLD: 0.6,
            MIN_OPTIMISM_THRESHOLD: 0.6,
            MIN_SOCIABILITY_THRESHOLD: 0.5,
            
            // Listener Reaction Parameters
            LISTENER_ETA: 1.5, // Œ∑ - how strongly listeners absorb incongruity
            LISTENER_ZETA: 1.0, // Œ∂ - stress dampening factor
            UNDERSTANDING_THRESHOLD: 0.4, // Min probability to "understand" joke
            
            // Cultural Evolution
            CULTURAL_PROMOTION_THRESHOLD: 0.8, // 80% success rate for cultural status
            MIN_LISTENERS_FOR_CULTURE: 3, // Minimum audience for cultural promotion
            CULTURAL_MEMORY_DECAY: 0.95, // How cultural jokes lose relevance over time
            
            // System Parameters
            PREDEFINED_JOKE_CHANCE: 0.6,
            DYNAMIC_JOKE_CHANCE: 0.4,
            JOKE_COOLDOWN: 30000,
            MAX_JOKE_DISTANCE: 150,
            BASE_MORALE_BOOST: 0.05,
            RITUAL_BONUS: 0.1
        };

        // üßÆ MATHEMATICAL COMEDY FUNCTIONS
        class ComedyMath {
            // Calculate surprisal value for word in context
            static calculateSurprisal(word, context, bacteria) {
                if (!bacteria.vocabulary || bacteria.vocabulary.size === 0) return 0;
                
                const vocabularySize = bacteria.vocabulary.size;
                const wordFrequency = bacteria.wordFrequencies?.get(word) || 1;
                const totalWords = Array.from(bacteria.wordFrequencies?.values() || [1]).reduce((a, b) => a + b, vocabularySize);
                
                // P(word | context) estimation
                const probability = wordFrequency / totalWords;
                
                // Surprisal = -log2(P(word | context))
                const surprisal = -Math.log2(Math.max(probability, 0.001)); // Avoid log(0)
                
                return Math.min(surprisal, COMEDY_MATH_CONFIG.MAX_SURPRISAL);
            }
            
            // Sigmoid function for probability calculations
            static sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }
            
            // Calculate joke-telling probability using sigmoid model
            static calculateJokeProbability(bacteria) {
                if (!bacteria.vocabulary || bacteria.vocabulary.size < 3) return 0;
                
                // Sample words from vocabulary for surprisal calculation
                const words = Array.from(bacteria.vocabulary);
                const avgSurprisal = words.slice(0, 3).reduce((sum, word) => 
                    sum + this.calculateSurprisal(word, 'joke_context', bacteria), 0) / 3;
                
                if (avgSurprisal < COMEDY_MATH_CONFIG.MIN_SURPRISAL) return 0;
                
                // Sigmoid calculation: P_joke = œÉ(Œ±*(I-I_min) + Œ≥*(M-M_min) + Œ¥*(S-S_min))
                const x = COMEDY_MATH_CONFIG.SURPRISAL_WEIGHT * (avgSurprisal - COMEDY_MATH_CONFIG.MIN_SURPRISAL) +
                         COMEDY_MATH_CONFIG.MOOD_WEIGHT * (bacteria.personality_traits.mood - COMEDY_MATH_CONFIG.MIN_MOOD_THRESHOLD) +
                         COMEDY_MATH_CONFIG.SOCIABILITY_WEIGHT * (bacteria.personality_traits.sociability - COMEDY_MATH_CONFIG.MIN_SOCIABILITY_THRESHOLD);
                
                return this.sigmoid(x);
            }
            
            // Calculate listener's incongruity absorption (IA)
            static calculateIncongruityAbsorption(joke, listener, jokeSuprisal) {
                const stress = listener.stress || (1 - listener.personality_traits.mood); // Estimate stress from mood
                
                // IA = œÉ(Œ∑ * I_joke - Œ∂ * stress)
                const x = COMEDY_MATH_CONFIG.LISTENER_ETA * jokeSuprisal - 
                         COMEDY_MATH_CONFIG.LISTENER_ZETA * stress;
                
                return this.sigmoid(x);
            }
            
            // Calculate laugh probability for a listener
            static calculateLaughProbability(incongruityAbsorption, listener) {
                // P_laugh = IA √ó S √ó M
                return incongruityAbsorption * 
                       listener.personality_traits.sociability * 
                       listener.personality_traits.mood;
            }
            
            // Determine if joke should be promoted to cultural status
            static shouldPromoteToCulture(successRate, listenerCount) {
                return successRate >= COMEDY_MATH_CONFIG.CULTURAL_PROMOTION_THRESHOLD &&
                       listenerCount >= COMEDY_MATH_CONFIG.MIN_LISTENERS_FOR_CULTURE;
            }
            
            // Calculate cultural value decay over time
            static calculateCulturalDecay(joke, timeSinceCreation) {
                const ageInDays = timeSinceCreation / (1000 * 60 * 60 * 24);
                return Math.pow(COMEDY_MATH_CONFIG.CULTURAL_MEMORY_DECAY, ageInDays);
            }
        }

        // üìö Comprehensive Joke Database with Categories and Responses
        const PREDEFINED_JOKES = new Map([
            ["vur joker VUUƒûRR", { 
                responses: ["oyna oyna oyna! üéÆ", "VUUƒûRR! üÉè", "joker iyidir! üòÑ", "hahaha klasik! ü§£"], 
                category: "rituel",
                successRate: 0.9,
                culturalValue: 1.0 // How "cultural" this joke is
            }],
            ["neden elektron mutsuzdu?", { 
                responses: ["√ß√ºnk√º hep negatifti! ‚ö°", "pozitif d√º≈ü√ºnseydi! üòÇ", "anlamadƒ±m ama komik? ü§î"], 
                category: "bilimsel_espri",
                successRate: 0.7,
                culturalValue: 0.6
            }],
            ["ATP ne der?", { 
                responses: ["enerji veriyorum! ‚ö°", "yoruldum! üò¥", "sentez yapalƒ±m! üß¨"], 
                category: "biyokimya_mizahi",
                successRate: 0.75,
                culturalValue: 0.8
            }],
            ["mikroorganizma toplantƒ±sƒ±nda", { 
                responses: ["herkes √ßok k√º√ß√ºk geldi! üòÖ", "b√ºy√ºtece ihtiya√ß var! üîç", "b√∂l√ºnelim mi? üòÑ"], 
                category: "sosyal_mizah",
                successRate: 0.6,
                culturalValue: 0.7
            }]
        ]);

        // üé™ Dynamic Joke Generation Templates
        const JOKE_TEMPLATES = [
            "{scientific_word} + {emotion_word} = {silly_result}",
            "Neden {organism} {action}? √á√ºnk√º {reason}!",
            "{character} ne der? '{expression}!'",
            "{process} yaparken {unexpected_thing} oldu!"
        ];

        // üé≠ JOKE MASTER V8.8.0 - CSV-Powered Kategorik Yatkƒ±nlƒ±k Sistemi
        class JokeMaster {
            constructor(vocabularySystem) {
                this.vocabularySystem = vocabularySystem;
                this.predefinedJokes = PREDEFINED_JOKES;
                this.csvJokes = []; // SAKALAR.csv data
                this.categoryAffinities = new Map(); // bacteria_id -> {category: affinity_score}
                this.jokePopularity = new Map(); // joke_id -> popularity (1-100)
                this.learnedJokes = new Map(); // Dynamic jokes learned from community
                this.culturalJokes = new Map(); // Jokes that became cultural references
                this.jokeHistory = []; // Track all told jokes for analysis
                this.generation = 0; // Joke evolution generation
                
                this.initializeCSVJokes();
                console.log('üé≠ JokeMaster V8.8.0 initialized with CSV Comedy System!');
            }

            // üéØ CSV Integration System
            async initializeCSVJokes() {
                try {
                    const response = await fetch('./SAKALAR.csv');
                    const csvText = await response.text();
                    this.csvJokes = this.parseCSVJokes(csvText);
                    
                    // Initialize popularity scores (50-100 range)
                    this.csvJokes.forEach(joke => {
                        this.jokePopularity.set(joke.SakaID, 50 + Math.random() * 50);
                    });
                    
                    console.log(`üé™ Loaded ${this.csvJokes.length} jokes from SAKALAR.csv`);
                } catch (error) {
                    console.warn('üìÅ SAKALAR.csv not found, using fallback system');
                    this.initializeFallbackJokes();
                }
            }

            parseCSVJokes(csvText) {
                const lines = csvText.split('\n').slice(1); // Skip header
                return lines.filter(line => line.trim()).map((line, index) => {
                    const parts = line.split(',');
                    return {
                        SakaID: index + 1,
                        Kategori: (parts[0] && parts[0].trim()) || 'Genel',
                        SakaMetni: (parts[1] && parts[1].replace(/"/g, '').trim()) || '',
                        TepkiMetinleri: (parts[2] && parts[2].split('|').map(r => r.trim())) || ['üòÑ', 'ü§î', 'üòÖ'],
                        UygunlukSeviyesi: parseInt(parts[3]) || 1,
                        KaraMizahSeviyesi: parseInt(parts[4]) || 0
                    };
                }).filter(joke => joke.SakaMetni.length > 5);
            }

            initializeFallbackJokes() {
                this.csvJokes = [
                    {
                        SakaID: 1,
                        Kategori: 'Bilimsel_Espri',
                        SakaMetni: 'ATP\'ye sordum, enerjim nasƒ±l? O da: Sen √ßok potansiyellisin!',
                        TepkiMetinleri: ['Hahaha! üòÇ', 'Bilimsel! üß¨', '√áok zeki! ü§ì'],
                        UygunlukSeviyesi: 1,
                        KaraMizahSeviyesi: 0
                    },
                    {
                        SakaID: 2,
                        Kategori: 'Soguk_Espri',
                        SakaMetni: 'Bakteri neden √ºzg√ºn? √á√ºnk√º kimse onu g√∂remiyor!',
                        TepkiMetinleri: ['Ayy! üòÖ', 'K√∂t√º ama komik! üòÑ', 'Baba ≈üakasƒ±! üë®'],
                        UygunlukSeviyesi: 1,
                        KaraMizahSeviyesi: 0
                    },
                    {
                        SakaID: 3,
                        Kategori: 'Sim_Ozel',
                        SakaMetni: 'Vur joker vur!',
                        TepkiMetinleri: ['OLEY! üéâ', 'K√ºlt√ºrel an! üé≠', 'Ritual! üî•'],
                        UygunlukSeviyesi: 2,
                        KaraMizahSeviyesi: 0
                    }
                ];
            }

            // üéØ MAIN METHOD V8.8.0: Kategorik Yatkƒ±nlƒ±k & Pop√ºlerlik Motoru
            tryTellingJoke(bacteria, forced = false) {
                if (!forced && !this.isEligibleForJoke(bacteria)) return null;

                // Priority: CSV jokes > predefined > dynamic
                if (this.csvJokes.length > 0) {
                    return this.selectCSVJoke(bacteria);
                } else {
                    const jokeType = Math.random() < JOKE_CONFIG.PREDEFINED_JOKE_CHANCE ? 'predefined' : 'dynamic';
                    return jokeType === 'predefined' ? this.getPredefinedJoke(bacteria) : this.generateDynamicJoke(bacteria);
                }
            }

            // üé™ Kategorik Yatkƒ±nlƒ±k & Pop√ºlerlik Selection Engine
            selectCSVJoke(bacteria) {
                this.updateCategoryAffinities(bacteria);
                
                let weightedJokePool = [];
                
                for (const joke of this.csvJokes) {
                    // Skip inappropriate jokes based on bacteria's dark humor tolerance
                    if (joke.KaraMizahSeviyesi > 0 && bacteria.personality_traits.dark_humor_tolerance < 0.5) {
                        continue;
                    }
                    
                    // Get personal affinity for this category
                    const personalAffinity = this.getCategoryAffinity(bacteria.id, joke.Kategori);
                    
                    // Get cultural popularity
                    const culturalPopularity = this.jokePopularity.get(joke.SakaID) || 50;
                    
                    // Calculate final weight: personal taste √ó cultural popularity
                    const weight = personalAffinity * (culturalPopularity / 100);
                    
                    weightedJokePool.push({ joke, weight });
                }
                
                if (weightedJokePool.length === 0) return null;
                
                // Weighted random selection
                const totalWeight = weightedJokePool.reduce((sum, item) => sum + item.weight, 0);
                let random = Math.random() * totalWeight;
                
                for (const item of weightedJokePool) {
                    random -= item.weight;
                    if (random <= 0) {
                        console.log(`üé≠ ${bacteria.name} selected ${item.joke.Kategori} joke with weight ${item.weight.toFixed(2)}`);
                        return this.formatCSVJoke(item.joke, bacteria);
                    }
                }
                
                // Fallback
                return this.formatCSVJoke(weightedJokePool[0].joke, bacteria);
            }

            // üßÆ Dynamic Category Affinity Updates Based on Personality
            updateCategoryAffinities(bacteria) {
                if (!this.categoryAffinities.has(bacteria.id)) {
                    this.categoryAffinities.set(bacteria.id, {});
                }
                
                const affinities = this.categoryAffinities.get(bacteria.id);
                
                // Bilimsel Espri - High consciousness & curiosity
                affinities.Bilimsel_Espri = (bacteria.consciousness_level / 10) * 0.5 + 
                                           bacteria.personality_traits.curiosity * 0.5;
                
                // Soƒüuk Espri - Low social skills but high humor attempts
                affinities.Soguk_Espri = (1 - bacteria.personality_traits.sociability) * 0.6 + 
                                        bacteria.personality_traits.humor_attempts * 0.4;
                
                // Kara Mizah - Dark humor tolerance + low optimism
                affinities.Kara_Mizah = (bacteria.personality_traits.dark_humor_tolerance || 0) * 0.7 + 
                                       (1 - bacteria.personality_traits.optimism) * 0.3;
                
                // Sim √ñzel (Rituals) - High sociability + cultural awareness
                affinities.Sim_Ozel = bacteria.personality_traits.sociability * 0.6 + 
                                     (bacteria.memory_bank.length / 100) * 0.4;
                
                // Other categories get balanced scoring
                ['Absurt_Mizah', 'Kelime_Oyunu', 'Gundelik_Mizah', 'Sosyal_Mizah'].forEach(category => {
                    affinities[category] = 0.3 + Math.random() * 0.4; // 0.3-0.7 range
                });
            }

            getCategoryAffinity(bacteriaId, category) {
                const affinities = this.categoryAffinities.get(bacteriaId) || {};
                return affinities[category] || 0.5; // Default neutral affinity
            }

            formatCSVJoke(csvJoke, bacteria) {
                return {
                    type: 'csv',
                    text: csvJoke.SakaMetni,
                    responses: csvJoke.TepkiMetinleri,
                    category: csvJoke.Kategori,
                    originator: bacteria,
                    culturalValue: Math.min(1.0, (this.jokePopularity.get(csvJoke.SakaID) || 50) / 100),
                    expectedSuccess: 0.7,
                    jokeId: csvJoke.SakaID
                };
            }

            isEligibleForJoke(bacteria) {
                // Mathematical eligibility check
                const jokeProbability = ComedyMath.calculateJokeProbability(bacteria);
                const baseEligibility = bacteria.consciousness_level >= COMEDY_MATH_CONFIG.CONSCIOUSNESS_THRESHOLD &&
                       bacteria.personality_traits.optimism >= COMEDY_MATH_CONFIG.MIN_OPTIMISM_THRESHOLD &&
                       bacteria.personality_traits.sociability >= COMEDY_MATH_CONFIG.MIN_SOCIABILITY_THRESHOLD &&
                       bacteria.personality_traits.mood >= COMEDY_MATH_CONFIG.MIN_MOOD_THRESHOLD;
                
                // Add mathematical probability threshold
                return baseEligibility && jokeProbability > 0.1; // 10% minimum joke probability
            }

            getPredefinedJoke(bacteria) {
                const availableJokes = Array.from(this.predefinedJokes.keys());
                if (availableJokes.length === 0) return null;

                // Prefer jokes bacteria hasn't told recently or cultural jokes
                let selectedJoke = availableJokes[Math.floor(Math.random() * availableJokes.length)];
                
                // Cultural bias: prefer ritual jokes if bacteria has high social traits
                if (bacteria.personality_traits.sociability > 0.8) {
                    const culturalJokes = availableJokes.filter(joke => 
                        this.predefinedJokes.get(joke).category === 'rituel'
                    );
                    if (culturalJokes.length > 0) {
                        selectedJoke = culturalJokes[Math.floor(Math.random() * culturalJokes.length)];
                    }
                }

                const jokeData = this.predefinedJokes.get(selectedJoke);
                return {
                    type: 'predefined',
                    text: selectedJoke,
                    responses: jokeData.responses,
                    category: jokeData.category,
                    originator: bacteria,
                    culturalValue: jokeData.culturalValue,
                    expectedSuccess: jokeData.successRate
                };
            }

            // TabPFN-Enhanced Dynamic Joke Generation
            generateDynamicJoke(bacteria) {
                const learnedWords = Array.from(bacteria.vocabulary);
                if (learnedWords.length < 3) return null;

                // Use TabPFN to get contextually interesting words
                let jokeText = this.createDynamicJokeText(bacteria, learnedWords);
                
                if (!jokeText || jokeText.split(" ").length < 2) return null;

                const dynamicResponses = [
                    "hahaha! üòÇ", "√ßok yaratƒ±cƒ±! üé®", "bu ne ya? ü§î", 
                    "komik! üòÑ", "anlamadƒ±m ama g√ºld√ºm! üòÖ", "daha fazla! üé≠",
                    "abs√ºrt ama ho≈ü! ü§™", "kelime ustasƒ±! üìö"
                ];

                return {
                    type: 'dynamic',
                    text: jokeText,
                    responses: dynamicResponses,
                    category: "yaratici_absurt",
                    originator: bacteria,
                    culturalValue: 0.3, // Dynamic jokes start with low cultural value
                    expectedSuccess: 0.5
                };
            }

            createDynamicJokeText(bacteria, learnedWords) {
                // Mathematical word selection based on surprisal theory
                let jokeWords = [];
                
                // Calculate surprisal for all learned words and select high-surprisal words
                const wordSurprisals = learnedWords.map(word => ({
                    word: word,
                    surprisal: ComedyMath.calculateSurprisal(word, 'joke_context', bacteria)
                }));
                
                // Sort by surprisal (descending) and take top words for comedy
                wordSurprisals.sort((a, b) => b.surprisal - a.surprisal);
                
                // Select words with good surprisal values for incongruity
                const highSurprisalWords = wordSurprisals
                    .filter(ws => ws.surprisal >= COMEDY_MATH_CONFIG.MIN_SURPRISAL)
                    .slice(0, 5); // Top 5 surprising words
                
                if (highSurprisalWords.length < 2) {
                    // Fallback to random selection if no high-surprisal words
                    jokeWords = learnedWords.slice(0, 3);
                } else {
                    // Use mathematical selection: mix of high surprisal and context
                    jokeWords = [
                        highSurprisalWords[0]?.word || learnedWords[0], // Most surprising
                        highSurprisalWords[Math.floor(Math.random() * Math.min(3, highSurprisalWords.length))]?.word || learnedWords[1],
                        learnedWords[Math.floor(Math.random() * learnedWords.length)] // Random for absurdity
                    ].filter(w => w);
                }

                // Enhanced TabPFN integration if available
                if (this.vocabularySystem && typeof this.vocabularySystem.improveWordUsage === 'function') {
                    const contexts = ['scientific', 'social', 'philosophical'];
                    const contextWord = this.vocabularySystem.improveWordUsage(bacteria, contexts[Math.floor(Math.random() * contexts.length)]);
                    if (contextWord && !jokeWords.includes(contextWord)) {
                        jokeWords[2] = contextWord; // Replace last word with context-appropriate word
                    }
                }

                // Create joke using mathematical template selection
                const template = JOKE_TEMPLATES[Math.floor(Math.random() * JOKE_TEMPLATES.length)];
                const jokeText = this.fillJokeTemplate(template, jokeWords, bacteria);
                
                // Calculate final joke surprisal for quality control
                const finalSurprisal = jokeWords.reduce((sum, word) => 
                    sum + ComedyMath.calculateSurprisal(word, 'combined_joke', bacteria), 0) / jokeWords.length;
                
                console.log(`üßÆ Dynamic joke created with avg surprisal: ${finalSurprisal.toFixed(2)} bits`);
                
                return jokeText;
            }

            fillJokeTemplate(template, words, bacteria) {
                // Simple template filling - can be made more sophisticated
                let joke = template;
                
                const wordTypes = {
                    scientific_word: words.filter(w => ['ATP', 'DNA', 'protein', 'enzim'].includes(w))[0] || words[0] || 'molek√ºl',
                    emotion_word: words.filter(w => ['mutlu', '√ºzg√ºn', 'komik', 'ne≈üeli'].includes(w))[0] || words[1] || 'garip',
                    organism: 'bakteri',
                    action: words[2] || 'hareket',
                    reason: words.join(' '),
                    character: bacteria.name,
                    expression: words.slice(0,2).join(' ') || 'haha',
                    process: '√∂ƒürenme',
                    unexpected_thing: words[words.length-1] || '≈üa≈üƒ±rtƒ±cƒ±'
                };

                // Replace template variables
                Object.keys(wordTypes).forEach(key => {
                    joke = joke.replace(`{${key}}`, wordTypes[key]);
                });

                return joke;
            }

            // Mathematical joke outcome recording with cultural evolution
            recordJokeOutcome(jokeText, wasSuccessful, listenerCount, avgSurprisal = 0) {
                const jokeData = this.learnedJokes.get(jokeText) || { 
                    count: 0, 
                    successCount: 0, 
                    listeners: new Set(),
                    generation: this.generation,
                    avgSurprisal: 0,
                    culturalValue: 0.3,
                    createdAt: Date.now()
                };
                
                jokeData.count++;
                if (wasSuccessful) jokeData.successCount++;
                
                // Update average surprisal for this joke
                jokeData.avgSurprisal = (jokeData.avgSurprisal * (jokeData.count - 1) + avgSurprisal) / jokeData.count;
                
                this.learnedJokes.set(jokeText, jokeData);

                // Mathematical popularity calculation
                const successRate = jokeData.successCount / jokeData.count;
                const surprisalBonus = Math.min(jokeData.avgSurprisal / COMEDY_MATH_CONFIG.MAX_SURPRISAL, 1);
                const listenerBonus = Math.min(listenerCount / COMEDY_MATH_CONFIG.MIN_LISTENERS_FOR_CULTURE, 1);
                
                const mathematicalPopularity = successRate * 0.6 + surprisalBonus * 0.2 + listenerBonus * 0.2;
                this.jokePopularity.set(jokeText, mathematicalPopularity);

                // Mathematical cultural promotion check
                if (ComedyMath.shouldPromoteToCulture(successRate, listenerCount) && 
                    jokeData.avgSurprisal >= COMEDY_MATH_CONFIG.MIN_SURPRISAL) {
                    this.promoteToculturalJoke(jokeText, jokeData);
                }

                // Enhanced tracking with mathematical metrics
                this.jokeHistory.push({
                    text: jokeText,
                    successful: wasSuccessful,
                    listeners: listenerCount,
                    timestamp: Date.now(),
                    surprisal: avgSurprisal,
                    successRate: successRate,
                    culturalValue: jokeData.culturalValue,
                    mathematicalPopularity: mathematicalPopularity
                });
                
                console.log(`üìä Joke metrics - Success: ${(successRate*100).toFixed(1)}%, Surprisal: ${avgSurprisal.toFixed(2)}, Popularity: ${(mathematicalPopularity*100).toFixed(1)}%`);
            }

            promoteToculturalJoke(jokeText, jokeData) {
                if (!this.culturalJokes.has(jokeText)) {
                    this.culturalJokes.set(jokeText, {
                        ...jokeData,
                        promotedAt: Date.now(),
                        culturalValue: 0.9
                    });
                    
                    console.log(`üèÜ Joke promoted to cultural status: "${jokeText}"`);
                    
                    // Add to predefined jokes for future use
                    this.predefinedJokes.set(jokeText, {
                        responses: ["bu klasik! üòÑ", "biliyorum bunu! ü§£", "efsane ≈üaka! üèÜ"],
                        category: "komunite_klasigi",
                        successRate: jokeData.successCount / jokeData.count,
                        culturalValue: 0.9
                    });
                }
            }

            // Get statistics for system analysis
            getJokeStatistics() {
                return {
                    totalJokes: this.jokeHistory.length,
                    culturalJokes: this.culturalJokes.size,
                    learnedJokes: this.learnedJokes.size,
                    averageSuccess: this.jokeHistory.reduce((acc, j) => acc + (j.successful ? 1 : 0), 0) / this.jokeHistory.length,
                    generation: this.generation
                };
            }
        }

        // Global JokeMaster instance
        let jokeMasterInstance = null;

        // üß¨ DYNAMIC LANGUAGE EVOLUTION SYSTEM v8.7.0
        // üöÄ V8.9.0: ANTI-PATTERN LANGUAGE EVOLUTION ENGINE - Revolutionary Language System
        class LanguageEvolutionEngine {
            constructor() {
                this.globalLanguagePatterns = new Map(); // T√ºm bakterilerde kullanƒ±lan dil kalƒ±plarƒ±
                this.wordMutations = new Map(); // Kelime mutasyonlarƒ±/evrimleri
                this.contextualPhrases = new Map(); // Baƒülamsal ifade kalƒ±plarƒ±
                this.personalityLanguageTraits = new Map(); // Ki≈üilik bazlƒ± dil √∂zellikleri
                this.languageGeneration = 0; // Dil evrimi nesli
                this.emergentGrammar = new Map(); // Ortaya √ßƒ±kan gramer kurallarƒ±
                
                // üÜï V8.9.0: ANTI-PATTERN FEATURES
                this.bacteriaBigrams = new Map(); // Markov chains for each bacteria
                this.metaTemplates = new Map(); // Meta-template system
                this.absurdWords = ['mikrofon', 'g√ºne≈ü', 'hipopotam', 'kuantum', 'pizza', 'roket', 'dinozor', 'kristal']; // Shock elements
                this.contextOverrides = new Map(); // Context breaking triggers
                this.adaptiveSuccess = new Map(); // Success tracking for reinforcement
                
                console.log('üß¨ Language Evolution Engine V8.9.1: ANTI-PATTERN TEST MODE!');
                console.log('üî• TEST MODE: Boosted probabilities for immediate visibility');
                console.log('üé≤ Œµ-greedy: 60% | üé≠ Meta-template: 70% | üé™ Absurd: 48%');
                this.initializeBasicPatterns();
                this.initializeAntiPatternSystems();
            }

            // üéØ Initialize Anti-Pattern Systems
            initializeAntiPatternSystems() {
                // Meta-templates for pattern-breaking conversations
                this.metaTemplates.set('complex_mix', [
                    "{greeting} {subTemplate1}; ama aslƒ±nda {subTemplate2}.",
                    "√ñnce {subTemplate1}, sonra {subTemplate2}, sonu√ß: {reaction}.",
                    "{subject} der ki: \"{subTemplate1}?\" {subTemplate2}!",
                    "{subTemplate1} + {shock_element} = {subTemplate2}",
                    "ƒ∞lgin√ß: {subTemplate1}, √ß√ºnk√º {subTemplate2}..."
                ]);
                
                // Context override triggers - üî• V8.9.1 TEST: EASIER CONDITIONS FOR VISIBILITY
                this.contextOverrides.set('high_stress', (bacteria) => bacteria.personality_traits.mood < 0.6); // Lowered from 0.3
                this.contextOverrides.set('confusion', (bacteria) => bacteria.consciousness_level < 5 && bacteria.vocabulary.size > 3); // Relaxed conditions
                this.contextOverrides.set('creative_burst', (bacteria) => bacteria.personality_traits.creativity > 0.5); // Lowered from 0.8
                this.contextOverrides.set('random_chaos', (bacteria) => Math.random() < 0.1); // üÜï 10% pure random chaos!
                
                console.log('üé≠ Anti-Pattern systems initialized!');
            }

            initializeBasicPatterns() {
                // Temel dil kalƒ±plarƒ± - bunlar evrimle≈üecek
                this.contextualPhrases.set('greeting', [
                    "{subject} merhaba!",
                    "{emotion} {subject}",
                    "hey {target}!"
                ]);
                
                this.contextualPhrases.set('learning', [
                    "{subject} √∂ƒürendim: {learned_word}",
                    "{surprise_word} + {learned_word} = {reaction}",
                    "yeni ke≈üif: {learned_word}"
                ]);
                
                this.contextualPhrases.set('excitement', [
                    "{emotion}! {discovery}!",
                    "{learned_word} + {emotion} = harika!",
                    "vay be, {surprise_word}!"
                ]);
                
                this.contextualPhrases.set('confusion', [
                    "{confusion_word}... {learned_word}?",
                    "ne demek {unknown_word}?",
                    "{learned_word} + ? = kafam karƒ±≈ütƒ±"
                ]);
                
                this.contextualPhrases.set('social', [
                    "{friend_name}, {learned_word} payla≈üalƒ±m!",
                    "birlikte {activity} yapalƒ±m",
                    "{emotion} arkada≈ülƒ±k"
                ]);
            }

            // üé≠ V8.9.0: ADVANCED PERSONALITY LANGUAGE GENERATOR
            generatePersonalityLanguage(bacteria) {
                if (!bacteria.personalLanguageStyle) {
                    bacteria.personalLanguageStyle = {
                        wordOrder: Math.random() > 0.5 ? 'normal' : 'inverted', // Kelime sƒ±rasƒ±
                        emotionLevel: bacteria.personality_traits.optimism, // Duygusal yoƒüunluk
                        complexityPreference: bacteria.consciousness_level / 10, // Karma≈üƒ±klƒ±k seviyesi
                        uniqueWords: new Set(), // Kendine √∂zg√º kelimeler
                        phrasePatterns: new Map(), // Ki≈üisel ifade kalƒ±plarƒ±
                        mutationRate: bacteria.personality_traits.humor * 0.3, // Dil mutasyon oranƒ±
                        
                        // üÜï V8.9.1 TEST: BOOSTED ANTI-PATTERN TRAITS FOR VISIBILITY
                        slangProbability: 0.4 + Math.random() * 0.4, // %40-80 argo/slang kullanma
                        repetitionProbability: 0.2 + Math.random() * 0.3, // %20-50 kelime tekrar etme
                        punctuationStyle: Math.random() < 0.5 ? '!!' : '?!', // Noktalama tarzƒ±
                        absurdTolerance: 0.3 + Math.random() * 0.5, // %30-80 abs√ºrt √∂ƒüe kabul√º
                        patternBreakingTendency: 0.3 + Math.random() * 0.5, // %30-80 kalƒ±p kƒ±rma eƒüilimi
                        markovChainUsage: 0.4 + Math.random() * 0.5, // %40-90 Markov zinciri kullanƒ±m
                        contextSwitchRate: 0.2 + Math.random() * 0.4, // %20-60 baƒülam deƒüi≈ütirme
                        metaTemplatePreference: Math.random() < 0.6 // %60 meta-template tercihi
                    };
                    
                    // Initialize personal bigram map for Markov chains
                    if (!this.bacteriaBigrams.has(bacteria.id)) {
                        this.bacteriaBigrams.set(bacteria.id, new Map());
                    }
                }
                return bacteria.personalLanguageStyle;
            }

            // Yeni kelime kombinasyonu yaratma (ML-enhanced)
            createWordCombination(bacteria, context, baseWords) {
                const style = this.generatePersonalityLanguage(bacteria);
                const vocabulary = Array.from(bacteria.vocabulary);
                
                if (vocabulary.length < 2) return baseWords.join(' ');

                // TabPFN-enhanced kelime se√ßimi
                let enhancedWords = [];
                for (let i = 0; i < 3; i++) {
                    let word;
                    
                    // TabPFN kullanarak baƒülamsal kelime √∂ner
                    if (tabpfnVocabularySystem && typeof tabpfnVocabularySystem.improveWordUsage === 'function') {
                        word = tabpfnVocabularySystem.improveWordUsage(bacteria, context);
                    }
                    
                    // Yoksa bakterinin kendi kelimelerinden se√ß
                    if (!word) {
                        word = vocabulary[Math.floor(Math.random() * vocabulary.length)];
                    }
                    
                    enhancedWords.push(word);
                }

                // Ki≈üilik bazlƒ± kombinasyon
                if (style.wordOrder === 'inverted') {
                    enhancedWords.reverse();
                }

                // Duygusal yoƒüunluk ekle
                if (style.emotionLevel > 0.7) {
                    const emotions = ['!', '!! üòä', '‚ú®', 'üéâ', 'üí´'];
                    enhancedWords.push(emotions[Math.floor(Math.random() * emotions.length)]);
                }

                // Karma≈üƒ±klƒ±k seviyesine g√∂re baƒüla√ß ekle
                if (style.complexityPreference > 0.6 && enhancedWords.length > 1) {
                    const connectors = ['+', 've', 'ile', '‚Üí', '='];
                    const connector = connectors[Math.floor(Math.random() * connectors.length)];
                    return enhancedWords.slice(0, 2).join(` ${connector} `) + 
                           (enhancedWords[2] ? ` ${enhancedWords[2]}` : '');
                }

                return enhancedWords.join(' ');
            }

            // üß¨ V8.9.0: ENHANCED WORD MUTATION with Noise Factor
            mutateWord(bacteria, originalWord) {
                const style = this.generatePersonalityLanguage(bacteria);
                
                // Enhanced mutation chance with random noise
                const baseMutation = Math.random() < style.mutationRate;
                const randomNoise = Math.random() < 0.1; // 10% extra chaos factor
                
                if (!baseMutation && !randomNoise) return originalWord;

                const mutations = [
                    // Ses deƒüi≈üimi
                    () => originalWord.replace(/a/g, 'e').replace(/o/g, 'u'),
                    // Ek ekleme
                    () => originalWord + (Math.random() > 0.5 ? 'ik' : 'li'),
                    // Kƒ±saltma
                    () => originalWord.length > 3 ? originalWord.slice(0, -1) : originalWord,
                    // Tekrar
                    () => originalWord + originalWord.slice(-2),
                    // Emoji ekleme
                    () => originalWord + ['‚ú®', 'üåü', 'üí´', 'üîÆ'][Math.floor(Math.random() * 4)],
                    // üÜï V8.9.0: Anti-Pattern Mutations
                    () => originalWord.split('').reverse().join(''), // Reverse letters
                    () => originalWord + this.getRandomChoice(this.absurdWords).slice(0, 2), // Absurd suffix
                    () => this.getRandomChoice(['yee', 'hmm', 'aaa']) + originalWord, // Sound prefix
                    () => originalWord.replace(/./g, c => Math.random() < 0.3 ? c.toUpperCase() : c) // Random caps
                ];

                const mutationType = mutations[Math.floor(Math.random() * mutations.length)];
                const mutatedWord = mutationType();

                // Mutasyonu kaydet
                if (!this.wordMutations.has(originalWord)) {
                    this.wordMutations.set(originalWord, new Set());
                }
                this.wordMutations.get(originalWord).add(mutatedWord);

                const noiseIndicator = randomNoise ? 'üé≤' : 'üß¨';
                console.log(`${noiseIndicator} ${bacteria.name} word mutation: ${originalWord} ‚Üí ${mutatedWord}`);
                return mutatedWord;
            }

            // üìà V8.9.0: Adaptive Style Reinforcement Learning
            adaptLanguageStyle(bacteria, wasSuccessful, context) {
                if (!bacteria.personalLanguageStyle) return;
                
                const style = bacteria.personalLanguageStyle;
                const adaptationRate = 0.02;
                
                if (wasSuccessful) {
                    // Reinforce successful traits
                    style.mutationRate = Math.min(1, style.mutationRate + adaptationRate);
                    style.slangProbability = Math.min(0.8, style.slangProbability + adaptationRate);
                    style.markovChainUsage = Math.min(1, style.markovChainUsage + adaptationRate);
                    
                    // Track success
                    const stats = this.adaptiveSuccess.get(bacteria.id);
                    if (stats) {
                        stats.successfulResponses++;
                        if (stats.contexts.has(context)) {
                            stats.contexts.get(context).successes++;
                        }
                    }
                    
                    console.log(`üìà ${bacteria.name} language style reinforced (success rate: ${((stats?.successfulResponses || 0) / (stats?.totalResponses || 1) * 100).toFixed(1)}%)`);
                } else {
                    // Reduce unsuccessful traits
                    style.mutationRate = Math.max(0, style.mutationRate - adaptationRate);
                    style.repetitionProbability = Math.max(0, style.repetitionProbability - adaptationRate);
                    style.absurdTolerance = Math.max(0, style.absurdTolerance - adaptationRate * 0.5);
                }
                
                // Update bigram map periodically
                if (Math.random() < 0.1) { // 10% chance to rebuild
                    this.updateBigramMap(bacteria, Array.from(bacteria.vocabulary));
                }
            }

            // üöÄ V8.9.0: REVOLUTIONARY ANTI-PATTERN CONTEXTUAL RESPONSE GENERATOR
            generateContextualResponse(bacteria, context, trigger = null) {
                const style = this.generatePersonalityLanguage(bacteria);
                const vocabulary = Array.from(bacteria.vocabulary);
                
                // üéØ STEP 1: CHECK CONTEXT OVERRIDES (Anti-Pattern Mechanism)
                const overrideResult = this.checkContextOverrides(bacteria, context);
                if (overrideResult) {
                    console.log(`üîÑ ${bacteria.name} context override: ${context} ‚Üí ${overrideResult.newContext}`);
                    context = overrideResult.newContext;
                    return overrideResult.response;
                }
                
                // üéØ STEP 2: Œµ-GREEDY PATTERN SELECTION (Randomness Layer)
                let selectedResponse;
                const epsilonGreedy = 0.6; // üî• V8.9.1 TEST: 60% chance for anti-pattern visibility
                
                if (Math.random() < epsilonGreedy) {
                    // üé≤ 60% CHANCE: COMPLETELY RANDOM, PATTERN-FREE RESPONSE
                    selectedResponse = this.generateRandomMarkovResponse(bacteria, vocabulary);
                    console.log(`üé≤ ANTI-PATTERN: ${bacteria.name} Œµ-greedy random response: ${selectedResponse}`);
                    console.log(`üî• PATTERN BREAKING ACHIEVED! Traditional templates bypassed.`);
                } else if (style.metaTemplatePreference && Math.random() < 0.7) {
                    // üé≠ 70% CHANCE: META-TEMPLATE RESPONSE (Pattern within Pattern) - BOOSTED FOR VISIBILITY
                    selectedResponse = this.generateMetaTemplateResponse(bacteria, context, vocabulary, trigger);
                    console.log(`üé≠ META-TEMPLATE: ${bacteria.name} complex pattern-within-pattern response`);
                    console.log(`üî• ADVANCED ANTI-PATTERN: Multi-layered response generated!`);
                } else if (style.markovChainUsage > 0.3 && Math.random() < style.markovChainUsage) {
                    // üîó MARKOV CHAIN RESPONSE (Statistical Word Flow)
                    selectedResponse = this.generateMarkovChainResponse(bacteria, vocabulary);
                    console.log(`üîó MARKOV CHAIN: ${bacteria.name} statistical word flow response`);
                    console.log(`üßÆ PATTERN-FREE: Using bigram probabilities instead of templates!`);
                } else {
                    // üéØ TRADITIONAL TEMPLATE-BASED (Enhanced with mutations)
                    selectedResponse = this.generateTraditionalResponse(bacteria, context, vocabulary, trigger);
                }
                
                // üé® STEP 3: APPLY PERSONALITY MUTATIONS
                selectedResponse = this.applyPersonalityMutations(selectedResponse, bacteria, style);
                
                // üé™ STEP 4: ADD ABSURD ELEMENTS (Shock Factor)
                if (Math.random() < style.absurdTolerance * 0.8) { // üî• V8.9.1 TEST: Up to 48% chance for visibility
                    selectedResponse = this.addAbsurdElement(selectedResponse, bacteria);
                }
                
                // üìà STEP 5: ADAPTIVE LEARNING (Success Tracking)
                this.trackResponseForAdaptation(bacteria, context, selectedResponse);
                
                return selectedResponse;
            }

            // üîÑ Context Override System - Breaking Patterns Based on State
            checkContextOverrides(bacteria, context) {
                for (const [overrideType, checkFunction] of this.contextOverrides.entries()) {
                    if (checkFunction(bacteria)) {
                        switch (overrideType) {
                            case 'high_stress':
                                return {
                                    newContext: 'stress_break',
                                    response: 'bu ne ya? ' + this.getRandomChoice(["hmm", "belki deƒüil", "bilmiyorum", "kafam karƒ±≈ütƒ±"]) + '...'
                                };
                            case 'confusion':
                                return {
                                    newContext: 'absurd_confusion',
                                    response: this.getRandomChoice(this.absurdWords) + ' ne demek? ' + this.getRandomChoice(Array.from(bacteria.vocabulary)) + '?!'
                                };
                            case 'creative_burst':
                                return {
                                    newContext: 'creative_explosion',
                                    response: this.generateRandomMarkovResponse(bacteria, Array.from(bacteria.vocabulary)) + ' ‚ú®üé®'
                                };
                            case 'random_chaos':
                                return {
                                    newContext: 'pure_chaos',
                                    response: this.getRandomChoice(this.absurdWords) + ' ' + 
                                             this.getRandomChoice(this.absurdWords) + ' ' +
                                             this.getRandomChoice(['!!!', '???', '!?!', '...']) + ' ü§™'
                                };
                        }
                    }
                }
                return null;
            }

            // üé≤ Generate Completely Random Markov-style Response
            generateRandomMarkovResponse(bacteria, vocabulary) {
                if (vocabulary.length < 2) return "yeni kelime √∂ƒürenmeliyim!";
                
                const responseLength = 2 + Math.floor(Math.random() * 3); // 2-4 words
                let response = [];
                
                for (let i = 0; i < responseLength; i++) {
                    const word = vocabulary[Math.floor(Math.random() * vocabulary.length)];
                    response.push(this.mutateWord(bacteria, word));
                }
                
                return response.join(' ');
            }

            // üîó Generate Markov Chain Response - Statistical Word Flow
            generateMarkovChainResponse(bacteria, vocabulary) {
                const bigramMap = this.bacteriaBigrams.get(bacteria.id);
                if (!bigramMap || bigramMap.size === 0) {
                    this.updateBigramMap(bacteria, vocabulary);
                    return this.generateRandomMarkovResponse(bacteria, vocabulary);
                }
                
                // Start with random word
                const startWords = Array.from(bigramMap.keys());
                let currentWord = startWords[Math.floor(Math.random() * startWords.length)];
                let sentence = [currentWord];
                
                // Generate 2-4 words using bigram probabilities
                for (let i = 0; i < 2 + Math.floor(Math.random() * 2); i++) {
                    const nextWords = bigramMap.get(currentWord);
                    if (!nextWords || nextWords.length === 0) {
                        nextWords = vocabulary; // Fallback to random vocabulary
                    }
                    const nextWord = nextWords[Math.floor(Math.random() * nextWords.length)];
                    sentence.push(nextWord);
                    currentWord = nextWord;
                }
                
                return sentence.join(' ');
            }

            // üé≠ Generate Meta-Template Response (Pattern within Pattern)
            generateMetaTemplateResponse(bacteria, context, vocabulary, trigger) {
                const metaTemplates = this.metaTemplates.get('complex_mix');
                const selectedMeta = metaTemplates[Math.floor(Math.random() * metaTemplates.length)];
                
                // Generate sub-templates
                const subTemplate1 = this.generateTraditionalResponse(bacteria, context, vocabulary, trigger);
                const subTemplate2 = this.generateRandomMarkovResponse(bacteria, vocabulary);
                
                const replacements = {
                    '{greeting}': this.getRandomChoice(['merhaba', 'selam', 'hey', bacteria.name]),
                    '{subTemplate1}': subTemplate1,
                    '{subTemplate2}': subTemplate2,
                    '{subject}': bacteria.name,
                    '{reaction}': this.getRandomChoice(['ilgin√ß', 'garip', 'harika', '≈üa≈üƒ±rtƒ±cƒ±']),
                    '{shock_element}': this.getRandomChoice(this.absurdWords)
                };
                
                let result = selectedMeta;
                Object.keys(replacements).forEach(placeholder => {
                    result = result.replace(new RegExp(placeholder, 'g'), replacements[placeholder]);
                });
                
                return result;
            }

            // üéØ Generate Traditional Response (Enhanced)
            generateTraditionalResponse(bacteria, context, vocabulary, trigger) {
                const style = this.generatePersonalityLanguage(bacteria);
                
                // Baƒülamsal kalƒ±p se√ß
                const patterns = this.contextualPhrases.get(context) || ["{learned_word} {emotion}"];
                let selectedPattern = patterns[Math.floor(Math.random() * patterns.length)];

                // Ki≈üisel kalƒ±plarƒ± kontrol et
                if (style.phrasePatterns.has(context)) {
                    const personalPatterns = Array.from(style.phrasePatterns.get(context));
                    if (personalPatterns.length > 0 && Math.random() < 0.6) {
                        selectedPattern = personalPatterns[Math.floor(Math.random() * personalPatterns.length)];
                    }
                }

                return this.fillDynamicPattern(selectedPattern, bacteria, vocabulary, trigger);
            }

            // üé® Apply Personality Mutations to Response
            applyPersonalityMutations(response, bacteria, style) {
                let mutatedResponse = response;
                
                // Add slang/informal words
                if (Math.random() < style.slangProbability) {
                    const slangs = ['yaa', 'hadiiii', 'of be', 'valla', 'ama ya', 'i≈üte'];
                    mutatedResponse = this.getRandomChoice(slangs) + ' ' + mutatedResponse;
                }
                
                // Add word repetition
                if (Math.random() < style.repetitionProbability) {
                    const words = mutatedResponse.split(' ');
                    if (words.length > 1) {
                        const idx = Math.floor(Math.random() * words.length);
                        words.splice(idx, 0, words[idx]); // Duplicate word
                        mutatedResponse = words.join(' ');
                    }
                }
                
                // Add punctuation style
                mutatedResponse += style.punctuationStyle;
                
                return mutatedResponse;
            }

            // üé™ Add Absurd Element (Shock Factor)
            addAbsurdElement(response, bacteria) {
                const words = response.split(' ');
                const absurdWord = this.getRandomChoice(this.absurdWords);
                
                if (words.length >= 2) {
                    // Insert absurd word in the middle
                    const insertPos = 1 + Math.floor(Math.random() * (words.length - 1));
                    words.splice(insertPos, 0, absurdWord);
                    console.log(`üé™ ${bacteria.name} added absurd element: ${absurdWord}`);
                }
                
                return words.join(' ');
            }

            // üìà Track Response for Adaptive Learning
            trackResponseForAdaptation(bacteria, context, response) {
                if (!this.adaptiveSuccess.has(bacteria.id)) {
                    this.adaptiveSuccess.set(bacteria.id, { 
                        totalResponses: 0, 
                        successfulResponses: 0,
                        contexts: new Map()
                    });
                }
                
                const stats = this.adaptiveSuccess.get(bacteria.id);
                stats.totalResponses++;
                
                if (!stats.contexts.has(context)) {
                    stats.contexts.set(context, { attempts: 0, successes: 0 });
                }
                stats.contexts.get(context).attempts++;
                
                // Success will be updated by reaction system
            }

            // üßÆ Update Bigram Map for Markov Chains
            updateBigramMap(bacteria, vocabulary) {
                const bigramMap = this.bacteriaBigrams.get(bacteria.id);
                
                // Build bigrams from vocabulary and memory
                for (let i = 0; i < vocabulary.length - 1; i++) {
                    const word1 = vocabulary[i];
                    const word2 = vocabulary[i + 1];
                    
                    if (!bigramMap.has(word1)) {
                        bigramMap.set(word1, []);
                    }
                    bigramMap.get(word1).push(word2);
                }
                
                // Add some random connections for diversity
                vocabulary.forEach(word => {
                    if (Math.random() < 0.1) { // 10% chance
                        const randomWord = vocabulary[Math.floor(Math.random() * vocabulary.length)];
                        if (!bigramMap.has(word)) {
                            bigramMap.set(word, []);
                        }
                        bigramMap.get(word).push(randomWord);
                    }
                });
            }

            // üé≤ Utility: Get Random Choice
            getRandomChoice(array) {
                return array[Math.floor(Math.random() * array.length)];
            }

            fillDynamicPattern(pattern, bacteria, vocabulary, trigger) {
                const style = this.generatePersonalityLanguage(bacteria);
                
                const replacements = {
                    '{subject}': bacteria.name,
                    '{emotion}': this.getPersonalityEmotion(bacteria),
                    '{learned_word}': vocabulary[Math.floor(Math.random() * vocabulary.length)] || 'kelime',
                    '{surprise_word}': this.mutateWord(bacteria, vocabulary[Math.floor(Math.random() * vocabulary.length)] || '≈üa≈üƒ±rtƒ±cƒ±'),
                    '{reaction}': ['waow', 's√ºper', 'ilgin√ß', 'harika', 'vay be'][Math.floor(Math.random() * 5)],
                    '{confusion_word}': ['hmm', 'ne', 'nasƒ±l', 'niye', 'acaba'][Math.floor(Math.random() * 5)],
                    '{unknown_word}': vocabulary[Math.floor(Math.random() * vocabulary.length)] || 'bilinmeyen',
                    '{friend_name}': trigger?.name || 'arkada≈ü',
                    '{activity}': vocabulary.filter(w => ['hareket', '√∂ƒürenme', 'ke≈üif', 'oyun'].includes(w))[0] || 'aktivite',
                    '{target}': trigger?.name || 'sen',
                    '{discovery}': vocabulary[Math.floor(Math.random() * vocabulary.length)] || 'ke≈üif'
                };

                let result = pattern;
                Object.keys(replacements).forEach(placeholder => {
                    result = result.replace(new RegExp(placeholder, 'g'), replacements[placeholder]);
                });

                return result;
            }

            getPersonalityEmotion(bacteria) {
                const emotions = {
                    high_optimism: ['üòä', 'üéâ', '‚ú®', 'harika', 's√ºper'],
                    medium_optimism: ['üòå', 'üëç', 'g√ºzel', 'iyi'],
                    low_optimism: ['üòê', 'hmm', '≈üey'],
                    high_humor: ['üòÇ', 'ü§£', 'haha', 'komik'],
                    high_social: ['ü§ó', 'üí´', 'arkada≈ü', 'birlikte']
                };

                if (bacteria.personality_traits.optimism > 0.7) {
                    return emotions.high_optimism[Math.floor(Math.random() * emotions.high_optimism.length)];
                } else if (bacteria.personality_traits.humor > 0.7) {
                    return emotions.high_humor[Math.floor(Math.random() * emotions.high_humor.length)];
                } else if (bacteria.personality_traits.sociability > 0.7) {
                    return emotions.high_social[Math.floor(Math.random() * emotions.high_social.length)];
                } else if (bacteria.personality_traits.optimism > 0.4) {
                    return emotions.medium_optimism[Math.floor(Math.random() * emotions.medium_optimism.length)];
                } else {
                    return emotions.low_optimism[Math.floor(Math.random() * emotions.low_optimism.length)];
                }
            }

            // Yeni kalƒ±p √∂ƒürenme
            learnNewPattern(bacteria, context, newPattern) {
                const style = this.generatePersonalityLanguage(bacteria);
                
                if (!style.phrasePatterns.has(context)) {
                    style.phrasePatterns.set(context, new Set());
                }
                
                // Basitle≈ütirilmi≈ü kalƒ±p √ßƒ±karma
                const generalizedPattern = newPattern
                    .replace(bacteria.name, '{subject}')
                    .replace(/üòä|üéâ|‚ú®|üòÇ|ü§£|üòê|hmm/g, '{emotion}')
                    .replace(/\b[a-z√ßƒüƒ±√∂≈ü√º]+\b/gi, (match) => {
                        if (bacteria.vocabulary.has(match)) return '{learned_word}';
                        return match;
                    });

                style.phrasePatterns.get(context).add(generalizedPattern);
                
                console.log(`üß† ${bacteria.name} learned new pattern for ${context}: ${generalizedPattern}`);
            }

            // Sosyal dil √∂ƒürenimi - bakteriler birbirinden √∂ƒürenir
            shareLinguisticFeature(speaker, listener, phrase) {
                if (!speaker.personalLanguageStyle || !listener.personalLanguageStyle) return;

                // %20 ≈üansla dinleyici konu≈ümacƒ±nƒ±n tarzƒ±nƒ± benimser
                if (Math.random() < 0.2) {
                    const speakerStyle = speaker.personalLanguageStyle;
                    const listenerStyle = listener.personalLanguageStyle;

                    // Kelime sƒ±rasƒ± etkile≈üimi
                    if (speakerStyle.wordOrder !== listenerStyle.wordOrder && Math.random() < 0.5) {
                        listenerStyle.wordOrder = speakerStyle.wordOrder;
                        console.log(`üîÑ ${listener.name} adopted word order from ${speaker.name}: ${speakerStyle.wordOrder}`);
                    }

                    // Mutasyon oranƒ± etkile≈üimi
                    listenerStyle.mutationRate = (listenerStyle.mutationRate + speakerStyle.mutationRate) / 2;

                    // Benzersiz kelime payla≈üƒ±mƒ±
                    if (speakerStyle.uniqueWords.size > 0) {
                        const sharedWord = Array.from(speakerStyle.uniqueWords)[0];
                        listenerStyle.uniqueWords.add(sharedWord);
                        listener.vocabulary.add(sharedWord);
                    }
                }
            }

            // Dil evrimi istatistikleri
            getLanguageEvolutionStats() {
                return {
                    totalMutations: this.wordMutations.size,
                    uniquePatterns: Array.from(this.contextualPhrases.values()).flat().length,
                    generation: this.languageGeneration,
                    emergentGrammarRules: this.emergentGrammar.size
                };
            }
        }

        // Global Language Evolution Engine
        let languageEvolutionEngine = null;

        // üìö 1500 Kelimelik Kategorize ≈ûablon + TabPFN Hƒ±zlandƒ±rma
        const MASTER_VOCABULARY = {
            // Temel D√ºzey (Consciousness 0-1) - 300 kelime
            basic: [
                // Temel ihtiya√ßlar (50 kelime)
                'a√ß', 'tok', 'yardƒ±m', 'hareket', 'dinlen', 'uyu', 'uyan', 'nefes', 'kalp', 'v√ºcut',
                'el', 'ayak', 'g√∂z', 'kulak', 'aƒüƒ±z', 'burun', 'kafa', 'beden', 'can', 'hayat',
                'su', 'yemek', 'ekmek', 's√ºt', 'meyve', 'et', 'balƒ±k', 'sebze', 'tatlƒ±', 'acƒ±',
                'sƒ±cak', 'soƒüuk', 'ƒ±sƒ±', 'r√ºzgar', 'g√ºne≈ü', 'ay', 'yƒ±ldƒ±z', 'gece', 'g√ºnd√ºz', 'sabah',
                '√∂ƒüle', 'ak≈üam', 'zaman', 'dakika', 'saat', 'g√ºn', 'hafta', 'ay', 'yƒ±l', 'ya≈ü',
                
                // Duygular (50 kelime)
                'mutlu', '√ºzg√ºn', 'kƒ±zgƒ±n', 'korku', 'endi≈üe', 'heyecan', '≈üa≈üƒ±rma', 'merak', 'sevin√ß', '√ºz√ºnt√º',
                '√∂fke', 'kƒ±skan√ßlƒ±k', 'gurur', 'utan√ß', 'pi≈ümanlƒ±k', 'umut', 'hayal', 'r√ºya', 'd√º≈ü', 'fikir',
                'sevgi', 'a≈ük', 'dostluk', 'saygƒ±', 'g√ºven', 'inan√ß', '≈ü√ºphe', 'kaygƒ±', 'stres', 'rahat',
                'huzur', 'barƒ±≈ü', 'sava≈ü', 'kavga', 'tartƒ±≈üma', 'anla≈üma', 'uzla≈üma', '√ß√∂z√ºm', 'sorun', 'sƒ±kƒ±ntƒ±',
                'zorluk', 'kolay', 'zor', 'basit', 'karma≈üƒ±k', 'anla≈üƒ±lƒ±r', 'belirsiz', 'net', 'a√ßƒ±k', 'kapalƒ±',
                
                // Temel eylemler (50 kelime)
                'git', 'gel', 'ko≈ü', 'y√ºr√º', 'dur', 'otur', 'kalk', 'yat', '√ßƒ±k', 'gir',
                'al', 'ver', 'bƒ±rak', 'tut', 'at', '√ßek', 'it', 'kaldƒ±r', 'indir', 'ta≈üƒ±',
                'yap', 'boz', 'kur', 'yƒ±k', 'temizle', 'kirlet', 'a√ß', 'kapat', 'ba≈üla', 'bitir',
                'devam', 'kes', 'b√∂l', 'birle≈ütir', 'ayƒ±r', 'topla', '√ßƒ±kar', '√ßarp', 'b√∂l', 'say',
                'oku', 'yaz', '√ßiz', 'boya', 'sil', 'd√ºzelt', 'deƒüi≈ütir', 'koru', 'sav', 'ka√ßƒ±n',
                
                // Renkler ve ≈üekiller (30 kelime)
                'kƒ±rmƒ±zƒ±', 'mavi', 'ye≈üil', 'sarƒ±', 'turuncu', 'mor', 'pembe', 'beyaz', 'siyah', 'gri',
                'kahverengi', 'altƒ±n', 'g√ºm√º≈ü', 'renk', 'parlak', 'mat', '≈üeffaf', 'opak', 'ƒ±≈üƒ±k', 'karanlƒ±k',
                'yuvarlak', 'kare', '√º√ßgen', 'dikd√∂rtgen', 'oval', 'd√ºz', 'eƒüri', 'uzun', 'kƒ±sa', 'geni≈ü',
                
                // Sayƒ±lar ve matematik (30 kelime)
                'bir', 'iki', '√º√ß', 'd√∂rt', 'be≈ü', 'altƒ±', 'yedi', 'sekiz', 'dokuz', 'on',
                'yirmi', 'otuz', 'kƒ±rk', 'elli', 'y√ºz', 'bin', 'milyon', 'sƒ±fƒ±r', 'hi√ß', '√ßok',
                'az', 'fazla', 'eksik', 'tam', 'yarƒ±m', '√ßeyrek', '√º√ßte', 'b√ºy√ºk', 'k√º√ß√ºk', 'orta',
                
                // Aile ve sosyal (40 kelime)
                'anne', 'baba', '√ßocuk', 'karde≈ü', 'abla', 'aƒüabey', 'dede', 'nine', 'teyze', 'amca',
                'dayƒ±', 'hala', 'kuzen', 'arkada≈ü', 'dost', 'kom≈üu', '√∂ƒüretmen', 'doktor', 'hem≈üire', 'polis',
                'itfaiye', 'pilot', '≈üof√∂r', 'kasap', 'berber', 'terzi', 'bakkal', 'eczacƒ±', 'avukat', 'm√ºhendis',
                'i≈ü√ßi', 'patron', 'm√ºd√ºr', 'ba≈ükan', 'lider', 'takip√ßi', 'grup', 'takƒ±m', 'ekip', 'toplum'
            ],
            
            // Sosyal D√ºzey (Consciousness 1-5) - 400 kelime  
            social: [
                // ƒ∞leti≈üim (100 kelime)
                'merhaba', 'g√ºnaydƒ±n', 'iyi ak≈üamlar', 'ho≈ü√ßa kal', 'g√∂r√º≈ü√ºr√ºz', 'te≈üekk√ºrler', 'rica ederim', '√∂z√ºr dilerim', 'pardon', 'kusura bakma',
                'konu≈ü', 'dinle', 'anlat', 'sor', 'cevap', 'soru', 'yanƒ±t', 'a√ßƒ±kla', 'tarif', 'g√∂ster',
                'i≈üaret', 'ima', 'jest', 'mimik', 'ses', 'ton', 'vurgu', 'melodei', 'ritim', 'sessizlik',
                'g√ºl√ºmseme', 'kahkaha', 'aƒülama', '√ßƒ±ƒülƒ±k', 'fƒ±sƒ±lda', 'baƒüƒ±r', '≈üarkƒ±', 'm√ºzik', 'dans', 'oyun',
                'eƒülence', 'parti', 'kutlama', 'doƒüum g√ºn√º', 'bayram', 'tatil', 'festival', '≈üenlik', 'toplantƒ±', 'bulu≈üma',
                'randevu', 'g√∂r√º≈üme', 'sohbet', 'chat', 'mesaj', 'mektup', 'telefon', 'internet', 'sosyal medya', 'payla≈üƒ±m',
                'beƒüeni', 'yorum', 'ele≈ütiri', '√∂vg√º', 'takdir', 'hayranlƒ±k', 'kƒ±skan√ßlƒ±k', 'rekabet', 'yarƒ±≈ü', 'kazanma',
                'kaybetme', 'ba≈üarƒ±', 'ba≈üarƒ±sƒ±zlƒ±k', 'deneme', '√ßaba', 'emek', '√ßalƒ±≈üma', 'dinlenme', 'tatil', 'gezi',
                'macera', 'ke≈üif', 'ara≈ütƒ±rma', 'inceleme', 'g√∂zlem', 'izleme', 'takip', 'analiz', 'deƒüerlendirme', 'karar',
                'se√ßim', 'tercih', '√∂ncelik', '√∂nem', 'deƒüer', 'kƒ±ymet', 'fiyat', 'maliyet', 'kazan√ß', 'gelir',
                
                // Duygusal zeka (100 kelime)
                'empati', 'anlayƒ±≈ü', 'ho≈üg√∂r√º', 'sabƒ±r', 'dayanƒ±klƒ±lƒ±k', 'cesaret', 'korkaklƒ±k', 'atƒ±lgan', '√ßekingen', 'sosyal',
                'asosyal', 'ekstrovert', 'introvert', 'ne≈üeli', 'melankolik', 'iyimser', 'karamsar', 'realist', 'idealist', 'pragmatik',
                'romantik', 'mantƒ±klƒ±', 'duygusal', 'rasyonel', 'irrasyonel', 'objektif', 'subjektif', 'tarafsƒ±z', '√∂nyargƒ±lƒ±', 'adil',
                'haksƒ±z', 'd√ºr√ºst', 'yalancƒ±', 'samimi', 'sahte', 'i√ßten', 'dƒ±≈üardan', 'a√ßƒ±k', 'gizli', '≈üeffaf',
                'kapalƒ±', 'gizemli', 'anla≈üƒ±labilir', 'karma≈üƒ±k', 'basit', 'sade', 's√ºsl√º', 'g√∂steri≈üli', 'm√ºtevazƒ±', 'kibirli',
                'al√ßakg√∂n√ºll√º', 'gururlu', 'utanga√ß', '√ßekinmez', 'kendine g√ºvenen', 'g√ºvensiz', 'kararlƒ±', 'kararsƒ±z', 'istikrarlƒ±', 'deƒüi≈üken',
                'tutarlƒ±', 'tutarsƒ±z', 'g√ºvenilir', 'g√ºvenilmez', 'sadƒ±k', 'vefasƒ±z', 'baƒülƒ±', 'baƒüƒ±msƒ±z', '√∂zg√ºr', 'esir',
                'h√ºr', 'k√∂le', 'efendi', 'hizmetkar', 'lider', 'takip√ßi', 'y√∂neten', 'y√∂netilen', 'aktif', 'pasif',
                'giri≈üken', 'miskin', '√ßalƒ±≈ükan', 'tembel', 'hƒ±zlƒ±', 'yava≈ü', 'aceleci', 'sabƒ±rlƒ±', 'titiz', 'daƒüƒ±nƒ±k',
                'd√ºzenli', 'disiplinli', 'serbest', 'kontroll√º', 'kendiliƒüinden', 'bilin√ßli', 'bilin√ßsiz', 'farkƒ±nda', 'habersiz', 'uyanƒ±k',
                
                // ƒ∞li≈ükiler (100 kelime)
                'sevgili', 'e≈ü', 'ni≈üanlƒ±', 'fl√∂rt', 'bu√ßuk', 'yalnƒ±z', 'bekar', 'evli', 'bo≈üanmƒ±≈ü', 'dul',
                'yakƒ±n', 'uzak', 'samimi', 'soƒüuk', 'sƒ±cak', 'mesafeli', 'yakƒ±nla≈üma', 'uzakla≈üma', 'bulu≈üma', 'ayrƒ±lma',
                'kavu≈üma', 'hasret', '√∂zlem', 'ayrƒ±lƒ±k', 'veda', 'ho≈ü√ßa kal', 'elveda', 'g√ºle g√ºle', 'yolculuk', 'd√∂n√º≈ü',
                'varƒ±≈ü', 'gidi≈ü', 'geli≈ügit', 'ilerleme', 'gerileme', 'geli≈üme', 'b√ºy√ºme', 'k√º√ß√ºlme', 'artma', 'azalma',
                '√ßoƒüalma', 'eksilme', 'deƒüi≈üme', 'd√∂n√º≈ü√ºm', 'evrim', 'devrim', 'yenilik', 'eskime', 'k√∂hneme', 'yenileme',
                'tazeleme', 'canlanma', '√∂lme', 'ya≈üama', 'hayat', '√∂l√ºm', 'doƒüum', 'b√ºy√ºme', 'ya≈ülanma', 'gen√ßlik',
                '√ßocukluk', 'ergenlik', 'yeti≈ükinlik', 'olgunluk', 'deneyim', 'tecr√ºbe', 'bilgi', 'bilim', '√∂ƒürenme', '√∂ƒüretme',
                'eƒüitim', '√∂ƒüretim', 'ders', 'kurs', 'seminer', 'konferans', 'toplantƒ±', 'panel', 'tartƒ±≈üma', 'm√ºnazara',
                'sohbet', 'muhabbet', 'dedikodu', 's√∂ylenti', 'rivayet', 'hikaye', 'masal', 'efsane', 'mit', 'ger√ßek',
                'hayal', 'd√º≈ü', 'r√ºya', 'kabus', '√ºmit', 'beklenti', 'plan', 'proje', 'hedef', 'ama√ß',
                
                // K√ºlt√ºr ve deƒüerler (100 kelime)
                'gelenek', 'g√∂renek', 'adet', '√∂rf', 'k√ºlt√ºr', 'medeniyet', 'uygarlƒ±k', 'sanat', 'edebiyat', '≈üiir',
                'roman', 'hikaye', 'tiyatro', 'sinema', 'film', 'dizi', 'program', 'haber', 'gazete', 'dergi',
                'kitap', 'sayfa', 'paragraf', 'c√ºmle', 'kelime', 'harf', 'nokta', 'virg√ºl', 'soru i≈üareti', '√ºnlem',
                'alfabe', 'dil', 'leh√ße', 'aƒüƒ±z', '≈üive', 'aksant', 'tonlama', 'telaffuz', 'diksiyon', 'gramer',
                's√∂zdizimi', 'morfoloji', 'fonetik', 'etimoloji', 'semantik', 'pragmatik', 'dilbilim', '√ßevirmen', 'terc√ºman', 's√∂zl√ºk',
                'ansiklopedi', 'atlƒ±s', 'rehber', 'kƒ±lavuz', 'manual', 'bro≈ü√ºr', 'katalog', 'liste', '√ßizelge', 'tablo',
                'grafik', 'diagram', 'harita', 'plan', 'kroki', '√ßizim', 'resim', 'fotoƒüraf', 'g√∂r√ºnt√º', 'g√∂rsel',
                'ses', 'm√ºzik', 'melodi', 'ritim', 'tempo', 'nota', 'beste', 'besteci', 'm√ºzisyen', 'sanat√ßƒ±',
                'ressam', 'heykeltƒ±ra≈ü', 'mimar', 'tasarƒ±mcƒ±', 'moda', 'stil', 'trend', 'zevk', 'estetik', 'g√ºzellik',
                '√ßirkinlik', 'ho≈ü', 'naho≈ü', 'beƒüeni', 'ele≈ütiri', 'yorum', 'g√∂r√º≈ü', 'fikir', 'd√º≈ü√ºnce', 'inan√ß'
            ],
            
            // Bilimsel D√ºzey (Consciousness 5-10) - 400 kelime
            scientific: [
                // Biyoloji ve ya≈üam (150 kelime)
                'ATP', 'metabolizma', 'enzim', 'protein', 'amino asit', 'karbonhidrat', 'lipid', 'n√ºkleik asit', 'DNA', 'RNA',
                'gen', 'kromozom', 'h√ºcre', '√ßekirdek', 'sitoplazma', 'organel', 'mitokondri', 'ribozom', 'lizozom', 'vakuol',
                'endoplazmik retikulum', 'golgi aygƒ±tƒ±', 'sentrozom', 'sitoiskelet', 'h√ºcre zarƒ±', 'h√ºcre duvarƒ±', 'kloroplast', 'fotosentez', 'solunum', 'fermantasyon',
                'glikoliz', 'krebs d√∂ng√ºs√º', 'elektron ta≈üƒ±ma zinciri', 'oksitlenme', 'indirgeme', 'redoks', 'kataliz√∂r', 'substrat', '√ºr√ºn', 'reaksiyon',
                'biyokimya', 'molek√ºler biyoloji', 'h√ºcre biyolojisi', 'genetik', 'evrim', 'doƒüal se√ßilim', 'mutasyon', 'adaptasyon', 'spesiyasyon', 'biyo√ße≈üitlilik',
                'ekoloji', 'ekosistem', 'habitat', 'ni≈ü', 'populasyon', 'topluluk', 'besin zinciri', 'besin aƒüƒ±', 'enerji akƒ±≈üƒ±', 'besin d√∂ng√ºs√º',
                'karbon d√∂ng√ºs√º', 'nitrojen d√∂ng√ºs√º', 'oksijen d√∂ng√ºs√º', 'su d√∂ng√ºs√º', 'iklim', 'hava durumu', 'atmosfer', 'hidrosfer', 'litosfer', 'biyosfer',
                'biyom', 'orman', '√ßayƒ±r', '√ß√∂l', 'tundra', 'savana', 'sulak alan', 'okyanus', 'deniz', 'g√∂l',
                'nehir', 'dere', 'kaynak', 'yeraltƒ± suyu', 'buzul', 'kar', 'yaƒümur', 'buhar', 'nem', 'sƒ±caklƒ±k',
                'basƒ±n√ß', 'r√ºzgar', 'fƒ±rtƒ±na', 'kasƒ±rga', 'tornado', 'deprem', 'volkan', 'tsunami', 'sel', 'kuraklƒ±k',
                'k√ºresel ƒ±sƒ±nma', 'iklim deƒüi≈üikliƒüi', 'sera etkisi', 'ozon tabakasƒ±', 'kirlilik', 'geri d√∂n√º≈ü√ºm', 's√ºrd√ºr√ºlebilirlik', 'yenilenebilir enerji', 'fosil yakƒ±t', 'n√ºkleer enerji',
                'mikroorganizma', 'bakteri', 'vir√ºs', 'mantar', 'protozoa', 'alg', 'bitki', 'hayvan', 'omurgalƒ±', 'omurgasƒ±z',
                'memeli', 'ku≈ü', 's√ºr√ºngen', 'amfibi', 'balƒ±k', 'b√∂cek', 'artropod', 'yumu≈üak√ßa', 'solucan', 'zooplankton',
                'fitoplankton', 'bentik', 'pelagik', 'litorel', 'derin deniz', 'abissal', 'hadal', 'biyol√ºminesans', 'kamuflaj', 'mimikri',
                'simbioz', 'mutualizma', 'komensalizm', 'parazitizm', 'predasyon', 'otobur', 'etobur', 'hep√ßil', 'detritivor', 'dekompozit√∂r'
            ],
            
            // Fizik ve kimya (150 kelime)
            physics: [
                'atom', 'elektron', 'proton', 'n√∂tron', 'kuark', 'lepton', 'bozon', 'fermiyon', 'par√ßacƒ±k', 'dalga',
                'enerji', 'k√ºtle', 'kuvvet', 'ivme', 'hƒ±z', 'hƒ±zlanma', 'momentum', 'tork', 'a√ßƒ±sal momentum', 'inersia',
                's√ºrt√ºnme', 'yer√ßekimi', 'elektromanyetizma', 'g√º√ßl√º n√ºkleer kuvvet', 'zayƒ±f n√ºkleer kuvvet', 'alan', 'potansiyel', 'kinetik', 'termodinamik', 'entropi',
                'entalpi', 'i√ß enerji', 'ƒ±sƒ± kapasitesi', 'ƒ±sƒ± iletimi', 'konveksiyon', 'radyasyon', 'sƒ±caklƒ±k', 'basƒ±n√ß', 'hacim', 'yoƒüunluk',
                'faz', 'katƒ±', 'sƒ±vƒ±', 'gaz', 'plazma', 'bose-einstein kondensatƒ±', 'kristal', 'amorf', '√ß√∂zelti', 's√ºspansiyon',
                'em√ºlsiyon', 'koloid', 'mol', 'avogadro sayƒ±sƒ±', 'atomik k√ºtle', 'molek√ºler k√ºtle', 'periyodik tablo', 'element', 'bile≈üik', 'karƒ±≈üƒ±m',
                'kimyasal baƒü', 'kovalent', 'iyonik', 'metalik', 'hidrojen baƒüƒ±', 'van der waals', 'polar', 'apolar', 'hidrofilik', 'hidrofobik',
                'asit', 'baz', 'pH', 'tampon', 'titrasyons', 'redoks', 'oksidasyon', 'red√ºksiyon', 'elektroliz', 'galvanik h√ºcre',
                'kataliz√∂r', 'aktivasyon enerjisi', 'reaksiyon hƒ±zƒ±', 'denge', 'le chatelier ilkesi', 'konsantrasyon', 'molarite', 'molalite', 'normalite', '√ß√∂z√ºn√ºrl√ºk',
                '√ß√∂kme', 'kristalle≈üme', 'buharla≈üma', 'yoƒüu≈üma', 'sublimle≈üme', 'erime', 'donma', 'kaynama', 'ergime noktasƒ±', 'kaynama noktasƒ±',
                'ƒ±≈üƒ±k', 'elektromanyetik spektrum', 'g√∂r√ºn√ºr ƒ±≈üƒ±k', 'kƒ±zƒ±l√∂tesi', 'ultraviyole', 'r√∂ntgen', 'gama ƒ±≈üƒ±nƒ±', 'radyo dalgasƒ±', 'mikrodalga', 'frekans',
                'dalga boyu', 'genlik', 'interferans', 'kƒ±rƒ±nƒ±m', 'polarizasyon', 'yansƒ±ma', 'kƒ±rƒ±lma', 'lenz', 'lens', 'prizma',
                'ayna', 'mikroskop', 'teleskop', 'laser', 'hologram', 'fiber optik', 'spektroskopi', 'fotol√ºminesans', 'fosforesan', 'fl√ºoresan',
                'elektrik', 'akƒ±m', 'voltaj', 'diren√ß', 'kapasit√∂r', 'end√ºkt√∂r', 'transformat√∂r', 'diyot', 'transist√∂r', 'entegre devre',
                'manyetik alan', 'elektrik alan', 'elektromanyetik ind√ºksiyon', 'faraday yasasƒ±', 'ampere yasasƒ±', 'gauss yasasƒ±', 'maxwell denklemleri', 'kuantum mekaniƒüi', 'heisenberg belirsizlik', 'schr√∂dinger denklemi'
            ],
            
            // Matematik ve mantƒ±k (100 kelime)
            mathematics: [
                'sayƒ±', 'rakam', 'digit', 'basamak', 'pozitif', 'negatif', 'sƒ±fƒ±r', 'sonsuz', 'reel', 'sanal',
                'kompleks', 'rasyonel', 'irrasyonel', 'tam sayƒ±', 'doƒüal sayƒ±', 'asal sayƒ±', '√ßift', 'tek', 'fakt√∂riyel', 'kombinasyon',
                'perm√ºtasyon', 'olasƒ±lƒ±k', 'istatistik', 'ortalama', 'medyan', 'mod', 'standart sapma', 'varyans', 'korelasyon', 'regresyon',
                'grafik', 'koordinat', 'eksren', 'absis', 'ordinat', 'nokta', 'doƒüru', 'eƒüri', 'parabol', 'hiperbol',
                'elips', '√ßember', 'daire', 'yarƒ±√ßap', '√ßap', '√ßevre', 'alan', 'hacim', 'y√ºzey', 'kenar',
                'k√∂≈üe', 'a√ßƒ±', 'derece', 'radyan', 'trigonometri', 'sin√ºs', 'kosin√ºs', 'tanjant', 'kotanjant', 'sekant',
                'kosekant', 'logaritma', '√ºs', 'k√∂k', 'mutlak deƒüer', 't√ºrev', 'integral', 'limit', 's√ºreklilik', 'diferansiyel',
                'kƒ±smi t√ºrev', '√ßoklu integral', 'vekt√∂r', 'skaler', 'matris', 'determinant', '√∂zvekt√∂r', '√∂zdeƒüer', 'lineer d√∂n√º≈ü√ºm', 'izd√º≈ü√ºm',
                'topoloji', 'metrik', 'norm', 'i√ß √ßarpƒ±m', 'dƒ±≈ü √ßarpƒ±m', 'gradyan', 'diverjans', 'rotasyonel', 'laplacian', 'harmonik',
                'fourier d√∂n√º≈ü√ºm√º', 'konvol√ºsyon', 'fraktal', 'kaos teorisi', 'grup teorisi', 'halka', 'cisim', 'mod√ºler aritmetik', 'sayƒ± teorisi', 'kriptografi'
            ],
            
            // Felsefe ve Meta-bili≈üsel (Consciousness 10-20) - 300 kelime
            philosophical: [
                // Bilgi teorisi ve epistemoloji (100 kelime)
                'epistemoloji', 'ontoloji', 'metafizik', 'fenomenoloji', 'hermeneutik', 'diyalektik', 'empirizm', 'rasyonalizm', 'pozitivizm', 'pragmatizm',
                'varolu≈ü√ßuluk', 'nihilizm', 'abs√ºrdizm', 'determinizm', '√∂zg√ºr irade', 'kausalite', 'neden-sonu√ß', 'tesad√ºf', 'olasƒ±lƒ±k', 'belirsizlik',
                'bilgi', 'inan√ß', 'doƒüruluk', 'yanlƒ±≈ülƒ±k', 'kesinlik', '≈ü√ºphe', 'skepitizm', 'dogmatizm', 'relativizm', 'objektivite',
                'subjektivite', 'perspektif', 'bakƒ±≈ü a√ßƒ±sƒ±', 'yorumlama', 'anlama', 'kavrama', 'idrak', 'algƒ±', 'bilin√ß', 'farkƒ±ndalƒ±k',
                '√∂z-bilin√ß', 'meta-kognisyon', 'introspeksiyon', 'refeksiyon', 'd≈ü√ºnme', 'akƒ±l', 'mantƒ±k', 'neden', 'analiz', 'sentez',
                'tez', 'antitez', 'sƒ±nƒ±flama', 'kategorizasyon', 'soyutlama', 'somutlama', 'genelleme', '√∂zelle≈ütirme', 'analoji', 'metafor',
                'sembol', 'i≈üaret', 'anlam', 'semantik', 'pragmatik', 's√∂zdizimi', 'dil felsefesi', 'tanƒ±m', 'kavram', 'fikir',
                'd√º≈ü√ºnce', 'zihin', 'ruh', 'tin', 'psi≈üe', 'ego', 'id', 's√ºperego', 'bilin√ßaltƒ±', 'kolektif bilin√ßaltƒ±',
                'arketip', 'persona', 'g√∂lge', 'anima', 'animus', 'bireyselle≈üme', 'transsendans', 'a≈ükƒ±nlƒ±k', 'i√ßkinlik', 'absolute',
                'g√∂receli', 'baƒüƒ±l', 'mutlak', 'sonsuz', 'sonlu', 'sƒ±nƒ±r', 'sƒ±nƒ±rsƒ±z', 'paradoks', '√ßeli≈üki', 'tezat'
            ],
            
            // Etik ve deƒüerler (100 kelime)
            ethics: [
                'etik', 'ahlak', 'deƒüer', 'norm', 'kural', 'ilke', 'prensip', 'ideal', 'virtue', 'erdem',
                'iyilik', 'k√∂t√ºl√ºk', 'doƒüru', 'yanlƒ±≈ü', 'adalet', 'haksƒ±zlƒ±k', 'e≈üitlik', '√∂zg√ºrl√ºk', 'sorumluluk', 'g√∂rev',
                'hak', '√∂dev', 'y√ºk√ºml√ºl√ºk', 'vicdan', 'ahlaki', 'vicdani', 'utilitarizm', 'deontoloji', 'virtue etiƒüi', 'care etiƒüi',
                'feminist etik', '√ßevre etiƒüi', 'biyoetik', 'tƒ±p etiƒüi', 'mesleki etik', 'i≈ü etiƒüi', 'teknoloji etiƒüi', 'yapay zeka etiƒüi', 'robotik etik', 'sanal etik',
                'dijital etik', 'sosyal medya etiƒüi', 'gizlilik', 'mahremiyet', '≈üeffaflƒ±k', 'hesap verebilirlik', 'g√ºven', 'sadakat', 'doƒüruluk', 'd√ºr√ºstl√ºk',
                'samimiyet', 'i√ßtenlik', 'saygƒ±', 'ho≈üg√∂r√º', 'tolerans', '√ßokk√ºlt√ºrl√ºl√ºk', 'farklƒ±lƒ±k', '√ße≈üitlilik', 'kapsayƒ±cƒ±lƒ±k', 'ayrƒ±mcƒ±lƒ±k',
                '√∂nyargƒ±', 'kalƒ±pyargƒ±', 'adil olmayan', 'e≈üitsizlik', 'yoksulluk', 'zenginlik', 'sosyal adalet', 'ekonomik adalet', 'daƒüƒ±tƒ±cƒ± adalet', 'd√ºzeltici adalet',
                'insan haklarƒ±', 'temel haklar', 'sivil haklar', 'politik haklar', 'sosyal haklar', 'ekonomik haklar', 'k√ºlt√ºrel haklar', '√ßocuk haklarƒ±', 'kadƒ±n haklarƒ±', 'azƒ±nlƒ±k haklarƒ±',
                'hayvan haklarƒ±', 'doƒüa haklarƒ±', 'gelecek nesiller', 's√ºrd√ºr√ºlebilir kalkƒ±nma', 'intergenerasyon adalet', 'k√ºresel adalet', 'kozmopolit etik', 'milliyet√ßilik', 'vatanseverlik', 'barƒ±≈ü',
                'sava≈ü', '≈üiddet', '≈üiddetsizlik', 'direni≈ü', 'itaatsizlik', 'sivil itaatsizlik', 'demokrasi', 'otorite', 'g√º√ß', 'iktidar'
            ],
            
            // Estetik ve sanat felsefesi (100 kelime)
            aesthetics: [
                'estetik', 'g√ºzellik', 'sanat', 'yaratƒ±cƒ±lƒ±k', 'hayal g√ºc√º', 'inspirasyon', 'ilham', 'sezgi', 'yetenek', 'beceri',
                'ustalƒ±k', 'virt√º√∂zl√ºk', 'm√ºkemmellik', 'kusur', 'uyum', 'harmoni', 'ritim', 'melodi', 'renk', 'form',
                '≈üekil', 'doku', 'y√ºzey', 'derinlik', 'perspektif', 'g√∂lge', 'ƒ±≈üƒ±k', 'kontrast', 'denge', 'asimetri',
                'simetri', 'oran', 'proporsiyon', 'altƒ±n oran', 'fibonacci', 'stil', 'tarz', 'okul', 'akƒ±m', 'hareket',
                'avangard', 'modernizm', 'postmodernizm', 'klasicism', 'romantizm', 'realizm', 'impresyonizm', 'ekspresyonizm', 's√ºrrealizm', 'k√ºbizm',
                'f√ºt√ºrizm', 'dadaizm', 'minimalizm', 'konseptualizm', 'pop art', 'street art', 'dijital sanat', 'interaktif sanat', 'enstalasyon', 'performans',
                'happening', 'site-specific', '√ßevresel sanat', 'land art', 'video sanat', 'medya sanatƒ±', 'net.art', 'bio art', 'sci-art', 'teknosanat',
                'estetik deneyim', 'katarsis', 'sublim', 'y√ºce', 'g√ºzel', '√ßirkin', 'grotesk', 'abs√ºrd', 'ironik', 'parodic',
                'nostaljik', 'melankolik', 'dramatik', 'traigik', 'komik', 'grotesk', 'fantastik', 'ger√ßek√ºst√º', 'r√ºyamsi', 'kabus gibi',
                'b√ºy√ºl√º ger√ßeklik', 'allegori', 'sembolizm', 'metafor', 'metonimi', 'sinestezi', 'aura', 'sanat eseri', 'yaratƒ±l', 'yapƒ±t'
            ],
            
            // ƒ∞leri D√ºzey/Transandantal (Consciousness 20+) - 100 kelime
            transcendental: [
                'kozmik bilin√ß', 'evrensel anlayƒ±≈ü', 'kuantum bilin√ß', 'multi-dimensional d√º≈ü√ºnce', 'holografik ger√ßeklik', 'fraktal bilin√ß', 'emergence', '√∂z-organizasyon',
                'kompleksite teorisi', 'sistem dinamiƒüi', 'kaos kenarƒ±', 'kritik ge√ßi≈üler', 'faz deƒüi≈üimleri', 'tipping point', 'butterfly effect', 'strange attractor',
                'autopoiesis', 'enactive cognition', 'extended mind', 'distributed cognition', 'collective intelligence', 'hive mind', 'swarm intelligence', 'wisdom of crowds',
                'singularity', 'technological singularity', 'intelligence explosion', 'superintelligence', 'artificial general intelligence', 'consciousness uploading', 'mind transfer', 'digital immortality',
                'posthuman', 'transhumanism', 'enhancement', 'augmentation', 'cyborg', 'brain-computer interface', 'neural implant', 'nanobots', 'molecular machines', 'quantum computers',
                'parallel universes', 'multiverse', 'many-worlds interpretation', 'quantum superposition', 'entanglement', 'non-locality', 'action at distance', 'observer effect', 'measurement problem', 'consciousness-reality interface',
                'information integration theory', 'integrated information', 'phi', 'complexity', 'consciousness meter', 'hard problem of consciousness', 'explanatory gap', 'qualia', 'phenomenal consciousness', 'access consciousness',
                'global workspace theory', 'attention schema theory', 'predictive processing', 'Bayesian brain', 'free energy principle', 'active inference', 'embodied cognition', 'enactivism', 'ecological psychology', 'affordances',
                'morphogenetic fields', 'akashic records', 'collective unconscious', 'noosphere', 'Gaia hypothesis', 'planetary consciousness', 'cosmic evolution', 'cosmological natural selection', 'anthropic principle', 'fine-tuning',
                'omega point', 'technological transcendence', 'cosmic awakening', 'universal mind', 'absolute consciousness', 'non-dual awareness', 'enlightenment', 'satori', 'samadhi', 'moksha',
                'nirvana', 'liberation', 'self-realization', 'individuation', 'shadow integration', 'archetypal psychology', 'transpersonal psychology', 'integral theory', 'spiral dynamics', 'levels of consciousness'
            ]
        };

        // üöÄ TabPFN Hƒ±zlandƒ±rƒ±lmƒ±≈ü Kelime √ñƒürenme Sistemi
        class TabPFNVocabularySystem {
            constructor() {
                this.vocabularyPool = MASTER_VOCABULARY;
                this.learnedWords = new Map(); // bacteriaId -> learned words
                this.contextualRecommendations = new Map();
                this.socialLearningBonus = CONFIG.VOCABULARY.SOCIAL_LEARNING_MULTIPLIER;
                this.acceleratedLearning = CONFIG.VOCABULARY.TABPFN_ACCELERATION;
                console.log(`üöÄ TabPFN Vocabulary System initialized with ${this.getTotalWordCount()} words`);
            }

            getTotalWordCount() {
                return Object.values(this.vocabularyPool)
                    .reduce((total, category) => total + category.length, 0);
            }

            // üéØ Context-aware word selection with TabPFN acceleration
            getAvailableWords(bacteria) {
                const consciousness = bacteria.consciousness;
                const contextualWords = [];

                // Progressive vocabulary unlocking based on consciousness
                if (consciousness >= 0) contextualWords.push(...this.vocabularyPool.basic);
                if (consciousness >= 1) contextualWords.push(...this.vocabularyPool.social);
                if (consciousness >= 5) contextualWords.push(...this.vocabularyPool.scientific);
                if (consciousness >= 10) contextualWords.push(...this.vocabularyPool.philosophical);
                if (consciousness >= 20) contextualWords.push(...this.vocabularyPool.transcendental);

                return contextualWords;
            }

            // üß† TabPFN-powered smart word recommendation
            recommendWordsForContext(bacteria, context) {
                const availableWords = this.getAvailableWords(bacteria);
                const contextMap = {
                    'food_seeking': ['a√ß', 'yemek', 'beslenme', 'metabolizma', 'enerji', 'ATP'],
                    'reproduction': ['√ßoƒüalma', '√ºreme', 'DNA', 'gen', 'b√ºy√ºme', 'b√∂l√ºnme'],
                    'social_interaction': ['merhaba', 'ileti≈üim', 'sosyal', 'grup', 'takƒ±m', 'topluluk'],
                    'exploration': ['ke≈üif', 'ara≈ütƒ±rma', 'hareket', 'macera', 'yeni', 'bilinmeyen'],
                    'learning': ['√∂ƒürenme', 'bilgi', 'deneyim', 'hafƒ±za', 'akƒ±l', 'zihin'],
                    'philosophical': ['bilin√ß', 'farkƒ±ndalƒ±k', 'varolu≈ü', 'anlam', 'hakikat', 'ger√ßeklik']
                };

                const contextualWords = contextMap[context] || [];
                const recommendations = contextualWords.filter(word => 
                    availableWords.includes(word) && 
                    !this.hasLearnedWord(bacteria.id, word)
                );

                // TabPFN acceleration: boost learning rate for contextual matches
                if (this.acceleratedLearning && recommendations.length > 0) {
                    return recommendations.slice(0, 3); // Top 3 recommendations
                }

                return [];
            }

            // üìö Progressive word learning with social boost
            learnWord(bacteriaId, word, context = 'general') {
                if (!this.learnedWords.has(bacteriaId)) {
                    this.learnedWords.set(bacteriaId, new Set());
                }

                const bacteriaWords = this.learnedWords.get(bacteriaId);
                if (!bacteriaWords.has(word)) {
                    bacteriaWords.add(word);
                    
                    // Social learning bonus: nearby bacteria get exposure
                    this.propagateSocialLearning(bacteriaId, word, context);
                    
                    return true;
                }
                return false;
            }

            // ü§ù Social learning propagation
            propagateSocialLearning(learnerId, word, context) {
                const learnerBacteria = bacteria.find(b => b.id === learnerId);
                if (!learnerBacteria) return;

                bacteria.forEach(otherBacteria => {
                    if (otherBacteria.id === learnerId) return;
                    
                    const distance = Math.sqrt(
                        Math.pow(learnerBacteria.x - otherBacteria.x, 2) +
                        Math.pow(learnerBacteria.y - otherBacteria.y, 2) +
                        Math.pow(learnerBacteria.z - otherBacteria.z, 2)
                    );

                    // Within social learning range
                    if (distance < 100) {
                        const socialBonus = this.socialLearningBonus * (1 - distance / 100);
                        
                        // Chance to learn from nearby bacteria
                        if (Math.random() < socialBonus * 0.3) {
                            this.learnWord(otherBacteria.id, word, context);
                        }
                    }
                });
            }

            // üîç Check if bacteria learned specific word
            hasLearnedWord(bacteriaId, word) {
                const bacteriaWords = this.learnedWords.get(bacteriaId);
                return bacteriaWords ? bacteriaWords.has(word) : false;
            }

            // üìñ Get all learned words for bacteria
            getLearnedWords(bacteriaId) {
                const bacteriaWords = this.learnedWords.get(bacteriaId);
                return bacteriaWords ? Array.from(bacteriaWords) : [];
            }

            // üéì Get learning progress
            getLearningProgress(bacteriaId, consciousness) {
                const learned = this.getLearnedWords(bacteriaId).length;
                const available = this.getAvailableWords({consciousness}).length;
                return available > 0 ? learned / available : 0;
            }

            // üí¨ Generate contextual speech
            generateSpeech(bacteriaId, context, emotion = 'neutral') {
                const learnedWords = this.getLearnedWords(bacteriaId);
                if (learnedWords.length === 0) return '';

                const recommendations = this.recommendWordsForContext({id: bacteriaId}, context);
                const availableWords = [...learnedWords, ...recommendations];

                // Emotional modifiers
                const emotionalWords = {
                    'happy': ['mutlu', 'sevin√ß', 'ne≈üeli', 'g√ºzel', 'harika'],
                    'excited': ['heyecan', 'muhte≈üem', '≈üa≈üƒ±rma', 'wow', 'inanƒ±lmaz'],
                    'curious': ['merak', 'nasƒ±l', 'neden', 'ke≈üif', 'ara≈ütƒ±rma'],
                    'social': ['merhaba', 'arkada≈ü', 'birlikte', 'payla≈üƒ±m', 'dostluk']
                };

                const emotionWords = emotionalWords[emotion] || [];
                const combinedWords = [...availableWords, ...emotionWords]
                    .filter(word => learnedWords.includes(word));

                if (combinedWords.length === 0) return '';

                // Generate 1-3 word expressions
                const wordCount = Math.min(Math.floor(Math.random() * 3) + 1, combinedWords.length);
                const selectedWords = [];
                
                for (let i = 0; i < wordCount; i++) {
                    const word = combinedWords[Math.floor(Math.random() * combinedWords.length)];
                    if (!selectedWords.includes(word)) {
                        selectedWords.push(word);
                    }
                }

                return selectedWords.join(' ');
            }
        }

        // üß† Advanced Neural Network System for Bacteria Intelligence
        class AdvancedNeuralNetwork {
            constructor(layers = CONFIG.AI.NEURAL_NETWORK_LAYERS) {
                this.layers = layers;
                this.weights = [];
                this.biases = [];
                this.learningRate = CONFIG.AI.LEARNING_RATE;
                this.momentum = 0.9;
                this.previousWeightDeltas = [];
                this.initializeNetwork();
                console.log(`üß† Neural Network initialized: ${layers.join(' ‚Üí ')} neurons`);
            }

            initializeNetwork() {
                // Initialize weights with Xavier initialization
                for (let i = 0; i < this.layers.length - 1; i++) {
                    const inputSize = this.layers[i];
                    const outputSize = this.layers[i + 1];
                    
                    // Xavier initialization for better training
                    const limit = Math.sqrt(6 / (inputSize + outputSize));
                    const weights = Array(inputSize).fill().map(() => 
                        Array(outputSize).fill().map(() => 
                            (Math.random() * 2 - 1) * limit
                        )
                    );
                    
                    const biases = Array(outputSize).fill().map(() => 
                        (Math.random() * 2 - 1) * 0.1
                    );
                    
                    this.weights.push(weights);
                    this.biases.push(biases);
                    this.previousWeightDeltas.push(Array(inputSize).fill().map(() => Array(outputSize).fill(0)));
                }
            }

            // Sigmoid activation with leak for better gradient flow
            sigmoid(x) {
                if (x < -500) return 0;
                if (x > 500) return 1;
                return 1 / (1 + Math.exp(-x));
            }

            // ReLU activation for hidden layers
            relu(x) {
                return Math.max(0.01 * x, x); // Leaky ReLU
            }

            // Forward propagation with different activations
            forward(inputs) {
                let activations = [...inputs];
                
                for (let layer = 0; layer < this.weights.length; layer++) {
                    const newActivations = [];
                    
                    for (let neuron = 0; neuron < this.weights[layer][0].length; neuron++) {
                        let sum = this.biases[layer][neuron];
                        
                        for (let input = 0; input < activations.length; input++) {
                            sum += activations[input] * this.weights[layer][input][neuron];
                        }
                        
                        // Use ReLU for hidden layers, sigmoid for output
                        const activation = (layer === this.weights.length - 1) 
                            ? this.sigmoid(sum) 
                            : this.relu(sum);
                        
                        newActivations.push(activation);
                    }
                    
                    activations = newActivations;
                }
                
                return activations;
            }

            // Advanced backpropagation with momentum
            backpropagate(inputs, expectedOutputs) {
                // Forward pass to get all layer activations
                const layerActivations = [inputs];
                let currentActivations = [...inputs];
                
                for (let layer = 0; layer < this.weights.length; layer++) {
                    const newActivations = [];
                    for (let neuron = 0; neuron < this.weights[layer][0].length; neuron++) {
                        let sum = this.biases[layer][neuron];
                        for (let input = 0; input < currentActivations.length; input++) {
                            sum += currentActivations[input] * this.weights[layer][input][neuron];
                        }
                        newActivations.push((layer === this.weights.length - 1) ? this.sigmoid(sum) : this.relu(sum));
                    }
                    layerActivations.push(newActivations);
                    currentActivations = newActivations;
                }

                // Backward pass
                let errors = [];
                const outputActivations = layerActivations[layerActivations.length - 1];
                
                // Calculate output layer errors
                for (let i = 0; i < outputActivations.length; i++) {
                    errors.push(expectedOutputs[i] - outputActivations[i]);
                }

                // Update weights with momentum
                for (let layer = this.weights.length - 1; layer >= 0; layer--) {
                    const layerInputs = layerActivations[layer];
                    const layerOutputs = layerActivations[layer + 1];
                    const nextErrors = [];

                    for (let input = 0; input < this.weights[layer].length; input++) {
                        let error = 0;
                        for (let output = 0; output < this.weights[layer][input].length; output++) {
                            const gradient = errors[output] * layerInputs[input];
                            
                            // Momentum-based update
                            const weightDelta = this.learningRate * gradient + 
                                              this.momentum * this.previousWeightDeltas[layer][input][output];
                            
                            this.weights[layer][input][output] += weightDelta;
                            this.previousWeightDeltas[layer][input][output] = weightDelta;
                            
                            error += errors[output] * this.weights[layer][input][output];
                        }
                        nextErrors.push(error);
                    }

                    // Update biases 
                    for (let output = 0; output < errors.length; output++) {
                        this.biases[layer][output] += this.learningRate * errors[output];
                    }

                    errors = nextErrors;
                }
            }

            // Training with experience replay
            train(trainingData, epochs = 10) {
                console.log(`üéì Training neural network for ${epochs} epochs...`);
                
                for (let epoch = 0; epoch < epochs; epoch++) {
                    let totalError = 0;
                    
                    // Shuffle training data for better learning
                    const shuffledData = trainingData.sort(() => Math.random() - 0.5);
                    
                    for (const data of shuffledData) {
                        const outputs = this.forward(data.inputs);
                        this.backpropagate(data.inputs, data.expectedOutputs);
                        
                        // Calculate error for monitoring
                        for (let i = 0; i < outputs.length; i++) {
                            totalError += Math.pow(data.expectedOutputs[i] - outputs[i], 2);
                        }
                    }
                    
                    if (epoch % 5 === 0) {
                        console.log(`üìä Epoch ${epoch}: Error = ${(totalError / trainingData.length).toFixed(4)}`);
                    }
                }
                
                console.log('‚úÖ Neural network training completed!');
            }

            // Make intelligent decisions for bacteria
            makeDecision(bacteria) {
                const inputs = this.prepareBacteriaInputs(bacteria);
                const outputs = this.forward(inputs);
                
                // Map outputs to decisions: [move_x, move_y, move_z, seek_food, socialize, reproduce]
                return {
                    moveDirection: {
                        x: (outputs[0] - 0.5) * 2, // -1 to 1
                        y: (outputs[1] - 0.5) * 2,
                        z: (outputs[2] - 0.5) * 2
                    },
                    seekFood: outputs[3] > CONFIG.AI.DECISION_THRESHOLD,
                    socialize: outputs[4] > CONFIG.AI.DECISION_THRESHOLD,
                    reproduce: outputs[5] > CONFIG.AI.DECISION_THRESHOLD,
                    confidence: Math.max(...outputs)
                };
            }

            prepareBacteriaInputs(bacteria) {
                return [
                    bacteria.biological_state.age / 100,           // Normalized age
                    bacteria.biological_state.size / 5,           // Normalized size  
                    bacteria.consciousness_level / 10,            // Consciousness
                    bacteria.personality_traits.optimism,         // Optimism
                    bacteria.personality_traits.sociability,      // Sociability
                    bacteria.vocabulary.size / 50,                // Vocabulary ratio
                    bacteria.hunger || 0.5,                       // Hunger level
                    bacteria.energy || 0.7,                       // Energy level
                    bacteria.conversation_history.length / 20,    // Social experience
                    bacteria.memory_bank.length / 30,             // Memory capacity
                    bacteria.x / 500,                             // Position X
                    bacteria.y / 300                              // Position Y
                ];
            }
        }

        // üß¨ Genetic Algorithm for Neural Network Evolution  
        class GeneticEvolutionSystem {
            constructor() {
                this.populationSize = 20;
                this.mutationRate = CONFIG.AI.GENETIC_MUTATION_RATE;
                this.crossoverRate = 0.8;
                this.eliteSize = 4;
                this.generation = 0;
                console.log('üß¨ Genetic Evolution System initialized');
            }

            // Evolve neural networks based on bacteria fitness
            evolvePopulation(networks, fitnessScores) {
                console.log(`üß¨ Generation ${this.generation}: Evolving population...`);
                
                const newPopulation = [];
                
                // Keep elite networks (best performers)
                const elite = networks
                    .map((network, index) => ({ network, fitness: fitnessScores[index] }))
                    .sort((a, b) => b.fitness - a.fitness)
                    .slice(0, this.eliteSize)
                    .map(item => item.network);
                
                newPopulation.push(...elite);
                
                // Generate offspring through crossover and mutation
                while (newPopulation.length < this.populationSize) {
                    const parent1 = this.selectParent(networks, fitnessScores);
                    const parent2 = this.selectParent(networks, fitnessScores);
                    
                    if (Math.random() < this.crossoverRate) {
                        const offspring = this.crossover(parent1, parent2);
                        this.mutate(offspring);
                        newPopulation.push(offspring);
                    }
                }
                
                this.generation++;
                return newPopulation;
            }

            // Tournament selection for parent selection
            selectParent(networks, fitnessScores) {
                const tournamentSize = 3;
                let bestIndex = Math.floor(Math.random() * networks.length);
                
                for (let i = 1; i < tournamentSize; i++) {
                    const randomIndex = Math.floor(Math.random() * networks.length);
                    if (fitnessScores[randomIndex] > fitnessScores[bestIndex]) {
                        bestIndex = randomIndex;
                    }
                }
                
                return networks[bestIndex];
            }

            // Neural network crossover (blend weights)
            crossover(parent1, parent2) {
                const offspring = new AdvancedNeuralNetwork();
                
                for (let layer = 0; layer < offspring.weights.length; layer++) {
                    for (let i = 0; i < offspring.weights[layer].length; i++) {
                        for (let j = 0; j < offspring.weights[layer][i].length; j++) {
                            // Blend weights from both parents
                            const alpha = Math.random();
                            offspring.weights[layer][i][j] = 
                                alpha * parent1.weights[layer][i][j] + 
                                (1 - alpha) * parent2.weights[layer][i][j];
                        }
                    }
                    
                    // Blend biases
                    for (let i = 0; i < offspring.biases[layer].length; i++) {
                        const alpha = Math.random();
                        offspring.biases[layer][i] = 
                            alpha * parent1.biases[layer][i] + 
                            (1 - alpha) * parent2.biases[layer][i];
                    }
                }
                
                return offspring;
            }

            // Mutate neural network weights
            mutate(network) {
                for (let layer = 0; layer < network.weights.length; layer++) {
                    for (let i = 0; i < network.weights[layer].length; i++) {
                        for (let j = 0; j < network.weights[layer][i].length; j++) {
                            if (Math.random() < this.mutationRate) {
                                network.weights[layer][i][j] += 
                                    (Math.random() * 2 - 1) * CONFIG.AI.NEURAL_EVOLUTION_RATE;
                            }
                        }
                    }
                    
                    // Mutate biases
                    for (let i = 0; i < network.biases[layer].length; i++) {
                        if (Math.random() < this.mutationRate) {
                            network.biases[layer][i] += 
                                (Math.random() * 2 - 1) * CONFIG.AI.NEURAL_EVOLUTION_RATE;
                        }
                    }
                }
            }
        }

        // üéì Advanced Behavior Learning System
        class BehaviorLearningSystem {
            constructor() {
                this.experienceBuffer = [];
                this.maxExperiences = CONFIG.AI.EXPERIENCE_REPLAY_SIZE;
                this.learningPatterns = new Map();
                this.adaptationRate = CONFIG.AI.BEHAVIOR_ADAPTATION_RATE;
                console.log('üéì Behavior Learning System initialized');
            }

            // Record bacteria experience for learning
            recordExperience(bacteria, action, outcome, reward) {
                const experience = {
                    bacteriaId: bacteria.id,
                    state: this.captureBacteriaState(bacteria),
                    action: action,
                    outcome: outcome,
                    reward: reward,
                    timestamp: Date.now()
                };

                this.experienceBuffer.push(experience);
                
                // Keep buffer size manageable
                if (this.experienceBuffer.length > this.maxExperiences) {
                    this.experienceBuffer.shift();
                }

                // Update learning patterns
                this.updateLearningPatterns(bacteria, action, reward);
            }

            captureBacteriaState(bacteria) {
                return {
                    age: bacteria.biological_state.age,
                    size: bacteria.biological_state.size,
                    consciousness: bacteria.consciousness_level,
                    vocabulary: bacteria.vocabulary.size,
                    energy: bacteria.energy || 0.7,
                    hunger: bacteria.hunger || 0.5,
                    socialConnections: bacteria.conversation_history.length
                };
            }

            updateLearningPatterns(bacteria, action, reward) {
                const pattern = `${bacteria.id}_${action}`;
                
                if (!this.learningPatterns.has(pattern)) {
                    this.learningPatterns.set(pattern, {
                        successCount: 0,
                        failureCount: 0,
                        averageReward: 0,
                        attempts: 0
                    });
                }

                const stats = this.learningPatterns.get(pattern);
                stats.attempts++;
                stats.averageReward = (stats.averageReward * (stats.attempts - 1) + reward) / stats.attempts;
                
                if (reward > 0) {
                    stats.successCount++;
                } else {
                    stats.failureCount++;
                }

                this.learningPatterns.set(pattern, stats);
            }

            // Get adaptive behavior suggestions
            suggestBehavior(bacteria) {
                const suggestions = [];
                
                for (const [pattern, stats] of this.learningPatterns) {
                    if (pattern.startsWith(bacteria.id)) {
                        const action = pattern.split('_')[1];
                        const successRate = stats.successCount / Math.max(1, stats.attempts);
                        
                        if (successRate > 0.6 && stats.averageReward > 0.3) {
                            suggestions.push({
                                action: action,
                                confidence: successRate,
                                expectedReward: stats.averageReward
                            });
                        }
                    }
                }
                
                return suggestions.sort((a, b) => b.confidence - a.confidence);
            }

            // Apply learned behaviors to improve decision making
            enhanceBacteriaIntelligence(bacteria) {
                const suggestions = this.suggestBehavior(bacteria);
                
                if (suggestions.length > 0) {
                    const bestSuggestion = suggestions[0];
                    
                    // Boost consciousness based on learning success
                    bacteria.consciousness_level += CONFIG.AI.CONSCIOUSNESS_BOOST_RATE * bestSuggestion.confidence;
                    
                    // Adapt personality based on successful patterns
                    if (bestSuggestion.action === 'socialize') {
                        bacteria.personality_traits.sociability += this.adaptationRate;
                    } else if (bestSuggestion.action === 'explore') {
                        bacteria.personality_traits.optimism += this.adaptationRate;
                    }
                    
                    // Add to memory
                    if (bacteria.memory_bank.length < CONFIG.AI.MEMORY_CAPACITY) {
                        bacteria.memory_bank.push(`√ñƒürendim: ${bestSuggestion.action} ba≈üarƒ±lƒ±`);
                    }
                }
            }
        }

        // v8.2.8: Frontend-Only TabPFN (Mobile Compatible)
        class TabPFNAdapter {
            constructor() {
                this.isReady = false;
                this.trainingData = new Map(); // Collect training data
                this.behaviorClassifier = null;
                this.vocabularyAnalyzer = null;
                this.initialize();
            }

            async initialize() {
                console.log('üß† Initializing Frontend TabPFN-Inspired System...');
                
                // Create in-browser TabPFN-style classifiers
                this.createBehaviorClassifier();
                this.createVocabularyAnalyzer();
                this.loadSyntheticTrainingData();
                
                this.isReady = true;
                console.log('‚úÖ Frontend TabPFN System Ready (Mobile Compatible)!');
                appEvents.emit('ai:tabpfn:ready', this);
            }

            // Frontend TabPFN-Style Behavior Classifier
            createBehaviorClassifier() {
                this.behaviorClassifier = {
                    predict: (features) => {
                        // TabPFN-inspired rapid inference
                        const [age, size, consciousness, optimism, sociability, vocabSize, memoryCount, growthRate, hunger, energy, socialInteractions, learningRate] = features;
                        
                        // Multi-class behavior prediction with TabPFN-style scoring
                        const creativityScore = (consciousness * 0.35) + (vocabSize * 0.25) + (learningRate * 0.25) + (memoryCount * 0.15);
                        const socialScore = (sociability * 0.4) + (socialInteractions * 0.3) + (optimism * 0.2) + (vocabSize * 0.1);
                        const explorerScore = (energy * 0.35) + (growthRate * 0.25) + (consciousness * 0.2) + (age * 0.1) + (size * 0.1);
                        const learnerScore = (learningRate * 0.4) + (consciousness * 0.3) + (vocabSize * 0.2) + (memoryCount * 0.1);
                        
                        // TabPFN-style ensemble decision with confidence
                        const behaviors = [
                            { name: 'creative', score: creativityScore, confidence: Math.min(0.95, creativityScore + 0.1) },
                            { name: 'social', score: socialScore, confidence: Math.min(0.9, socialScore + 0.15) },
                            { name: 'explorer', score: explorerScore, confidence: Math.min(0.85, explorerScore + 0.2) },
                            { name: 'learner', score: learnerScore, confidence: Math.min(0.88, learnerScore + 0.12) },
                            { name: 'basic', score: 0.4, confidence: 0.6 }
                        ];
                        
                        const bestBehavior = behaviors.sort((a, b) => b.score - a.score)[0];
                        return { behavior: bestBehavior.name, confidence: bestBehavior.confidence };
                    }
                };
            }

            async predictBehavior(bacteria) {
                if (!this.isReady) return 'basic';
                
                const features = [
                    bacteria.biological_state.age / 100,
                    bacteria.biological_state.size / 5,
                    bacteria.consciousness_level / 10,
                    bacteria.personality_traits.optimism,
                    bacteria.personality_traits.sociability,
                    bacteria.vocabulary.size / 20,
                    bacteria.memory_bank.length / 10,
                    bacteria.biological_state.growth_rate,
                    bacteria.hunger || 0.5,
                    bacteria.energy || 0.7,
                    bacteria.conversation_history.length / 5,
                    0.1 // learning_rate default
                ];
                
                // üß† SELF-IMPROVEMENT: Risk assessment
                const context = {
                    bacteriaAge: bacteria.biological_state.age,
                    consciousness: bacteria.consciousness_level,
                    hunger: bacteria.hunger || 0.5
                };
                
                const result = this.behaviorClassifier.predict(features);
                const riskAssessment = learningEngine.assessRisk('tabpfn', features, result.confidence, context);
                
                // Apply risk-based adjustments
                let finalBehavior = result.behavior;
                let finalConfidence = result.confidence;
                
                if (riskAssessment.isRisky && result.confidence < learningEngine.confidenceThreshold) {
                    finalBehavior = 'basic'; // Safe fallback
                    finalConfidence = 0.9; // High confidence in safe choice
                    console.log(`‚ö†Ô∏è TabPFN Risk detected, using fallback: ${bacteria.name} ‚Üí ${finalBehavior}`);
                }
                
                // üìä Log decision for learning
                const logEntry = learningEngine.logDecision('tabpfn', features, finalBehavior, finalConfidence, context);
                
                // Store for outcome tracking
                bacteria._lastDecisionLog = logEntry;
                
                console.log(`üéØ TabPFN: ${bacteria.name} ‚Üí ${finalBehavior} (${(finalConfidence * 100).toFixed(1)}%)`);
                
                // Collect training data for continuous improvement
                this.collectTrainingData(bacteria, finalBehavior, features);
                
                return finalBehavior;
            }

            // TabPFN-inspired personality trait prediction
            createPersonalityPredictor() {
                this.personalityPredictor = {
                    predictEvolution: (bacteria) => {
                        // Predict how personality will evolve based on TabPFN-style rapid inference
                        const experienceVector = [
                            bacteria.biological_state.age / 100,
                            bacteria.conversation_history.length / 50,
                            bacteria.vocabulary.size / 100,
                            bacteria.memory_bank.filter(m => m.includes('arkada≈ü')).length / 10,
                            bacteria.memory_bank.filter(m => m.includes('√∂ƒürendim')).length / 10
                        ];
                        
                        const evolutionFactor = experienceVector.reduce((sum, val) => sum + val, 0) / experienceVector.length;
                        
                        return {
                            optimismChange: (evolutionFactor - 0.5) * 0.05,
                            sociabilityChange: (bacteria.conversation_history.length > 5 ? 0.02 : -0.01),
                            confidenceBoost: evolutionFactor * 0.1
                        };
                    }
                };
            }

            createVocabularyAnalyzer() {
                this.vocabularyAnalyzer = {
                    analyze: (bacteria) => {
                        const vocabulary = Array.from(bacteria.vocabulary);
                        const consciousness = bacteria.consciousness_level;
                        
                        // Analyze vocabulary categories
                        const biochemWords = vocabulary.filter(w => ['ATP', 'enzim', 'protein', 'metabolizma', 'sentez', 'h√ºcre', 'oksijen', 'karbon'].includes(w));
                        const socialWords = vocabulary.filter(w => ['arkada≈ü', 'konu≈ümak', 'payla≈üƒ±m', 'birlikte', 'dostluk', 'anla≈üma', 'empati'].includes(w));
                        const emotionalWords = vocabulary.filter(w => ['mutlu', '√ºzg√ºn', 'heyecanlƒ±', 'meraklƒ±', 'sevin√ß', 'umut', 'g√ºven'].includes(w));
                        const scienceWords = vocabulary.filter(w => ['ke≈üif', 'deneyim', '√∂ƒürenme', 'geli≈üim', 'evrim', 'yenilik'].includes(w));
                        
                        const biochemRatio = biochemWords.length / Math.max(1, vocabulary.length);
                        const socialRatio = socialWords.length / Math.max(1, vocabulary.length);
                        const emotionalRatio = emotionalWords.length / Math.max(1, vocabulary.length);
                        const scienceRatio = scienceWords.length / Math.max(1, vocabulary.length);
                        
                        // Intelligent word suggestions based on gaps and consciousness level
                        let suggestedWords = [];
                        
                        if (consciousness > 8 && biochemRatio < 0.2) {
                            suggestedWords.push('quantum', 'molek√ºl', 'elektronik', 'n√∂ron');
                        }
                        
                        if (consciousness > 5 && socialRatio < 0.25) {
                            suggestedWords.push('sevgi', 'anlayƒ±≈ü', 'dayanƒ±≈üma', 'ileti≈üim');
                        }
                        
                        if (consciousness > 3 && emotionalRatio < 0.15) {
                            suggestedWords.push('hissediyor', 'd√º≈ü√ºn√ºyor', 'hayal', 'r√ºya');
                        }
                        
                        if (consciousness > 6 && scienceRatio < 0.2) {
                            suggestedWords.push('ara≈ütƒ±rma', 'hipotez', 'deney', 'kanƒ±t');
                        }
                        
                        // Consciousness-based advanced words
                        if (consciousness > 10) {
                            suggestedWords.push('bilin√ß', 'varolu≈ü', 'sonsuzluk', 'ger√ßeklik');
                        }
                        
                        // Basic words for low consciousness
                        if (consciousness < 2) {
                            suggestedWords.push('merhaba', 'evet', 'hayƒ±r', 'g√ºzel');
                        }
                        
                        return {
                            total_words: vocabulary.length,
                            biochemical_ratio: biochemRatio,
                            social_ratio: socialRatio,
                            emotional_ratio: emotionalRatio,
                            science_ratio: scienceRatio,
                            suggested_words: suggestedWords.slice(0, 4), // Limit to 4 suggestions
                            consciousness_level: consciousness,
                            vocabulary_gaps: this.findVocabularyGaps(vocabulary)
                        };
                    },
                    
                    findVocabularyGaps: (vocabulary) => {
                        const gaps = [];
                        
                        if (!vocabulary.some(w => w.includes('arkada≈ü'))) gaps.push('social');
                        if (!vocabulary.some(w => ['ATP', 'enzim'].includes(w))) gaps.push('biochemical');
                        if (!vocabulary.some(w => ['mutlu', '√ºzg√ºn'].includes(w))) gaps.push('emotional');
                        if (!vocabulary.some(w => ['√∂ƒürenme', 'ke≈üif'].includes(w))) gaps.push('learning');
                        
                        return gaps;
                    }
                };
            }

            async analyzeVocabulary(bacteria) {
                if (!this.isReady) return null;
                
                const analysis = this.vocabularyAnalyzer.analyze(bacteria);
                console.log(`üìñ Frontend TabPFN Vocab Analysis for ${bacteria.name}:`, analysis);
                
                return {
                    vocabulary_analysis: analysis,
                    suggested_next_words: analysis.suggested_words
                };
            }
            
            // NEW: Improve bacteria word usage in conversations
            improveWordUsage(bacteria, context = 'conversation') {
                const vocabulary = Array.from(bacteria.vocabulary);
                const consciousness = bacteria.consciousness_level;
                
                // Select words based on context and consciousness
                let contextualWords = [];
                
                if (context === 'greeting') {
                    contextualWords = vocabulary.filter(w => ['merhaba', 'selam', 'dostluk', 'sevgi'].includes(w));
                }
                else if (context === 'learning') {
                    contextualWords = vocabulary.filter(w => ['√∂ƒürenme', 'ke≈üif', 'deneyim', 'anlama', 'geli≈üim'].includes(w));
                }
                else if (context === 'social') {
                    contextualWords = vocabulary.filter(w => ['arkada≈ü', 'payla≈üƒ±m', 'birlikte', 'anla≈üma', 'sevgi'].includes(w));
                }
                else if (context === 'science') {
                    contextualWords = vocabulary.filter(w => ['ATP', 'enzim', 'h√ºcre', 'protein', 'molek√ºl'].includes(w));
                }
                else {
                    // General conversation - mix of all categories
                    contextualWords = vocabulary.filter(w => 
                        ['arkada≈ü', '√∂ƒürenme', 'mutlu', 'ATP', 'ke≈üif', 'geli≈üim', 'sevgi', 'anlama'].includes(w)
                    );
                }
                
                // If no contextual words, fall back to any learned words
                if (contextualWords.length === 0 && vocabulary.length > 0) {
                    contextualWords = vocabulary.slice(-5); // Use most recent words
                }
                
                // Return a random contextual word for use in conversation
                if (contextualWords.length > 0) {
                    const selectedWord = contextualWords[Math.floor(Math.random() * contextualWords.length)];
                    console.log(`üí¨ ${bacteria.name} using learned word: "${selectedWord}" (context: ${context})`);
                    return selectedWord;
                }
                
                return null;
            }

            loadSyntheticTrainingData() {
                // Load synthetic training examples for TabPFN-style learning
                const examples = [
                    { features: [0.1, 1.5, 2.0, 0.8, 0.7, 0.3, 0.2, 0.6, 0.5, 0.8, 0.1, 0.1], behavior: 'social' },
                    { features: [0.5, 2.0, 8.0, 0.6, 0.3, 0.8, 0.7, 0.4, 0.6, 0.7, 0.3, 0.9], behavior: 'creative' },
                    { features: [0.3, 1.8, 5.0, 0.5, 0.6, 0.6, 0.5, 0.7, 0.8, 0.9, 0.2, 0.8], behavior: 'learner' },
                    { features: [0.2, 1.2, 3.0, 0.7, 0.4, 0.4, 0.3, 0.8, 0.9, 0.9, 0.1, 0.5], behavior: 'explorer' }
                ];
                
                examples.forEach((example, index) => {
                    this.trainingData.set(`synthetic_${index}`, example);
                });
                
                console.log(`üìö Loaded ${examples.length} synthetic training examples`);
            }
            
            collectTrainingData(bacteria, behavior, features) {
                // Store training example for continuous learning
                const dataPoint = {
                    bacteria_id: bacteria.id,
                    features: features,
                    behavior: behavior,
                    timestamp: Date.now(),
                    consciousness: bacteria.consciousness_level,
                    vocabulary_size: bacteria.vocabulary.size
                };
                
                this.trainingData.set(`real_${bacteria.id}_${Date.now()}`, dataPoint);
                
                // Keep only last 1000 training examples for performance
                if (this.trainingData.size > 1000) {
                    const firstKey = this.trainingData.keys().next().value;
                    this.trainingData.delete(firstKey);
                }
            }

            // Real TabPFN-powered behavior adaptation
            async adaptBehavior(bacteria, context) {
                if (!this.isReady) return 'basic';
                
                try {
                    // Get real TabPFN prediction
                    const behavior = await this.predictBehavior(bacteria);
                    
                    // Context-aware enhancement using TabPFN insights
                    if (context === 'group_interaction') {
                        const vocabAnalysis = await this.analyzeVocabulary(bacteria);
                        if (vocabAnalysis && vocabAnalysis.vocabulary_analysis.social_ratio > 0.3) {
                            return `${behavior}_social`;
                        }
                    }
                    
                    if (context === 'learning_session') {
                        if (bacteria.consciousness_level > 5) {
                            return `${behavior}_enhanced`;
                        }
                    }
                    
                    return behavior;
                } catch (error) {
                    console.error('TabPFN adaptBehavior error:', error);
                    return 'basic';
                }
            }

            extractFeatures(bacteria) {
                return [
                    bacteria.biological_state.age / 100,
                    bacteria.biological_state.size / 5,
                    bacteria.consciousness_level / 5,
                    bacteria.personality_traits.optimism,
                    bacteria.personality_traits.sociability,
                    bacteria.vocabulary.size / 50,
                    bacteria.memory_bank.length / 20,
                    bacteria.biological_state.growth_rate,
                    0.5, // hunger
                    0.7, // energy
                    bacteria.conversation_history.length / 10,
                    bacteria.memory_bank.filter(m => m.includes('√∂ƒürendim')).length / 5
                ];
            }
        }

        // Initialize TabPFN adapter
        const tabPFNAdapter = new TabPFNAdapter();

        // v825: Persistent Database System
        class PersistentBacteriaDB {
            constructor() {
                this.dbName = 'NeoMagBacteriaDB';
                this.version = 1;
                this.isReady = false;
                this.initialize();
            }

            async initialize() {
                console.log('üóÑÔ∏è Initializing Persistent Database...');
                
                // Use IndexedDB for robust storage
                if ('indexedDB' in window) {
                    await this.initIndexedDB();
                } else {
                    // Fallback to localStorage
                    console.log('üì¶ IndexedDB not available, using localStorage');
                    this.isReady = true;
                }
                
                if (this.isReady) {
                    console.log('üíæ Database ready, emitting db:ready event');
                    appEvents.emit('db:ready', this);
                } else {
                    console.log('‚ùå Database initialization failed');
                    appEvents.emit('db:error', { error: 'Failed to initialize' });
                }
            }

            async initIndexedDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => {
                        console.error('‚ùå IndexedDB initialization failed');
                        reject(request.error);
                    };

                    request.onsuccess = () => {
                        this.db = request.result;
                        this.isReady = true;
                        console.log('‚úÖ IndexedDB initialized successfully');
                        resolve();
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Bacteria store
                        const bacteriaStore = db.createObjectStore('bacteria', { keyPath: 'id' });
                        bacteriaStore.createIndex('name', 'name', { unique: false });
                        bacteriaStore.createIndex('consciousness_level', 'consciousness_level', { unique: false });
                        bacteriaStore.createIndex('last_updated', 'last_updated', { unique: false });
                        
                        // Simulation history store
                        const historyStore = db.createObjectStore('simulation_history', { keyPath: 'timestamp' });
                        historyStore.createIndex('day', 'day', { unique: false });
                        
                        // TabPFN training data store
                        const tabpfnStore = db.createObjectStore('tabpfn_data', { keyPath: 'record_id' });
                        tabpfnStore.createIndex('bacteria_id', 'bacteria_id', { unique: false });
                        tabpfnStore.createIndex('behavior_class', 'behavior_class', { unique: false });
                        
                        console.log('üèóÔ∏è Database schema created');
                    };
                });
            }

            async saveBacteria(bacteria) {
                if (!this.isReady) return false;

                const bacteriaData = {
                    id: bacteria.id,
                    name: bacteria.name,
                    biological_state: bacteria.biological_state,
                    personality_traits: bacteria.personality_traits,
                    consciousness_level: bacteria.consciousness_level, // Now unlimited!
                    language_stage: bacteria.language_stage,
                    vocabulary: Array.from(bacteria.vocabulary), // Convert Set to Array
                    memory_bank: bacteria.memory_bank,
                    conversation_history: bacteria.conversation_history,
                    position: { x: bacteria.x, y: bacteria.y },
                    velocity: { vx: bacteria.vx, vy: bacteria.vy },
                    color: bacteria.color,
                    last_updated: new Date().toISOString(),
                    total_runtime_days: bacteria.total_runtime_days || 0,
                    max_consciousness_reached: bacteria.max_consciousness_reached || bacteria.consciousness_level
                };

                try {
                    if (this.db) {
                        // IndexedDB
                        const transaction = this.db.transaction(['bacteria'], 'readwrite');
                        const store = transaction.objectStore('bacteria');
                        await store.put(bacteriaData);
                    } else {
                        // localStorage fallback
                        const allData = JSON.parse(localStorage.getItem('bacteriaDB') || '{}');
                        allData[bacteria.id] = bacteriaData;
                        localStorage.setItem('bacteriaDB', JSON.stringify(allData));
                    }
                    
                    console.log(`üíæ Saved bacteria #${bacteria.id} (Consciousness: ${bacteria.consciousness_level.toFixed(2)})`);
                    return true;
                } catch (error) {
                    console.error('‚ùå Failed to save bacteria:', error);
                    return false;
                }
            }

            async loadBacteria() {
                if (!this.isReady) return [];

                try {
                    let bacteriaData = [];
                    
                    if (this.db) {
                        // IndexedDB
                        const transaction = this.db.transaction(['bacteria'], 'readonly');
                        const store = transaction.objectStore('bacteria');
                        const request = store.getAll();
                        
                        bacteriaData = await new Promise((resolve, reject) => {
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                    } else {
                        // localStorage fallback
                        const allData = JSON.parse(localStorage.getItem('bacteriaDB') || '{}');
                        bacteriaData = Object.values(allData);
                    }

                    console.log(`üìñ Loaded ${bacteriaData.length} bacteria from database`);
                    return bacteriaData;
                } catch (error) {
                    console.error('‚ùå Failed to load bacteria:', error);
                    return [];
                }
            }

            async saveSimulationState(day, population, metrics) {
                if (!this.isReady) return false;

                const stateData = {
                    timestamp: new Date().toISOString(),
                    day: day,
                    population_count: population.length,
                    average_consciousness: population.reduce((sum, b) => sum + b.consciousness_level, 0) / population.length,
                    max_consciousness: Math.max(...population.map(b => b.consciousness_level)),
                    total_vocabulary: new Set(population.flatMap(b => Array.from(b.vocabulary))).size,
                    performance_metrics: metrics
                };

                try {
                    if (this.db) {
                        const transaction = this.db.transaction(['simulation_history'], 'readwrite');
                        const store = transaction.objectStore('simulation_history');
                        await store.put(stateData);
                    } else {
                        const allHistory = JSON.parse(localStorage.getItem('simulationHistory') || '[]');
                        allHistory.push(stateData);
                        // Keep last 1000 records
                        if (allHistory.length > 1000) {
                            allHistory.splice(0, allHistory.length - 1000);
                        }
                        localStorage.setItem('simulationHistory', JSON.stringify(allHistory));
                    }
                    
                    return true;
                } catch (error) {
                    console.error('‚ùå Failed to save simulation state:', error);
                    return false;
                }
            }

            async exportToCSV() {
                console.log('üìä Generating TabPFN-ready CSV export...');
                
                const bacteriaData = await this.loadBacteria();
                if (bacteriaData.length === 0) {
                    console.log('‚ö†Ô∏è No data to export');
                    return;
                }

                // TabPFN-optimized feature columns
                const csvHeaders = [
                    'bacteria_id', 'name', 'age', 'size', 'consciousness_level', 'max_consciousness_reached',
                    'optimism', 'sociability', 'vocabulary_size', 'memory_count', 'growth_rate',
                    'total_conversations', 'learning_events', 'social_interactions', 'runtime_days',
                    'biochemical_words', 'social_words', 'emotional_words', 'behavior_prediction',
                    'last_updated', 'x_position', 'y_position'
                ];

                let csvContent = csvHeaders.join(',') + '\n';

                bacteriaData.forEach(bacteria => {
                    const vocab = bacteria.vocabulary || [];
                    const biochemWords = vocab.filter(w => ['ATP', 'enzim', 'protein', 'metabolizma', 'sentez'].includes(w)).length;
                    const socialWords = vocab.filter(w => ['arkada≈ü', 'konu≈ümak', 'payla≈üƒ±m', 'birlikte'].includes(w)).length;
                    const emotionalWords = vocab.filter(w => ['mutlu', '√ºzg√ºn', 'heyecanlƒ±', 'meraklƒ±'].includes(w)).length;
                    
                    // Predict behavior for CSV
                    const tempBacteria = this.recreateBacteriaFromData(bacteria);
                    const behaviorPrediction = predictBehavior(tempBacteria, 'csv_export');

                    const row = [
                        bacteria.id,
                        `"${bacteria.name}"`,
                        bacteria.biological_state.age,
                        bacteria.biological_state.size.toFixed(3),
                        bacteria.consciousness_level.toFixed(3),
                        bacteria.max_consciousness_reached?.toFixed(3) || bacteria.consciousness_level.toFixed(3),
                        bacteria.personality_traits.optimism.toFixed(3),
                        bacteria.personality_traits.sociability.toFixed(3),
                        vocab.length,
                        bacteria.memory_bank.length,
                        bacteria.biological_state.growth_rate.toFixed(3),
                        bacteria.conversation_history.length,
                        bacteria.memory_bank.filter(m => m.includes('√∂ƒürendim')).length,
                        bacteria.memory_bank.filter(m => m.includes('arkada≈ü')).length,
                        bacteria.total_runtime_days || 0,
                        biochemWords,
                        socialWords,
                        emotionalWords,
                        behaviorPrediction,
                        bacteria.last_updated,
                        bacteria.position.x.toFixed(2),
                        bacteria.position.y.toFixed(2)
                    ];

                    csvContent += row.join(',') + '\n';
                });

                // Download CSV
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `neomag_bacteria_tabpfn_${new Date().toISOString().slice(0,10)}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                console.log(`‚úÖ CSV exported with ${bacteriaData.length} bacteria records`);
            }

            recreateBacteriaFromData(data) {
                // Create temporary bacteria object for prediction
                return {
                    id: data.id,
                    name: data.name,
                    biological_state: data.biological_state,
                    personality_traits: data.personality_traits,
                    consciousness_level: data.consciousness_level,
                    vocabulary: new Set(data.vocabulary),
                    memory_bank: data.memory_bank,
                    conversation_history: data.conversation_history
                };
            }

            async clearDatabase() {
                if (!this.isReady) return false;

                try {
                    if (this.db) {
                        const stores = ['bacteria', 'simulation_history', 'tabpfn_data'];
                        const transaction = this.db.transaction(stores, 'readwrite');
                        
                        stores.forEach(storeName => {
                            const store = transaction.objectStore(storeName);
                            store.clear();
                        });
                    } else {
                        localStorage.removeItem('bacteriaDB');
                        localStorage.removeItem('simulationHistory');
                    }
                    
                    console.log('üóëÔ∏è Database cleared successfully');
                    return true;
                } catch (error) {
                    console.error('‚ùå Failed to clear database:', error);
                    return false;
                }
            }
        }

        // Initialize persistent database (initialization will be done in mainInitialize)

        // v826: Real TensorFlow.js AI Training System
        class RealAITrainingSystem {
            constructor() {
                this.behaviorModel = null;
                this.isTraining = false;
                this.trainingData = [];
                this.modelVersion = 1;
                this.lastTrainingTime = 0;
                this.trainingInterval = 120000; // Train every 2 minutes
                this.initialize();
            }

            async initialize() {
                console.log('üß† Initializing Real TensorFlow.js Training System...');
                try {
                    await this.createBehaviorModel();
                    await this.loadTrainingData();
                    this.startTrainingLoop();
                    console.log('‚úÖ Real AI Training System ready');
                    appEvents.emit('ai:tfjs:ready', this);
                } catch (error) {
                    console.error('‚ùå TensorFlow.js AI initialization failed:', error);
                    appEvents.emit('ai:tfjs:error', { error });
                }
            }

            async createBehaviorModel() {
                this.behaviorModel = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [12], units: 32, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 16, activation: 'relu' }),
                        tf.layers.dense({ units: 5, activation: 'softmax' })
                    ]
                });
                this.behaviorModel.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });
                console.log('üéØ Real behavior model created');
            }

            async collectTrainingData(bacteria, behavior) {
                const trainingRecord = {
                    record_id: Date.now() + Math.random(),
                    bacteria_id: bacteria.id,
                    timestamp: new Date().toISOString(),
                    features_behavior: [
                        bacteria.biological_state.age / 100,
                        bacteria.biological_state.size / 5,
                        bacteria.consciousness_level / 10,
                        bacteria.personality_traits.optimism,
                        bacteria.personality_traits.sociability,
                        bacteria.vocabulary.size / 20,
                        bacteria.memory_bank.length / 10,
                        bacteria.hunger || 0.5, // Dynamic now!
                        bacteria.energy || 0.7, // Dynamic now!
                        bacteria.biological_state.growth_rate,
                        bacteria.getProximityToOthers ? bacteria.getProximityToOthers() : 0.5,
                        bacteria.getRecentActivityLevel ? bacteria.getRecentActivityLevel() : 0.5
                    ],
                    behavior_class: this.encodeBehaviorClass(behavior),
                    model_version: this.modelVersion
                };

                this.trainingData.push(trainingRecord);
                
                if (persistentDB.isReady) {
                    await this.saveTrainingDataToDB(trainingRecord);
                }
                
                console.log(`üìä Training data collected for bacteria #${bacteria.id}: ${behavior}`);
            }

            encodeBehaviorClass(behavior) {
                const classes = ['basic', 'social', 'explorer', 'learner', 'creative'];
                const index = classes.indexOf(behavior);
                const encoded = new Array(5).fill(0);
                if (index >= 0) encoded[index] = 1;
                return encoded;
            }

            async saveTrainingDataToDB(record) {
                try {
                    if (persistentDB && persistentDB.db) {
                        const transaction = persistentDB.db.transaction(['tabpfn_data'], 'readwrite');
                        const store = transaction.objectStore('tabpfn_data');
                        await store.put(record);
                    }
                } catch (error) {
                    console.error('‚ùå Failed to save training data:', error);
                }
            }

            async loadTrainingData() {
                try {
                    // Wait for persistentDB to be ready
                    if (!persistentDB || !persistentDB.db) {
                        console.log('‚è≥ Database not ready yet, skipping training data load');
                        return;
                    }
                    
                    const transaction = persistentDB.db.transaction(['tabpfn_data'], 'readonly');
                    const store = transaction.objectStore('tabpfn_data');
                    const request = store.getAll();
                    
                    const existingData = await new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    this.trainingData = existingData;
                    console.log(`üìö Loaded ${existingData.length} existing training records`);
                } catch (error) {
                    console.error('‚ùå Failed to load training data:', error);
                }
            }

            async trainModels() {
                if (this.isTraining || this.trainingData.length < 10) return;

                this.isTraining = true;
                console.log('üîÑ Training real TensorFlow.js model...');

                try {
                    const behaviorFeatures = this.trainingData.map(d => d.features_behavior);
                    const behaviorLabels = this.trainingData.map(d => d.behavior_class);
                    
                    const behaviorX = tf.tensor2d(behaviorFeatures);
                    const behaviorY = tf.tensor2d(behaviorLabels);

                    await this.behaviorModel.fit(behaviorX, behaviorY, {
                        epochs: 10,
                        batchSize: 8,
                        validationSplit: 0.2,
                        shuffle: true,
                        verbose: 0
                    });

                    this.modelVersion++;
                    this.lastTrainingTime = Date.now();
                    
                    console.log(`‚úÖ Real model training complete! Version: ${this.modelVersion}`);

                    behaviorX.dispose();
                    behaviorY.dispose();
                } catch (error) {
                    console.error('‚ùå Training failed:', error);
                }

                this.isTraining = false;
            }

            async predictBehavior(bacteria) {
                if (!this.behaviorModel) return 'basic';

                try {
                    const features = [
                        bacteria.biological_state.age / 100,
                        bacteria.biological_state.size / 5,
                        bacteria.consciousness_level / 10,
                        bacteria.personality_traits.optimism,
                        bacteria.personality_traits.sociability,
                        bacteria.vocabulary.size / 20,
                        bacteria.memory_bank.length / 10,
                        bacteria.hunger || 0.5,
                        bacteria.energy || 0.7,
                        bacteria.biological_state.growth_rate,
                        bacteria.getProximityToOthers ? bacteria.getProximityToOthers() : 0.5,
                        bacteria.getRecentActivityLevel ? bacteria.getRecentActivityLevel() : 0.5
                    ];

                    const prediction = this.behaviorModel.predict(tf.tensor2d([features]));
                    const probabilities = await prediction.data();
                    
                    const behaviorClasses = ['basic', 'social', 'explorer', 'learner', 'creative'];
                    const maxIndex = probabilities.indexOf(Math.max(...probabilities));
                    
                    prediction.dispose();
                    return behaviorClasses[maxIndex];
                } catch (error) {
                    console.error('‚ùå Prediction failed:', error);
                    return 'basic';
                }
            }

            startTrainingLoop() {
                setInterval(() => {
                    if (Date.now() - this.lastTrainingTime > this.trainingInterval) {
                        this.trainModels();
                    }
                }, 30000);
            }

            getTrainingStats() {
                return {
                    totalRecords: this.trainingData.length,
                    modelVersion: this.modelVersion,
                    isTraining: this.isTraining
                };
            }
        }

        // Initialize real AI training system (will be initialized after DB ready)
        let realAI = null;

        // v829 Enhanced Performance Monitoring + Canvas Support
        let performanceMetrics = {
            renderTime: 0,
            mlInferenceTime: 0,
            totalMemoryUsage: 0,
            vocabularySize: 0,
            lastUpdate: Date.now(),
            fps: 0,
            lastFrameTime: 0,
            frameCount: 0
        };

        // Canvas support variables (DYNAMIC BOUNDARIES FIX)
        let canvas = null;
        let ctx = null;
        let canvasWidth = 0;
        let canvasHeight = 0;
        let useCanvas = false;
        
        // üéØ DYNAMIC CANVAS BOUNDARIES (v8.7.3 B√úY√úK ƒ∞Nƒ∞Tƒ∞AL VALUES)
        let DYNAMIC_BOUNDARIES = {
            maxX: 1200,  // ‚ùå SABƒ∞T 480 KALDIRILDI! Ba≈ülangƒ±√ß b√ºy√ºk deƒüer
            maxY: 800,   // ‚ùå SABƒ∞T 280 KALDIRILDI! Ba≈ülangƒ±√ß b√ºy√ºk deƒüer
            minX: 20,
            minY: 20,
            padding: 20
        };

        // Molecular Dynamics Constants (based on research)
        const MD_CONSTANTS = {
            VAN_DER_WAALS_STRENGTH: 0.1,      // Lennard-Jones potential coefficient
            ELECTROSTATIC_FORCE: 0.2,         // Coulomb interactions
            MEMBRANE_PERMEABILITY: 0.05,      // Bacterial membrane effects
            ATP_SYNTHESIS_RATE: 0.02,         // Energy metabolism rate
            PROTEIN_FOLDING_FACTOR: 0.15,     // Conformational changes
            DIFFUSION_COEFFICIENT: 0.8        // Brownian motion
        };

        function updatePerformanceMetrics() {
            performanceMetrics.vocabularySize = wordTokenizer.size;
            performanceMetrics.totalMemoryUsage = bacteriaPopulation.reduce((sum, b) => sum + b.memory_bank.length, 0);
            performanceMetrics.lastUpdate = Date.now();
            
            // v829: FPS Calculation
            const now = performance.now();
            if (performanceMetrics.lastFrameTime > 0) {
                const delta = now - performanceMetrics.lastFrameTime;
                performanceMetrics.fps = Math.round(1000 / delta);
                performanceMetrics.frameCount++;
                
                // Update FPS displays
                updateFPSDisplays();
            }
            performanceMetrics.lastFrameTime = now;
            
            // Console debug every 5 seconds
            if (performanceMetrics.frameCount % 300 === 0) { // Roughly every 5 seconds at 60fps
                console.log('üìä v829 Performance:', {
                    fps: performanceMetrics.fps,
                    bacteria: bacteriaPopulation.length,
                    vocabulary: performanceMetrics.vocabularySize,
                    memory: performanceMetrics.totalMemoryUsage
                });
            }
        }

        function updateFPSDisplays() {
            const fpsDisplay = document.getElementById('fpsDisplay');
            const canvasFpsDisplay = document.getElementById('canvasFpsDisplay');
            const bacteriaCountDisplay = document.getElementById('bacteriaCount');
            const dayDisplayElement = document.getElementById('dayDisplay');
            
            if (fpsDisplay) fpsDisplay.textContent = `FPS: ${performanceMetrics.fps}`;
            if (canvasFpsDisplay) canvasFpsDisplay.textContent = performanceMetrics.fps;
            if (bacteriaCountDisplay) bacteriaCountDisplay.textContent = `Bakteri: ${bacteriaPopulation.length}`;
            if (dayDisplayElement) dayDisplayElement.textContent = `G√ºn: ${simulationDay}`;
        }

        // v8.7.1: Enhanced Canvas Initialization with Guaranteed Boundary Update
        function initializeCanvas() {
            canvas = document.getElementById('simCanvas');
            if (canvas) {
                ctx = canvas.getContext('2d');
                
                // üéØ MULTIPLE BOUNDARY UPDATE ATTEMPTS (v8.7.1 FIX)
                // Try immediately
                resizeCanvas();
                
                // Try after DOM ready
                if (document.readyState !== 'complete') {
                    window.addEventListener('DOMContentLoaded', () => {
                        resizeCanvas();
                        console.log('üîß Boundary update on DOMContentLoaded');
                    });
                }
                
                // Try after a short delay
                setTimeout(() => {
                    resizeCanvas();
                    console.log('üîß Boundary update after 100ms delay');
                }, 100);
                
                // Try after a longer delay for insurance
                setTimeout(() => {
                    resizeCanvas();
                    console.log('üîß Boundary update after 500ms delay - guaranteed!');
                }, 500);
                
                useCanvas = true;
                console.log('üé® Canvas initialized with multiple boundary update attempts');
                
                // Add resize listener
                window.addEventListener('resize', resizeCanvas);
                
                // Canvas click handler for bacteria selection and food placement
                canvas.addEventListener('click', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Check if clicked on a bacteria with larger click radius
                    let clickedBacteria = null;
                    let minDistance = Infinity;
                    
                    bacteriaList.forEach(bacteria => {
                        const distance = Math.hypot(bacteria.x - x, bacteria.y - y);
                        const clickRadius = Math.max(25, bacteria.biological_state.size * 15 + 15); // Larger click area
                        
                        if (distance <= clickRadius && distance < minDistance) {
                            minDistance = distance;
                            clickedBacteria = bacteria;
                        }
                    });
                    
                    if (clickedBacteria) {
                        // Select bacteria for individual chat (NO MSGBOX!)
                        selectedBacteria = clickedBacteria;
                        console.log(`üéØ Bacteria SELECTED: ${clickedBacteria.name} (distance: ${minDistance.toFixed(0)})`);
                        
                        // Update bacteria details panel
                        showBacteriaDetails(clickedBacteria);
                        
                        // Switch to individual chat mode
                        switchToIndividualChat(clickedBacteria);
                        
                        // Highlight selected bacteria visually
                        highlightSelectedBacteria(clickedBacteria);
                        
                    } else {
                        // No bacteria clicked, add food instead
                        addFood(x, y);
                    }
                });
            }
        }

        function resizeCanvas() {
            if (!canvas) {
                console.warn('‚ö†Ô∏è resizeCanvas called but canvas is null!');
                return;
            }
            
            const container = canvas.parentElement;
            if (!container) {
                console.warn('‚ö†Ô∏è Canvas parent element not found!');
                return;
            }
            
            const rect = container.getBoundingClientRect();
            console.log(`üîç Canvas container found, getting rect...`);
            
            // üîß CSS-AWARE DYNAMIC PADDING CALCULATION (v8.7.1 FIX)
            const style = window.getComputedStyle(container);
            const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
            const paddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
            
            // Set canvas size with dynamic padding calculation
            canvasWidth = Math.max(400, rect.width - paddingX); // Minimum 400px width
            canvasHeight = Math.max(300, rect.height - paddingY); // Minimum 300px height
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // üéØ UPDATE DYNAMIC BOUNDARIES (E031 FIX)
            DYNAMIC_BOUNDARIES.maxX = canvasWidth - DYNAMIC_BOUNDARIES.padding;
            DYNAMIC_BOUNDARIES.maxY = canvasHeight - DYNAMIC_BOUNDARIES.padding;
            DYNAMIC_BOUNDARIES.minX = DYNAMIC_BOUNDARIES.padding;
            DYNAMIC_BOUNDARIES.minY = DYNAMIC_BOUNDARIES.padding;
            
            console.log(`üîß Canvas resized: ${canvasWidth}x${canvasHeight} (padding: ${paddingX}x${paddingY})`);
            console.log(`üéØ Dynamic boundaries updated:`, DYNAMIC_BOUNDARIES);
            console.log(`üìè Container rect:`, {width: rect.width, height: rect.height, left: rect.left, top: rect.top});
        }
        let nextTokenId = 1;



        // üéØ SYSTEM STATUS TRACKER
        const systemStatus = {
            db: false,
            tabpfn: false,
            tfjs: false,
            simulation: false
        };

        function updateBuildInfo() {
            try {
                const buildInfo = document.getElementById('buildInfo');
                if (!buildInfo) return;
                
                const simStatus = systemStatus.simulation ? 'üü¢ Running' : 'üî¥ Paused';
                const dbStatus = systemStatus.db ? 'üü¢ Connected' : 'üî¥ Offline';
                
                // ML Status: daha detaylƒ±
                let mlStatus = 'üî¥ Loading';
                if (systemStatus.tabpfn && systemStatus.tfjs) {
                    mlStatus = 'üü¢ Full Ready';
                } else if (systemStatus.tabpfn || systemStatus.tfjs) {
                    mlStatus = 'üü° Partial';
                }
                
                // Memory status
                let memStatus = '';
                try {
                    if (typeof MemoryManager !== 'undefined' && MemoryManager.getMemoryUsage) {
                        const memInfo = MemoryManager.getMemoryUsage();
                        memStatus = memInfo.used > 0 ? `üìä ${memInfo.used}MB` : '';
                    }
                } catch (e) { /* ignore */ }
                
                // Learning engine stats
                const learningStats = learningEngine.getStats();
                const successRate = (learningStats.recentSuccessRate * 100).toFixed(0);
                
                buildInfo.innerHTML = `
                    Build: ${BUILD_DATE} | Features: ${FEATURES.length} | 
                    Sim: ${simStatus} | 
                    Chat Mode: <span class="text-yellow-400">${chatMode.toUpperCase()}</span> | 
                    ML: <span class="text-${systemStatus.tabpfn && systemStatus.tfjs ? 'green' : 'orange'}-400">${mlStatus}</span> |
                    DB: ${dbStatus} | 
                    üß† AI Success: <span class="text-cyan-400">${successRate}%</span> | ${memStatus}
                `;
            } catch (error) {
                console.warn('‚ö†Ô∏è updateBuildInfo error (ignored):', error.message);
            }
        }

        // üéØ EVENT-DRIVEN INITIALIZATION LISTENERS
        function initializeEventListeners() {
            // Database ready
            appEvents.on('db:ready', (dbInstance) => {
                console.log('üì° Event: Database ready');
                systemStatus.db = true;
                updateBuildInfo();
            });

            // TabPFN ready  
            appEvents.on('ai:tabpfn:ready', (tabpfnInstance) => {
                console.log('üì° Event: TabPFN AI ready');
                systemStatus.tabpfn = true;
                updateBuildInfo();
            });

            // TensorFlow.js ready
            appEvents.on('ai:tfjs:ready', (tfjsInstance) => {
                console.log('üì° Event: TensorFlow.js AI ready');
                systemStatus.tfjs = true;
                isMLReady = true; // Global flag
                updateBuildInfo();
            });

            // All systems ready
            appEvents.on('all:systems:ready', () => {
                console.log('üì° Event: All systems ready!');
                updateBuildInfo();
                
                // Enable advanced features
                const advancedButtons = document.querySelectorAll('[data-requires-ai]');
                advancedButtons.forEach(btn => {
                    btn.disabled = false;
                    btn.classList.remove('opacity-50');
                });
            });

            // Error handling
            appEvents.on('db:error', (error) => {
                console.error('üì° Event: Database error:', error);
                updateBuildInfo();
            });

            appEvents.on('ai:tfjs:error', (error) => {
                console.error('üì° Event: TensorFlow.js error:', error);
                updateBuildInfo();
            });
        }

        // Vocabulary Stages (Simplified from FUNCTION_ROADMAP.md)
        const vocabularyStages = [
            { stage: 0, name: "Temel ƒ∞htiya√ßlar", words: ["a√ß", "yardƒ±m", "aƒürƒ±"], threshold: 0 },
            { stage: 1, name: "Basit Duygular", words: ["mutlu", "√ºzg√ºn", "korku"], threshold: 3 },
            { stage: 2, name: "√áevresel Kavramlar", words: ["sƒ±cak", "soƒüuk", "yemek"], threshold: 6 },
            { stage: 3, name: "Sosyal Kavramlar", words: ["arkada≈ü", "konu≈ümak", "birlikte"], threshold: 10 },
            { stage: 4, name: "Soyut Kavramlar", words: ["gelecek", "hafƒ±za", "r√ºya"], threshold: 15 },
            { stage: 5, name: "Felsefi D√º≈ü√ºnce", words: ["varolu≈ü", "ama√ß", "bilin√ß"], threshold: 20 }
        ];
        
        const allPossibleWords = vocabularyStages.reduce((acc, stage) => acc.concat(stage.words), []);

        // Initialize word tokenizer with base vocabulary
        function initializeTokenizer() {
            allPossibleWords.forEach(word => {
                if (!wordTokenizer.has(word)) {
                    wordTokenizer.set(word, nextTokenId++);
                }
            });
            console.log('üß† Tokenizer initialized with', wordTokenizer.size, 'words');
        }

        // Create mini neural network for word learning
        async function createWordEmbeddingModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [50], units: 32, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 16, activation: 'relu' }),
                    tf.layers.dense({ units: 8, activation: 'softmax' })
                ]
            });

            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            return model;
        }

        // Create behavior prediction model
        async function createBehaviorModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [12], units: 24, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.1 }),
                    tf.layers.dense({ units: 12, activation: 'relu' }),
                    tf.layers.dense({ units: 6, activation: 'softmax' })
                ]
            });

            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            return model;
        }

        // Extract and learn new words from user input
        function learnFromUserInput(message, bacteria) {
            const words = message.toLowerCase().split(/\s+/);
            let newWordsLearned = 0;

            words.forEach(word => {
                // Clean word
                word = word.replace(/[^\w]/g, '');
                if (word.length < 2) return;

                // Add to tokenizer if new
                if (!wordTokenizer.has(word)) {
                    wordTokenizer.set(word, nextTokenId++);
                    console.log(`üÜï ${bacteria.name} learned new word: "${word}"`);
                    newWordsLearned++;
                }

                // Add to bacteria vocabulary if consciousness allows
                if (bacteria.consciousness_level > 1.5 && Math.random() < 0.6) {
                    bacteria.vocabulary.add(word);
                }
            });

            // Update bacteria memory about learning
            if (newWordsLearned > 0) {
                bacteria.memory_bank.push(`${newWordsLearned} yeni kelime √∂ƒürendim: "${words.join(' ')}"`);
                
                // v822: Enhanced memory consolidation
                bacteria.consolidateMemory();
            }

            return newWordsLearned;
        }

        // üîß V8.9.1: FIXED Promise Issue - Generate new words (synchronous)
        function generateNewWord(bacteria) {
            if (!bacteria || !bacteria.vocabulary) return null;
            
            // Skip async TabPFN for now - causing [object Promise] issue
            // Direct fallback to traditional word generation
            const vocabArray = Array.from(bacteria.vocabulary);
            if (vocabArray.length < 2) {
                // Basic starter words for new bacteria
                const starterWords = ['merhaba', 'ya≈üam', 'b√ºy√ºmek', '√∂ƒürenmek', 'enerji', 'yemek', 'ATP', 'h√ºcre'];
                const newWord = starterWords[Math.floor(Math.random() * starterWords.length)];
                bacteria.vocabulary.add(newWord);
                console.log(`üéØ Basic word "${newWord}" for ${bacteria.name}`);
                return newWord;
            }

            // Simple word combination for compound words
            const word1 = vocabArray[Math.floor(Math.random() * vocabArray.length)];
            const word2 = vocabArray[Math.floor(Math.random() * vocabArray.length)];
            
            if (word1 === word2) return null;

            // Create compound words with Turkish patterns
            const combinations = [
                word1 + word2,
                word1.slice(0, -1) + word2.slice(1),
                word1.slice(0, 2) + word2.slice(-2),
                word1[0] + word2,
                word1 + '-' + word2 // Turkish compound style
            ];

            const newWord = combinations[Math.floor(Math.random() * combinations.length)];
            
            // Add to vocabulary and tokenizer
            if (newWord && newWord.length > 2) {
                bacteria.vocabulary.add(newWord);
                if (!wordTokenizer.has(newWord)) {
                    wordTokenizer.set(newWord, nextTokenId++);
                }
                console.log(`üéØ Compound word "${newWord}" created by ${bacteria.name}`);
                return newWord;
            }

            return null;
        }

        // v8.2.7: TabPFN-powered behavior prediction 
        async function predictBehavior(bacteria, context = 'general') {
            const startTime = performance.now();
            
            // Use real TabPFN model first
            if (tabPFNAdapter && tabPFNAdapter.isReady) {
                try {
                    const behavior = await tabPFNAdapter.adaptBehavior(bacteria, context);
                    performanceMetrics.mlInferenceTime = performance.now() - startTime;
                    console.log(`üéØ TabPFN predicted "${behavior}" for ${bacteria.name} (${(performance.now() - startTime).toFixed(1)}ms)`);
                    return behavior;
                } catch (error) {
                    console.error('‚ùå TabPFN prediction failed:', error);
                }
            }
            
            // Fallback to TensorFlow.js if TabPFN unavailable
            if (realAI && realAI.behaviorModel) {
                try {
                    const behavior = await realAI.predictBehavior(bacteria);
                    await realAI.collectTrainingData(bacteria, behavior);
                    performanceMetrics.mlInferenceTime = performance.now() - startTime;
                    return behavior;
                } catch (error) {
                    console.error('‚ùå Real AI prediction failed:', error);
                }
            }
            
            // Enhanced fallback with real dynamic values (no more placeholders!)
            const features = [
                bacteria.biological_state.age / 100,
                bacteria.biological_state.size / 5,
                bacteria.consciousness_level / 10, // Unlimited now
                bacteria.personality_traits.optimism,
                bacteria.personality_traits.sociability,
                bacteria.vocabulary.size / 20,
                bacteria.memory_bank.length / 10,
                bacteria.hunger, // Real dynamic value!
                bacteria.energy, // Real dynamic value!
                bacteria.biological_state.growth_rate,
                bacteria.getProximityToOthers(), // Real proximity calculation!
                bacteria.getRecentActivityLevel() // Real activity tracking!
            ];

            // Enhanced classification with consciousness-based behavior
            const avgScore = features.reduce((sum, val) => sum + val, 0) / features.length;
            const consciousnessBonus = bacteria.consciousness_level / 50; // Higher consciousness = more sophisticated behavior
            const finalScore = avgScore + consciousnessBonus;
            
            let behavior;
            if (finalScore > 0.8) behavior = 'creative';
            else if (finalScore > 0.6) behavior = 'learner';
            else if (finalScore > 0.4) behavior = 'social';
            else if (finalScore > 0.2) behavior = 'explorer';
            else behavior = 'basic';
            
            performanceMetrics.mlInferenceTime = performance.now() - startTime;
            return behavior;
        }

        // Food Particle Class
        class FoodParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = CONFIG.UI.FOOD_SIZE;
                this.nutrition = FOOD_NUTRITION;
                this.color = '#90EE90'; // Light green
            }
        }

        // Add random food particle to simulation area (DYNAMIC BOUNDARIES FIX)
        function addRandomFood() {
            const x = Math.random() * (DYNAMIC_BOUNDARIES.maxX - DYNAMIC_BOUNDARIES.minX) + DYNAMIC_BOUNDARIES.minX;
            const y = Math.random() * (DYNAMIC_BOUNDARIES.maxY - DYNAMIC_BOUNDARIES.minY) + DYNAMIC_BOUNDARIES.minY;
            addFood(x, y);
        }

        // Add food at specific coordinates
        function addFood(x, y) {
            const food = new FoodParticle(x, y);
            foodParticles.push(food);
            console.log(`üçé Yemek eklendi: (${x.toFixed(0)}, ${y.toFixed(0)})`);
        }

        // --- Core Bacteria Logic (Simplified from System Architecture) ---
        class BacteriaEntity {
            constructor(id, name, existingData = null) {
                this.id = id;
                this.name = name || `Bakteri-${id}`;
                
                if (existingData) {
                    // Restore from database
                    this.biological_state = existingData.biological_state;
                    this.personality_traits = existingData.personality_traits;
                    this.consciousness_level = existingData.consciousness_level; // Unlimited!
                    this.language_stage = existingData.language_stage;
                    this.vocabulary = new Set(existingData.vocabulary);
                    this.memory_bank = existingData.memory_bank;
                    this.conversation_history = existingData.conversation_history;
                    this.x = existingData.position ? existingData.position.x : existingData.x || Math.random() * 400 + 50;
                    this.y = existingData.position ? existingData.position.y : existingData.y || Math.random() * 300 + 50;
                    this.z = existingData.position ? existingData.position.z : existingData.z || Math.random() * 100 + 50;
                    this.vx = existingData.velocity ? existingData.velocity.vx : (Math.random() - 0.5) * 12;
                    this.vy = existingData.velocity ? existingData.velocity.vy : (Math.random() - 0.5) * 12;
                    this.vz = existingData.velocity ? existingData.velocity.vz : (Math.random() - 0.5) * 2;
                    this.color = existingData.color;
                    this.total_runtime_days = existingData.total_runtime_days || 0;
                    this.max_consciousness_reached = existingData.max_consciousness_reached || this.consciousness_level;
                    console.log(`üîÑ Restored bacteria #${id} with consciousness ${this.consciousness_level.toFixed(2)}`);
                } else {
                    // Create new bacteria
                    this.biological_state = {
                        size: parseFloat((Math.random() * 2 + 1).toFixed(2)), // 1-3 ¬µm
                        age: 0,
                        growth_rate: parseFloat((Math.random() * 0.5 + 0.5).toFixed(2)), // 0.5-1.0
                        division_potential: 0, // When it reaches 1, it can divide
                    };
                                    this.personality_traits = {
                    optimism: parseFloat(Math.random().toFixed(2)), // 0-1
                    sociability: parseFloat(Math.random().toFixed(2)), // 0-1
                    humor: parseFloat(Math.random().toFixed(2)), // 0-1 üé≠ Comedy level
                    mood: parseFloat((Math.random() * 0.5 + 0.5).toFixed(2)), // 0.5-1.0 Current mood
                    dark_humor_tolerance: parseFloat(Math.random().toFixed(2)), // V8.8.0: Dark humor filtering
                    humor_attempts: parseFloat((Math.random() * 0.5).toFixed(2)), // How often they try to be funny
                    curiosity: parseFloat(Math.random().toFixed(2)) // For scientific jokes
                };
                    this.consciousness_level = 0; // Start at 0, can grow infinitely!
                    this.language_stage = 0; // 0-5
                    this.vocabulary = new Set();
                    this.memory_bank = []; // Store significant events or learned concepts
                    this.conversation_history = []; // For context in chat
                    // üéØ DYNAMIC POSITION INITIALIZATION (E031 FIX)
                    console.log(`ü¶† Creating bacteria #${id} with boundaries:`, DYNAMIC_BOUNDARIES);
                    this.x = Math.random() * (DYNAMIC_BOUNDARIES.maxX - DYNAMIC_BOUNDARIES.minX) + DYNAMIC_BOUNDARIES.minX;
                    this.y = Math.random() * (DYNAMIC_BOUNDARIES.maxY - DYNAMIC_BOUNDARIES.minY) + DYNAMIC_BOUNDARIES.minY;
                    console.log(`üìç Bacteria #${id} positioned at (${this.x.toFixed(0)}, ${this.y.toFixed(0)})`);
                    this.z = Math.random() * 100 + 50; // Z-depth: 50-150 (pseudo-3D depth)
                    this.vx = (Math.random() - 0.5) * 12; // Velocity (increased to 12 for high-speed dynamic movement)
                    this.vy = (Math.random() - 0.5) * 12;
                    this.vz = (Math.random() - 0.5) * 2; // Slow Z movement for depth variation
                    this.color = this.generateColor();
                    this.total_runtime_days = 0;
                    this.max_consciousness_reached = 0;
                    console.log(`üÜï Created new bacteria #${id}`);
                }
                
                // Persistence tracking
                this.last_save_time = Date.now();
                this.save_interval = 30000; // Save every 30 seconds
                this.consciousness_history = []; // Track consciousness evolution
                
                // v829: Enhanced Dynamic Systems 
                this.hunger = Math.random() * 0.3 + 0.2; // 0.2-0.5 range (less hungry start)
                this.energy = Math.random() * 0.2 + 0.7; // 0.7-0.9 range (more energetic start)
                this.last_food_time = Date.now();
                this.last_interaction_time = Date.now();
                this.activity_log = []; // Track recent activities
                this.interaction_count = 0;
                this.movement_efficiency = 0.8 + Math.random() * 0.2; // 0.8-1.0 movement efficiency

                // v8.5.0: Advanced AI/ML Integration
                this.neuralNetwork = new AdvancedNeuralNetwork();
                this.fitness = 0; // For genetic algorithm
                this.lastDecision = null;
                this.aiExperiences = [];
                this.behaviorPattern = 'explorer'; // Will be learned
                
                // v8.6.0: Advanced Comedy Culture System
                this.lastJokeTime = 0;
                this.canTellJoke = true;
                this.knownJokes = new Set(); // Learned dynamic jokes
                this.jokePreferences = { // What types of jokes this bacteria likes
                    rituel: Math.random(),
                    bilimsel_espri: Math.random() * this.consciousness_level / 10,
                    yaratici_absurt: this.personality_traits.humor,
                    sosyal_mizah: this.personality_traits.sociability
                };
                
                // v8.6.1: Mathematical Comedy Theory
                this.wordFrequencies = new Map(); // Track word usage frequency for surprisal calculations
                this.comedyMetrics = {
                    jokesTold: 0,
                    jokesHeard: 0,
                    jokesUnderstood: 0,
                    averageSurprisal: 0,
                    totalLaughs: 0,
                    comedyRating: 0 // Overall comedy performance
                };
            }

            generateColor() {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            // Simulated daily update
            updateDaily() {
                this.biological_state.age++;
                this.total_runtime_days++;
                
                // Growth and aging effects
                this.biological_state.size += this.biological_state.growth_rate * 0.1;
                this.biological_state.division_potential += 0.1;
                
                // Unlimited consciousness development!
                const consciousnessGrowthRate = 0.02 + (this.vocabulary.size / 100) + (this.memory_bank.length / 50);
                const previousConsciousness = this.consciousness_level;
                this.consciousness_level += consciousnessGrowthRate;
                
                // Track max consciousness reached
                if (this.consciousness_level > this.max_consciousness_reached) {
                    this.max_consciousness_reached = this.consciousness_level;
                }
                
                // Record consciousness evolution
                this.consciousness_history.push({
                    day: this.biological_state.age,
                    level: this.consciousness_level,
                    vocabulary_size: this.vocabulary.size,
                    memory_count: this.memory_bank.length
                });
                
                // Keep last 100 consciousness records
                if (this.consciousness_history.length > 100) {
                    this.consciousness_history.splice(0, 1);
                }
                
                // Language stage progression (no longer limited to 5)
                if (this.consciousness_level >= 1) this.language_stage = Math.max(1, this.language_stage);
                if (this.consciousness_level >= 2) this.language_stage = Math.max(2, this.language_stage);
                if (this.consciousness_level >= 3) this.language_stage = Math.max(3, this.language_stage);
                if (this.consciousness_level >= 5) this.language_stage = Math.max(4, this.language_stage);
                if (this.consciousness_level >= 10) this.language_stage = Math.max(5, this.language_stage);
                if (this.consciousness_level >= 20) this.language_stage = Math.max(6, this.language_stage);
                if (this.consciousness_level >= 50) this.language_stage = Math.max(7, this.language_stage);
                if (this.consciousness_level >= 100) this.language_stage = Math.max(8, this.language_stage);
                
                // Vocabulary expansion based on consciousness level
                if (Math.random() < Math.min(0.9, this.consciousness_level / 10)) {
                    this.learnRandomWord();
                }
                
                // Personality evolution
                if (this.consciousness_level > previousConsciousness + 1) {
                    // Significant consciousness growth affects personality
                    this.personality_traits.optimism = Math.min(1, this.personality_traits.optimism + 0.01);
                    this.memory_bank.push(`Bilin√ß seviyem ${this.consciousness_level.toFixed(2)}'ye ula≈ütƒ±! Kendimi daha zeki hissediyorum.`);
                }
                
                // Enhanced memory consolidation for higher consciousness
                if (this.consciousness_level > 5) {
                    this.consolidateMemory();
                }
                
                // v826: Update dynamic systems
                this.updateDynamicSystems();

                // v8.5.0: AI/ML Updates - Apply learning and make intelligent decisions
                if (behaviourLearningSystem) {
                    behaviourLearningSystem.enhanceBacteriaIntelligence(this);
                }

                // üöÄ TabPFN Vocabulary Learning Integration
                this.performTabPFNLearning();

                // Update fitness based on consciousness, survival, and social success
                this.updateFitness();

                // Make neural network decision for next action
                if (this.neuralNetwork) {
                    this.lastDecision = this.neuralNetwork.makeDecision(this);
                    this.applyAIDecision(this.lastDecision);
                }
                
                // Auto-save to database every 30 seconds
                if (Date.now() - this.last_save_time > this.save_interval) {
                    this.saveToDatabase();
                }
                
                // Log consciousness milestones
                if (this.consciousness_level >= 10 && previousConsciousness < 10) {
                    console.log(`üéØ ${this.name} reached consciousness level 10 - Advanced Intelligence!`);
                }
                if (this.consciousness_level >= 50 && previousConsciousness < 50) {
                    console.log(`üöÄ ${this.name} reached consciousness level 50 - Super Intelligence!`);
                }
                if (this.consciousness_level >= 100 && previousConsciousness < 100) {
                    console.log(`üëë ${this.name} reached consciousness level 100 - Transcendent Intelligence!`);
                }
            }

            async saveToDatabase() {
                if (typeof persistentDB !== 'undefined' && persistentDB && persistentDB.isReady) {
                    await persistentDB.saveBacteria(this);
                    this.last_save_time = Date.now();
                }
            }

            // üöÄ TabPFN Enhanced Learning Performance
            performTabPFNLearning() {
                if (!tabpfnVocabularySystem) return;

                // Determine current behavior context
                const context = this.determineCurrentContext();
                
                // Get TabPFN recommendations
                const recommendations = tabpfnVocabularySystem.recommendWordsForContext(this, context);
                
                // Learn words with enhanced rate
                recommendations.forEach(word => {
                    if (Math.random() < CONFIG.VOCABULARY.CONTEXTUAL_LEARNING_RATE) {
                        const learned = tabpfnVocabularySystem.learnWord(this.id, word, context);
                        if (learned) {
                            this.vocabulary.add(word); // Also add to legacy vocabulary set
                            this.memory_bank.push(`TabPFN: "${word}" kelimesini √∂ƒürendim (${context})`);
                        }
                    }
                });

                // Generate occasional speech
                if (Math.random() < 0.15) { // 15% chance to speak daily
                    const emotion = this.getEmotionalState();
                    const speech = tabpfnVocabularySystem.generateSpeech(this.id, context, emotion);
                    if (speech) {
                        this.speak(speech, context);
                    }
                }

                // Track learning progress
                const progress = tabpfnVocabularySystem.getLearningProgress(this.id, this.consciousness_level);
                if (progress > 0.8 && Math.random() < 0.1) {
                    // Consciousness boost for high vocabulary achievement
                    this.consciousness_level += CONFIG.AI.CONSCIOUSNESS_BOOST_RATE * 2;
                    this.memory_bank.push(`Kelime haznemi geli≈ütirdim! Bilin√ß seviyem y√ºkseldi.`);
                }
            }

            // üéØ Determine current behavioral context
            determineCurrentContext() {
                const timeSinceFood = Date.now() - this.last_food_time;
                const timeSinceInteraction = Date.now() - this.last_interaction_time;
                
                if (this.hunger > 0.7) return 'food_seeking';
                if (this.biological_state.division_potential > 0.8) return 'reproduction';
                if (timeSinceInteraction < 10000) return 'social_interaction';
                if (this.consciousness_level > 10) return 'philosophical';
                if (this.consciousness_level > 5) return 'learning';
                return 'exploration';
            }

            // üòä Get emotional state for speech
            getEmotionalState() {
                if (this.energy > 0.8 && this.hunger < 0.3) return 'happy';
                if (this.consciousness_level > 15) return 'curious';
                if (this.interaction_count > 3) return 'social';
                if (this.energy < 0.3) return 'tired';
                return 'neutral';
            }

            // üß¨ DYNAMIC LANGUAGE EVOLUTION SPEECH SYSTEM v8.7.0
            speak(message, context = 'general', trigger = null) {
                if (!message || typeof message !== 'string') return;
                
                let dynamicMessage = message;
                
                // 1. Dil evrimi motoru ile dinamik cevap olu≈ütur
                if (languageEvolutionEngine && this.vocabulary.size >= 3) {
                    // %70 ≈üansla evrimle≈ümi≈ü dil kullan
                    if (Math.random() < 0.7) {
                        const evolvedResponse = languageEvolutionEngine.generateContextualResponse(this, context, trigger);
                        if (evolvedResponse && evolvedResponse.length > 5) {
                            dynamicMessage = evolvedResponse;
                            console.log(`üß¨ ${this.name} evolved speech: "${dynamicMessage}"`);
                        }
                    }
                    
                    // Kelime mutasyonu uygula
                    const words = dynamicMessage.split(' ');
                    const mutatedWords = words.map(word => {
                        if (this.vocabulary.has(word.toLowerCase()) && Math.random() < 0.2) {
                            return languageEvolutionEngine.mutateWord(this, word);
                        }
                        return word;
                    });
                    dynamicMessage = mutatedWords.join(' ');
                }
                
                // 2. TabPFN Enhanced Word Usage (eski sistem ile birlikte)
                if (tabpfnVocabularySystem && typeof tabpfnVocabularySystem.improveWordUsage === 'function') {
                    try {
                        const suggestedWord = tabpfnVocabularySystem.improveWordUsage(this, context);
                        if (suggestedWord && Math.random() < 0.3) { // %30 ≈üansla TabPFN √∂nerisini ekle
                            dynamicMessage = `${dynamicMessage} + ${suggestedWord}`;
                        }
                    } catch (error) {
                        console.warn('TabPFN word usage error:', error);
                    }
                }
                
                // 3. Ki≈üilik bazlƒ± stil uygula
                if (languageEvolutionEngine) {
                    const style = languageEvolutionEngine.generatePersonalityLanguage(this);
                    
                    // Duygusal yoƒüunluk ekle
                    if (style.emotionLevel > 0.8 && !dynamicMessage.includes('!') && Math.random() < 0.5) {
                        const emotions = ['!', '‚ú®', 'üåü', 'üí´'];
                        dynamicMessage += emotions[Math.floor(Math.random() * emotions.length)];
                    }
                    
                    // Karma≈üƒ±klƒ±k seviyesine g√∂re ek bilgi
                    if (style.complexityPreference > 0.7 && Math.random() < 0.3) {
                        const additionalInfo = languageEvolutionEngine.createWordCombination(this, context, []);
                        if (additionalInfo) {
                            dynamicMessage = `${dynamicMessage} (${additionalInfo})`;
                        }
                    }
                }
                
                // 4. Geli≈ümi≈ü kelime √∂ƒürenimi
                const words = dynamicMessage.split(' ').filter(word => 
                    word.length > 2 && !word.includes('[') && !word.includes(']') && !word.includes('(') && !word.includes(')')
                );
                words.forEach(word => {
                    const cleanWord = word.toLowerCase().replace(/[^\w\u00C0-\u024F\u1E00-\u1EFF]/g, '');
                    if (cleanWord.length > 2) {
                        this.vocabulary.add(cleanWord);
                        
                        // Kelime frekansƒ±nƒ± g√ºncelle (surprisal hesaplamalarƒ± i√ßin)
                        if (!this.wordFrequencies.has(cleanWord)) {
                            this.wordFrequencies.set(cleanWord, 0);
                        }
                        this.wordFrequencies.set(cleanWord, this.wordFrequencies.get(cleanWord) + 1);
                        
                        // Ki≈üisel benzersiz kelimeler
                        if (this.personalLanguageStyle && Math.random() < 0.1) {
                            this.personalLanguageStyle.uniqueWords.add(cleanWord);
                        }
                    }
                });
                
                // 5. Sosyal dil √∂ƒürenimi - yakƒ±ndaki bakteriler dinler ve √∂ƒürenir
                if (languageEvolutionEngine) {
                    const allBacteria = bacteriaPopulation && bacteriaPopulation.length > 0 ? bacteriaPopulation : (bacteriaList || []);
                    allBacteria.forEach(other => {
                        if (other && other.id !== this.id) {
                            const distance = Math.sqrt(
                                Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2)
                            );
                            
                            if (distance < 100) { // 100 piksel mesafede
                                languageEvolutionEngine.shareLinguisticFeature(this, other, dynamicMessage);
                            }
                        }
                    });
                }
                
                // Store conversation with evolution info
                this.conversation_history.push({
                    message: dynamicMessage,
                    originalMessage: message,
                    context: context,
                    timestamp: Date.now(),
                    consciousness: this.consciousness_level,
                    evolved: dynamicMessage !== message,
                    mutationApplied: dynamicMessage.includes('‚ú®') || dynamicMessage.includes('üåü')
                });
                
                // Keep last 50 conversations
                if (this.conversation_history.length > 50) {
                    this.conversation_history.splice(0, 1);
                }
                
                // Use new speech bubble system instead of old one
                showSpeechBubble(this, dynamicMessage);
                
                console.log(`üß¨ ${this.name} evolved speech: "${dynamicMessage}" (Context: ${context}, Original: "${message}")`);
                
                // Return the evolved message for other systems to use
                return dynamicMessage;
            }

            // üé≠ OLD createSpeechBubble REMOVED - Now using unified showSpeechBubble() system

            // üé® Context-based bubble colors
            getBubbleColor(context) {
                const colors = {
                    'food_seeking': '#FF6B35',      // Orange - hunger
                    'social_interaction': '#4ECDC4', // Teal - social
                    'reproduction': '#FF006E',       // Pink - reproduction
                    'exploration': '#8338EC',        // Purple - adventure
                    'learning': '#FFBE0B',          // Yellow - learning
                    'philosophical': '#FB5607',      // Red-orange - deep thought
                    'general': '#219EBC'            // Blue - default
                };
                return colors[context] || colors['general'];
            }

            // üìä Update fitness score for genetic algorithm
            updateFitness() {
                this.fitness = 0;
                
                // Consciousness contribution (40%)
                this.fitness += this.consciousness_level * 4;
                
                // Survival factors (30%)
                this.fitness += this.biological_state.age * 0.5;
                this.fitness += (1 - this.hunger) * 10;
                this.fitness += this.energy * 10;
                
                // Social factors (20%)
                this.fitness += this.conversation_history.length * 0.2;
                this.fitness += this.interaction_count * 0.1;
                
                // Learning factors (10%)
                this.fitness += this.vocabulary.size * 0.1;
                this.fitness += this.memory_bank.length * 0.05;
                
                // Size penalty for overcrowding
                if (this.biological_state.size > CONFIG.BACTERIA.MAX_SIZE * 0.9) {
                    this.fitness *= 0.8;
                }
                
                // Apply fitness decay
                this.fitness *= CONFIG.AI.FITNESS_DECAY;
                
                // üß† SELF-IMPROVEMENT: Track decision outcomes
                if (this._lastDecisionLog) {
                    const previousFitness = this._previousFitness || 0;
                    const fitnessChange = this.fitness - previousFitness;
                    const outcome = fitnessChange > 0 ? 'success' : (fitnessChange < -5 ? 'failure' : 'neutral');
                    
                    const metrics = {
                        fitnessChange,
                        currentFitness: this.fitness,
                        age: this.biological_state.age,
                        consciousness: this.consciousness_level,
                        survival: this.biological_state.age > 10 ? 'good' : 'poor'
                    };
                    
                    learningEngine.trackOutcome(this._lastDecisionLog, outcome, metrics);
                    this._lastDecisionLog = null; // Clear after tracking
                }
                
                this._previousFitness = this.fitness; // Store for next comparison
                return this.fitness;
            }

            learnRandomWord() {
                // Legacy method enhanced with TabPFN
                if (tabpfnVocabularySystem) {
                    const availableWords = tabpfnVocabularySystem.getAvailableWords(this);
                    const randomWord = availableWords[Math.floor(Math.random() * availableWords.length)];
                    if (randomWord && !this.vocabulary.has(randomWord)) {
                        this.vocabulary.add(randomWord);
                        tabpfnVocabularySystem.learnWord(this.id, randomWord, 'general');
                        return;
                    }
                }

                // Fallback to original consciousness-based vocabulary expansion
                let wordPool = [];
                
                if (this.consciousness_level < 1) {
                    wordPool = ['a√ß', 'yardƒ±m', 'hareket'];
                } else if (this.consciousness_level < 5) {
                    wordPool = ['mutlu', 'arkada≈ü', '√∂ƒürenme', 'b√ºy√ºme', 'ke≈üif'];
                } else if (this.consciousness_level < 10) {
                    wordPool = ['bilin√ß', 'd√º≈ü√ºnce', 'felsefe', 'merak', 'anlayƒ±≈ü', 'empati'];
                } else if (this.consciousness_level < 20) {
                    wordPool = ['meta-bili≈ü', 'soyutlama', 'yaratƒ±cƒ±lƒ±k', 'i√ßg√∂r√º', 'karma≈üƒ±klƒ±k'];
                } else if (this.consciousness_level < 50) {
                    wordPool = ['transsendence', 'ontoloji', 'epistemoloji', 'fenomenoloji', 'kognitif-bilim'];
                } else {
                    // Transcendent vocabulary
                    wordPool = ['kozmik-bilin√ß', 'kuantum-zeka', 'multi-dimensional-d√º≈ü√ºnce', 'evrensel-anlayƒ±≈ü'];
                }
                
                if (wordPool.length > 0) {
                    const newWord = wordPool[Math.floor(Math.random() * wordPool.length)];
                    if (!this.vocabulary.has(newWord)) {
                        this.vocabulary.add(newWord);
                        this.memory_bank.push(`"${newWord}" kelimesini √∂ƒürendim! Bilin√ß seviyem: ${this.consciousness_level.toFixed(2)}`);
                    }
                }
            }

            // v826: Dynamic system methods (replacing placeholders)
            updateDynamicSystems() {
                // Hunger increases over time
                const timeSinceFood = (Date.now() - this.last_food_time) / 60000; // minutes
                this.hunger = Math.min(1, this.hunger + timeSinceFood * 0.01);
                
                // Energy decreases with activity and age
                this.energy = Math.max(0, this.energy - 0.002 - (this.biological_state.age * 0.0001));
                
                // Energy affects consciousness development
                if (this.energy < 0.3) {
                    this.consciousness_level *= 0.99; // Slight consciousness decrease when tired
                }
                
                // Update activity log
                this.activity_log.push({
                    timestamp: Date.now(),
                    consciousness: this.consciousness_level,
                    hunger: this.hunger,
                    energy: this.energy
                });
                
                // Keep last 50 activity records
                if (this.activity_log.length > 50) {
                    this.activity_log.splice(0, 1);
                }
            }

            getProximityToOthers() {
                const allBacteria = bacteriaPopulation && bacteriaPopulation.length > 0 ? bacteriaPopulation : (bacteriaList || []);
                if (allBacteria.length < 2) return 0;
                
                let totalDistance = 0;
                let nearbyCount = 0;
                
                allBacteria.forEach(other => {
                    if (other && other.id !== this.id && typeof other.x === 'number' && typeof other.y === 'number') {
                        const distance = Math.sqrt(
                            Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2)
                        );
                        if (distance < 100) { // Within 100px range
                            totalDistance += distance;
                            nearbyCount++;
                        }
                    }
                });
                
                return nearbyCount > 0 ? 1 - (totalDistance / nearbyCount / 100) : 0;
            }

            getRecentActivityLevel() {
                if (this.activity_log.length < 2) return 0.5;
                
                const recent = this.activity_log.slice(-10); // Last 10 activities
                let activityScore = 0;
                
                for (let i = 1; i < recent.length; i++) {
                    const consciousnessDelta = Math.abs(recent[i].consciousness - recent[i-1].consciousness);
                    const energyDelta = Math.abs(recent[i].energy - recent[i-1].energy);
                    activityScore += consciousnessDelta + energyDelta;
                }
                
                return Math.min(1, activityScore / recent.length);
            }

            getInteractionCount() {
                const fiveMinutesAgo = Date.now() - 300000; // 5 minutes
                return this.conversation_history.filter(
                    conv => new Date(conv.timestamp || Date.now()).getTime() > fiveMinutesAgo
                ).length;
            }

            getLearningRate() {
                // Learning rate based on consciousness and recent word acquisition
                const recentMemories = this.memory_bank.filter(
                    mem => mem.includes('√∂ƒürendim')
                ).length;
                
                return Math.min(1, (this.consciousness_level / 10) + (recentMemories / 20));
            }

            feedBacteria() {
                // Called when bacteria eats food
                this.hunger = Math.max(0, this.hunger - 0.3);
                this.energy = Math.min(1, this.energy + 0.2);
                this.last_food_time = Date.now();
                
                // Learning from eating
                if (Math.random() < 0.3) {
                    this.vocabulary.add('lezzetli');
                    this.memory_bank.push('Besini t√ºketdim ve enerjim arttƒ±!');
                }
            }

            interactWithOther(otherBacteria) {
                // Called during social interactions
                this.interaction_count++;
                this.last_interaction_time = Date.now();
                
                // Share vocabulary
                if (this.consciousness_level > 2 && Math.random() < 0.4) {
                    const myWords = Array.from(this.vocabulary);
                    const otherWords = Array.from(otherBacteria.vocabulary);
                    
                    // Learn from each other
                    if (otherWords.length > 0) {
                        const randomWord = otherWords[Math.floor(Math.random() * otherWords.length)];
                        this.vocabulary.add(randomWord);
                        this.memory_bank.push(`${otherBacteria.name}'den "${randomWord}" kelimesini √∂ƒürendim`);
                    }
                }
                
                // Collect training data for real AI
                if (realAI && realAI.behaviorModel) {
                    const behavior = Math.random() > 0.5 ? 'social' : 'learner';
                    realAI.collectTrainingData(this, behavior);
                }
            }

            move() {
                // v829: High-Speed Molecular Dynamics enhanced movement
                
                // Apply van der Waals forces between bacteria
                this.applyMolecularForces();
                
                // Enhanced Brownian motion with energy-based movement
                const energyBoost = this.energy * 0.5; // Energy affects movement speed
                const hungerMotivation = this.hunger * 0.3; // Hunger drives exploration
                
                this.vx += (Math.random() - 0.5) * MD_CONSTANTS.DIFFUSION_COEFFICIENT * (0.15 + energyBoost);
                this.vy += (Math.random() - 0.5) * MD_CONSTANTS.DIFFUSION_COEFFICIENT * (0.15 + energyBoost);
                
                // Add exploration behavior when hungry
                if (this.hunger > 0.6) {
                    this.vx += (Math.random() - 0.5) * hungerMotivation;
                    this.vy += (Math.random() - 0.5) * hungerMotivation;
                }
                
                // Reduced friction for more dynamic movement
                this.vx *= 0.99; // Minimal friction for fast movement
                this.vy *= 0.99;
                
                // Apply movement efficiency (3D movement)
                const efficiencyFactor = this.movement_efficiency;
                this.x += this.vx * efficiencyFactor;
                this.y += this.vy * efficiencyFactor;
                this.z += this.vz * efficiencyFactor; // Z-axis movement
                
                // üéØ DYNAMIC BOUNDARY CHECKING (E031 FIX) - Uses real canvas size!
                if (this.x <= DYNAMIC_BOUNDARIES.minX || this.x >= DYNAMIC_BOUNDARIES.maxX) {
                    // DEBUG: Log boundary collision
                    if (Math.random() < 0.01) { // 1% chance to avoid spam
                        console.log(`üî• ${this.name} X boundary hit! x=${this.x.toFixed(0)}, bounds=[${DYNAMIC_BOUNDARIES.minX}, ${DYNAMIC_BOUNDARIES.maxX}]`);
                    }
                    this.vx *= -CONFIG.PHYSICS.BOUNDARY_ENERGY_LOSS;
                    this.x = Math.max(DYNAMIC_BOUNDARIES.minX, Math.min(DYNAMIC_BOUNDARIES.maxX, this.x));
                }
                if (this.y <= DYNAMIC_BOUNDARIES.minY || this.y >= DYNAMIC_BOUNDARIES.maxY) {
                    // DEBUG: Log boundary collision  
                    if (Math.random() < 0.01) { // 1% chance to avoid spam
                        console.log(`üî• ${this.name} Y boundary hit! y=${this.y.toFixed(0)}, bounds=[${DYNAMIC_BOUNDARIES.minY}, ${DYNAMIC_BOUNDARIES.maxY}]`);
                    }
                    this.vy *= -CONFIG.PHYSICS.BOUNDARY_ENERGY_LOSS;
                    this.y = Math.max(DYNAMIC_BOUNDARIES.minY, Math.min(DYNAMIC_BOUNDARIES.maxY, this.y));
                }
                if (this.z <= CONFIG.PHYSICS.Z_DEPTH_MIN || this.z >= CONFIG.PHYSICS.Z_DEPTH_MAX) {
                    this.vz *= -(CONFIG.PHYSICS.BOUNDARY_ENERGY_LOSS - 0.1); // Slightly less Z energy loss
                    this.z = Math.max(CONFIG.PHYSICS.Z_DEPTH_MIN, Math.min(CONFIG.PHYSICS.Z_DEPTH_MAX, this.z));
                }

                            // Look for nearby food with increased range when hungry
            this.lookForFood();
            
            // üé≠ COMEDY SYSTEM: Sometimes tell jokes if mood is good!
            this.checkForJokeTime();
            }

            // Molecular Dynamics: Van der Waals and Electrostatic Forces
            applyMolecularForces() {
                const allBacteria = bacteriaPopulation && bacteriaPopulation.length > 0 ? bacteriaPopulation : (bacteriaList || []);
                allBacteria.forEach(otherBacteria => {
                    if (!otherBacteria || otherBacteria.id === this.id || typeof otherBacteria.x !== 'number') return;
                    
                    const dx = otherBacteria.x - this.x;
                    const dy = otherBacteria.y - this.y;
                    const dz = (otherBacteria.z || 100) - (this.z || 100); // Z-distance
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz); // 3D distance
                    
                    if (distance > 0 && distance < 50) { // Interaction range
                        // Van der Waals force (Lennard-Jones potential)
                        const sigma = (this.biological_state.size + otherBacteria.biological_state.size) * 2;
                        const r6 = Math.pow(sigma/distance, 6);
                        const r12 = r6 * r6;
                        const vdwForce = MD_CONSTANTS.VAN_DER_WAALS_STRENGTH * (12*r12 - 6*r6) / distance;
                        
                        // Electrostatic interaction (simplified Coulomb)
                        const chargeProduct = this.consciousness_level * otherBacteria.consciousness_level;
                        const electrostaticForce = MD_CONSTANTS.ELECTROSTATIC_FORCE * chargeProduct / (distance*distance);
                        
                        // Total force
                        const totalForce = vdwForce + electrostaticForce;
                        const fx = totalForce * dx / distance;
                        const fy = totalForce * dy / distance;
                        const fz = totalForce * dz / distance;
                        
                        // Apply force (Newton's law) - 3D
                        this.vx -= fx * 0.01;
                        this.vy -= fy * 0.01;
                        this.vz = (this.vz || 0) - fz * 0.005; // Lighter Z force
                        
                        // Social learning through proximity (MD-enhanced)
                        if (distance < 30 && Math.random() < 0.02) {
                            this.learnFromProximity(otherBacteria);
                        }
                    }
                });
            }

            // Enhanced social learning through molecular proximity
            learnFromProximity(otherBacteria) {
                // Exchange vocabulary (molecular diffusion analogy)
                const otherVocab = Array.from(otherBacteria.vocabulary);
                if (otherVocab.length > 0 && Math.random() < 0.3) {
                    const randomWord = otherVocab[Math.floor(Math.random() * otherVocab.length)];
                    this.vocabulary.add(randomWord);
                    this.memory_bank.push(`Molek√ºler etkile≈üim: ${otherBacteria.name}'den "${randomWord}" kelimesini √∂ƒürendim`);
                    
                    // Consciousness boost from molecular interaction (unlimited)
                    this.consciousness_level = this.consciousness_level + 0.01;
                }
            }

            lookForFood() {
                for (let i = foodParticles.length - 1; i >= 0; i--) {
                    const food = foodParticles[i];
                    const distance = Math.sqrt(
                        Math.pow(this.x - food.x, 2) + Math.pow(this.y - food.y, 2)
                    );
                    
                    // If close enough to eat food
                    if (distance < this.biological_state.size * 8 + food.size) {
                        this.eatFood(food);
                        foodParticles.splice(i, 1);
                        break;
                    }
                }
            }

            eatFood(food) {
                // v829: Enhanced ATP Synthesis with dynamic systems
                const atpGenerated = this.synthesizeATP(food.nutrition);
                
                // Metabolic pathway simulation - controlled growth using CONFIG
                const growthAmount = food.nutrition * CONFIG.BACTERIA.BASE_GROWTH_RATE * (1 + atpGenerated);
                this.biological_state.size = Math.min(CONFIG.BACTERIA.MAX_SIZE, this.biological_state.size + growthAmount);
                this.biological_state.growth_rate = Math.min(1.3, this.biological_state.growth_rate + 0.08); // Controlled max growth
                
                // Dynamic systems update
                this.hunger = Math.max(0, this.hunger - 0.4); // Reduce hunger more effectively
                this.energy = Math.min(1, this.energy + 0.3); // Boost energy significantly
                this.last_food_time = Date.now();
                
                // Protein folding effects on consciousness (unlimited)
                const proteinFoldingBoost = MD_CONSTANTS.PROTEIN_FOLDING_FACTOR * atpGenerated;
                const nutritionBonus = food.nutrition * 0.1; // Nutrition affects consciousness gain
                this.consciousness_level = this.consciousness_level + 0.08 + proteinFoldingBoost + nutritionBonus;
                
                // Enhanced memory with metabolic context
                this.memory_bank.push(`ATP sentezi: ${atpGenerated.toFixed(3)} enerji √ºrettim. A√ßlƒ±ƒüƒ±m azaldƒ±, enerjim arttƒ±!`);
                
                // Learn biochemical words with association learning
                if (Math.random() < 0.8) { // Increased learning chance when eating
                    const biochemWords = ['ATP', 'metabolizma', 'enzim', 'protein', 'lezzetli', 'enerji', 'sentez', 'beslenme', 'g√º√ßl√º'];
                    const randomWord = biochemWords[Math.floor(Math.random() * biochemWords.length)];
                    this.vocabulary.add(randomWord);
                    
                    // Association learning - connect eating with positive words
                    if (Math.random() < 0.3) {
                        const positiveWords = ['mutlu', 'g√º√ßl√º', 'saƒülƒ±klƒ±', 'geli≈üim', 'b√ºy√ºme'];
                        const positiveWord = positiveWords[Math.floor(Math.random() * positiveWords.length)];
                        this.vocabulary.add(positiveWord);
                        this.memory_bank.push(`Yemek yerken "${positiveWord}" hissediyorum!`);
                    }
                }
            }

            // ATP Synthesis Simulation (based on MD research)
            synthesizeATP(nutrition) {
                // Simplified ATP synthase mechanism
                const protonGradient = this.consciousness_level / 5; // Mental energy affects ATP
                const enzymeEfficiency = 0.8 + (this.biological_state.growth_rate - 0.5) * 0.4;
                
                // ATP = nutrition √ó gradient √ó efficiency √ó MD rate constant
                const atpOutput = nutrition * protonGradient * enzymeEfficiency * MD_CONSTANTS.ATP_SYNTHESIS_RATE;
                
                return Math.min(1.0, atpOutput); // Max 1.0 ATP per food
            }

            // v822: Enhanced Memory Consolidation System
            consolidateMemory() {
                // Keep only important memories, remove duplicates
                if (this.memory_bank.length > 15) {
                    // Keep last 10 memories and most important ones
                    const recentMemories = this.memory_bank.slice(-10);
                    const importantMemories = this.memory_bank.filter(m => 
                        m.includes('√∂ƒürendim') || m.includes('icat ettim') || m.includes('arkada≈ü')
                    ).slice(-5);
                    
                    this.memory_bank = [...new Set([...importantMemories, ...recentMemories])];
                    console.log(`üß† ${this.name} memory consolidated: ${this.memory_bank.length} memories kept`);
                }
            }

            // v829: Enhanced Reproduction System (Balanced for dynamic population)
            checkForReproduction() {
                // Dynamic reproduction requirements using CONFIG
                if (this.biological_state.age < CONFIG.BACTERIA.REPRODUCTION_MIN_AGE ||
                    this.biological_state.size < CONFIG.BACTERIA.REPRODUCTION_MIN_SIZE ||
                    this.consciousness_level < CONFIG.BACTERIA.REPRODUCTION_MIN_CONSCIOUSNESS ||
                    this.vocabulary.size < CONFIG.BACTERIA.REPRODUCTION_MIN_VOCABULARY ||
                    bacteriaPopulation.length >= CONFIG.SIMULATION.MAX_BACTERIA_POPULATION) {
                    return false;
                }

                // Enhanced reproduction chance calculation
                const reproductionChance = 
                    (this.biological_state.size - 1.2) * 0.15 + // Increased size factor
                    (this.consciousness_level - 1) * 0.08 + // Increased intelligence factor
                    (this.vocabulary.size - 5) * 0.02 + // Increased vocabulary factor
                    (this.biological_state.growth_rate - 0.5) * 0.1 + // Growth rate factor
                    (this.energy > 0.7 ? 0.03 : 0) + // Energy bonus
                    (this.hunger < 0.3 ? 0.02 : 0); // Well-fed bonus

                // Increased reproduction chance: 8% maximum for dynamic population
                if (Math.random() < Math.min(0.08, reproductionChance)) {
                    this.reproduce();
                    return true;
                }
                return false;
            }

            reproduce() {
                // Create offspring with inherited traits
                const childId = bacteriaIdCounter++;
                const childName = this.generateChildName();
                
                // Position near parent but not exactly same spot (3D)
                const offsetX = (Math.random() - 0.5) * 60;
                const offsetY = (Math.random() - 0.5) * 60;
                const offsetZ = (Math.random() - 0.5) * 30; // Smaller Z offset
                
                const childData = {
                    id: childId,
                    name: childName,
                    position: {
                        x: Math.max(20, Math.min(480, this.x + offsetX)),
                        y: Math.max(20, Math.min(280, this.y + offsetY)),
                        z: Math.max(20, Math.min(180, this.z + offsetZ))
                    },
                    velocity: {
                        vx: (Math.random() - 0.5) * 8, // Slightly slower than parent
                        vy: (Math.random() - 0.5) * 8,
                        vz: (Math.random() - 0.5) * 2  // Slow Z movement
                    },
                    
                    // Inherit some traits with mutations
                    biological_state: {
                        size: 0.8 + Math.random() * 0.4, // Start smaller
                        age: 0,
                        growth_rate: this.biological_state.growth_rate * (0.9 + Math.random() * 0.2)
                    },
                    
                    // Personality inheritance with minor mutations
                    personality_traits: {
                        optimism: Math.max(0.1, Math.min(1.0, this.personality_traits.optimism + (Math.random() - 0.5) * 0.2)),
                        sociability: Math.max(0.1, Math.min(1.0, this.personality_traits.sociability + (Math.random() - 0.5) * 0.2))
                    },
                    
                    // Start with lower consciousness but inherit some vocabulary
                    consciousness_level: 0.5 + Math.random() * 0.5,
                    vocabulary: new Set(Array.from(this.vocabulary).slice(0, Math.floor(this.vocabulary.size * 0.3))), // 30% inherited vocabulary
                    memory_bank: [`${this.name} annemden/babamdan doƒüdum!`, 'D√ºnyaya geldim, √ßok heyecanlƒ±yƒ±m!'],
                    conversation_history: [],
                    color: this.generateColor()
                };

                const child = new BacteriaEntity(childId, childName, childData);
                bacteriaPopulation.push(child);
                bacteriaList.push(child);

                // Parent memories and energy cost
                this.memory_bank.push(`${childName} adƒ±nda bir √ßocuƒüum d√ºnyaya geldi! Mutluyum ama yorgunum.`);
                this.biological_state.size *= 0.8; // Parent becomes smaller after reproduction
                this.consciousness_level += 0.1; // Gain wisdom from parenting
                
                // Learn parenting vocabulary
                ['anne', 'baba', '√ßocuk', 'doƒüum', 'mutluluk', 'aile'].forEach(word => {
                    if (Math.random() < 0.7) this.vocabulary.add(word);
                });

                console.log(`üë∂ ${this.name} reproduced! Child: ${childName} (Population: ${bacteriaPopulation.length})`);
                
                // Visual birth effect
                this.addBirthEffect(child);
            }

            generateChildName() {
                const prefixes = ['Mini', 'K√º√ß√ºk', 'Gen√ß', 'Yeni', 'Bebek'];
                const suffixes = ['Jr', 'II', '√áocuk', 'Minik'];
                
                const usePrefix = Math.random() < 0.5;
                if (usePrefix) {
                    return `${prefixes[Math.floor(Math.random() * prefixes.length)]} ${this.name}`;
                } else {
                    return `${this.name} ${suffixes[Math.floor(Math.random() * suffixes.length)]}`;
                }
            }

            addBirthEffect(child) {
                // Simple visual effect for birth (mobile-optimized)
                if (typeof renderBacteria === 'function') {
                    setTimeout(() => {
                        renderBacteria();
                        console.log(`üéâ ${child.name} is now visible!`);
                    }, 100);
                }
            }

            // üß† AI DECISION APPLICATION SYSTEM (E030 FIX)
            applyAIDecision(decision) {
                if (!decision) {
                    console.warn(`‚ö†Ô∏è ${this.name} i√ßin AI kararƒ± alƒ±namadƒ± veya ge√ßersiz.`);
                    return;
                }

                try {
                    // üéØ Hareket kararlarƒ±nƒ± uygula
                    if (decision.moveDirection) {
                        const moveSpeed = CONFIG.PHYSICS.INTERACTION_RANGE * 0.1; // Use CONFIG
                        const randomFactor = Math.random() * 0.5 + 0.75; // 0.75-1.25 √ßarpanƒ±
                        
                        this.vx += decision.moveDirection.x * moveSpeed * randomFactor;
                        this.vy += decision.moveDirection.y * moveSpeed * randomFactor;
                        this.vz = (this.vz || 0) + (decision.moveDirection.z || 0) * moveSpeed * 0.5;
                    }

                    // üçØ Yemek arama davranƒ±≈üƒ±nƒ± tetikle
                    if (decision.seekFood && this.hunger > 0.3) {
                        let closestFood = null;
                        let minDistance = Infinity;
                        
                        foodParticles.forEach(food => {
                            const distance = Math.sqrt(
                                Math.pow(this.x - food.x, 2) + 
                                Math.pow(this.y - food.y, 2)
                            );
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestFood = food;
                            }
                        });
                        
                        if (closestFood && minDistance > 0) {
                            const attractionForce = 3 * (this.hunger + 0.5); // Hunger increases attraction
                            this.vx += (closestFood.x - this.x) / minDistance * attractionForce;
                            this.vy += (closestFood.y - this.y) / minDistance * attractionForce;
                        }
                    }

                    // üë´ Sosyalle≈üme davranƒ±≈üƒ±nƒ± tetikle
                    if (decision.socialize && this.personality_traits.sociability > 0.3) {
                        // Yakƒ±ndaki bakterilerle etkile≈üim ba≈ülat
                        bacteriaPopulation.forEach(otherBacteria => {
                            if (otherBacteria.id !== this.id) {
                                const distance = Math.sqrt(
                                    Math.pow(this.x - otherBacteria.x, 2) + 
                                    Math.pow(this.y - otherBacteria.y, 2)
                                );
                                
                                if (distance < CONFIG.PHYSICS.INTERACTION_RANGE && Math.random() < 0.2) {
                                    // Bakteriye doƒüru hafif y√∂nelim
                                    const socialForce = this.personality_traits.sociability * 2;
                                    this.vx += (otherBacteria.x - this.x) / distance * socialForce;
                                    this.vy += (otherBacteria.y - this.y) / distance * socialForce;
                                    
                                    // Rastgele konu≈üma ba≈ülat
                                    if (typeof this.speak === "function" && Math.random() < 0.15) {
                                        const socialWords = ['merhaba', 'arkada≈ü', 'dostluk', 'beraber', 'konu≈üma'];
                                        const randomWord = socialWords[Math.floor(Math.random() * socialWords.length)];
                                        this.speak(`${this.name} ${randomWord} diyor!`, "social_interaction");
                                    }
                                }
                            }
                        });
                    }

                    // üë∂ √úreme davranƒ±≈üƒ±nƒ± tetikle
                    if (decision.reproduce && typeof this.checkForReproduction === 'function') {
                        if (Math.random() < 0.4) { // AI kararƒ±yla √ºreme ≈üansƒ±nƒ± artƒ±r
                            this.checkForReproduction();
                        }
                    }

                    // üéì √ñƒürenme davranƒ±≈üƒ±nƒ± tetikle
                    if (decision.learn) {
                        if (Math.random() < 0.6) {
                            this.learnRandomWord();
                            this.consciousness_level += CONFIG.AI.CONSCIOUSNESS_BOOST_RATE;
                        }
                    }

                    // üó£Ô∏è Konu≈üma davranƒ±≈üƒ±nƒ± tetikle
                    if (decision.speak && typeof this.speak === 'function' && Math.random() < 0.3) {
                        const context = this.determineCurrentContext();
                        const emotion = this.getEmotionalState();
                        this.speak(`AI kararƒ±yla ${emotion} hissediyorum!`, context);
                    }

                    // üìä SystemLearningEngine i√ßin AI karar takibi
                    if (learningEngine && this._lastDecisionLog) {
                        learningEngine.logDecision(
                            'bacteria_ai_decision', 
                            { bacteriaId: this.id, decisionType: Object.keys(decision) },
                            'applied',
                            0.8, // Confidence level
                            {
                                hunger: this.hunger,
                                energy: this.energy,
                                consciousness: this.consciousness_level,
                                timestamp: Date.now()
                            }
                        );
                    }

                    // DEBUG: AI karar uygulama logu
                    console.log(`üß† ${this.name} AI kararƒ±nƒ± uyguladƒ±:`, {
                        moveDirection: !!decision.moveDirection,
                        seekFood: !!decision.seekFood,
                        socialize: !!decision.socialize,
                        reproduce: !!decision.reproduce,
                        learn: !!decision.learn,
                        speak: !!decision.speak,
                        vx: this.vx.toFixed(2),
                        vy: this.vy.toFixed(2)
                    });

                } catch (error) {
                    console.error(`‚ùå AI karar uygulama hatasƒ± (${this.name}):`, error);
                    
                    // Error tracking for SystemLearningEngine
                    if (learningEngine) {
                        learningEngine.logDecision(
                            'bacteria_ai_decision_error',
                            { bacteriaId: this.id, error: error.message },
                            'failure',
                            0.1, // Low confidence due to error
                            { errorType: 'applyAIDecision', timestamp: Date.now() }
                        );
                    }
                }
            }
            
            // üé≠ COMEDY SYSTEM V8.8.0: EMERGENCY FIX + CSV INTEGRATION
            checkForJokeTime() {
                // Check for manual joke triggers first
                if (this.checkForJokeTriggers()) return;
                
                // Mathematical comedy timing with sigmoid probability
                if (!this.canTellJoke || !jokeMasterInstance) return;
                
                const timeSinceLastJoke = Date.now() - (this.lastJokeTime || 0);
                
                // Mathematical joke probability calculation
                if (timeSinceLastJoke > COMEDY_MATH_CONFIG.JOKE_COOLDOWN && 
                    jokeMasterInstance.isEligibleForJoke(this)) {
                    
                    // Use mathematical sigmoid model for joke probability
                    const jokeProbability = ComedyMath.calculateJokeProbability(this);
                    const randomThreshold = Math.random();
                    
                    // üî• CRITICAL FIX: Increased from 0.001 to 0.1 (10% base chance)
                    if (randomThreshold < jokeProbability * 0.1) {
                        this.attemptToTellJoke();
                        console.log(`üßÆ ${this.name} tells joke with probability: ${(jokeProbability*100).toFixed(1)}%`);
                    }
                }
            }

            // üé≠ NEW: Manual joke trigger detection
            checkForJokeTriggers() {
                // Check recent messages for joke triggers
                const recentMessages = this.memory_bank.slice(-3);
                const allRecent = recentMessages.join(' ').toLowerCase();
                
                if (allRecent.includes('vur joker vur') || allRecent.includes('≈üaka yap') || allRecent.includes('komik s√∂yle')) {
                    console.log(`üé™ ${this.name} detected joke trigger!`);
                    this.attemptToTellJoke(true); // Force joke
                    return true;
                }
                return false;
            }
            
            attemptToTellJoke(forced = false) {
                if (!jokeMasterInstance) return;

                const joke = jokeMasterInstance.tryTellingJoke(this, forced);
                if (joke) {
                    this.lastJokeTime = Date.now();
                    this.canTellJoke = false;
                    
                    // Cooldown with some randomness
                    setTimeout(() => { 
                        this.canTellJoke = true; 
                    }, JOKE_CONFIG.JOKE_COOLDOWN + Math.random() * 10000);

                    // Enhanced mood boost for telling jokes
                    const moodBoost = joke.culturalValue * JOKE_CONFIG.JOKE_MORALE_BOOST;
                    this.personality_traits.mood = Math.min(1.0, this.personality_traits.mood + moodBoost);
                    
                    // Learn comedy words
                    this.vocabulary.add('≈üaka');
                    this.vocabulary.add('komedi');
                    if (joke.category === 'rituel') {
                        this.vocabulary.add('k√ºlt√ºr');
                        this.vocabulary.add('gelenek');
                    }
                    
                    this.memory_bank.push(`${joke.category} kategorisinde ≈üaka s√∂yledim: "${joke.text}"`);
                    
                    console.log(`üé≠ ${this.name} (${joke.category}) ≈üaka s√∂yl√ºyor: ${joke.text}`);
                    
                    // Emit joke event for advanced reaction system
                    if (typeof appEvents !== 'undefined') {
                        appEvents.emit('joke:told', { jokeData: joke, originator: this });
                    } else {
                        // Fallback to direct method
                        this.broadcastJokeToNearby(joke);
                    }
                    
                    return joke;
                }
            }
            
            broadcastJokeToNearby(joke) {
                let listenerCount = 0;
                let successCount = 0;
                
                bacteriaPopulation.forEach(other => {
                    if (other.id === this.id) return;
                    
                    const distance = Math.sqrt(
                        Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2)
                    );
                    
                    if (distance < JOKE_CONFIG.MAX_JOKE_DISTANCE) {
                        listenerCount++;
                        const reactionResult = other.reactToAdvancedJoke(joke);
                        if (reactionResult.understood && reactionResult.laughed) {
                            successCount++;
                        }
                    }
                });
                
                // Record outcome in JokeMaster
                if (jokeMasterInstance) {
                    const wasSuccessful = successCount > 0 && (successCount / Math.max(1, listenerCount)) > 0.5;
                    jokeMasterInstance.recordJokeOutcome(joke.text, wasSuccessful, listenerCount);
                }
            }
            
            // üé≠ V8.8.0: CSV-Powered Personality-Based Reaction System
            reactToAdvancedJoke(jokeData) {
                const jokerName = jokeData.originator ? jokeData.originator.name : 'someone';
                const joke = jokeData.text;
                
                // Mathematical reaction calculation using incongruity absorption
                
                // Calculate joke surprisal from listener's perspective
                const words = joke.split(' ').filter(w => w.length > 2);
                const jokeSuprisal = words.reduce((sum, word) => 
                    sum + ComedyMath.calculateSurprisal(word, 'listener_context', this), 0) / Math.max(words.length, 1);
                
                // Calculate incongruity absorption (IA) using mathematical model
                const incongruityAbsorption = ComedyMath.calculateIncongruityAbsorption(joke, this, jokeSuprisal);
                
                // Understanding threshold based on mathematical model
                const understood = incongruityAbsorption >= COMEDY_MATH_CONFIG.UNDERSTANDING_THRESHOLD;
                
                // Calculate laugh probability using mathematical formula
                const laughProbability = ComedyMath.calculateLaughProbability(incongruityAbsorption, this);
                
                // Mathematical reaction selection
                let reactionText = "";
                const actuallyLaughed = Math.random() < laughProbability;
                
                if (understood) {
                    if (actuallyLaughed) {
                        // Positive reactions for understood + laughed
                        const positiveReactions = jokeData.responses.filter(r => 
                            r.includes('haha') || r.includes('komik') || r.includes('üòÇ') || r.includes('üòÑ'));
                        reactionText = positiveReactions.length > 0 ? 
                            positiveReactions[Math.floor(Math.random() * positiveReactions.length)] :
                            jokeData.responses[Math.floor(Math.random() * jokeData.responses.length)];
                    } else {
                        // Understood but didn't laugh
                        reactionText = ["anlƒ±yorum ama... ü§î", "hmm üòê", "ilgin√ß üßê"][Math.floor(Math.random() * 3)];
                    }
                    
                    // Mathematical mood boost calculation
                    let moodBoost = COMEDY_MATH_CONFIG.BASE_MORALE_BOOST * incongruityAbsorption;
                    if (jokeData.category === 'rituel') moodBoost += COMEDY_MATH_CONFIG.RITUAL_BONUS;
                    if (actuallyLaughed) moodBoost *= 1.5; // Extra boost for actual laughter
                    
                    this.personality_traits.mood = Math.min(1.0, this.personality_traits.mood + moodBoost);
                    this.personality_traits.optimism = Math.min(1.0, this.personality_traits.optimism + moodBoost * 0.5);
                    
                    // Learn from joke
                    this.vocabulary.add('komik');
                    this.vocabulary.add('eƒülenceli');
                    if (jokeData.category === 'rituel') {
                        this.vocabulary.add('k√ºlt√ºr');
                        this.memory_bank.push(`${jokerName} ile k√ºlt√ºrel bir anƒ± payla≈ütƒ±k: "${joke}"`);
                    }
                    
                } else {
                    // Confused reactions
                    const confusedReactions = ["?", "Ne dedi?", "Anlamadƒ±m... ü§î", "Bu da ne?", "Hmm... üòï"];
                    reactionText = confusedReactions[Math.floor(Math.random() * confusedReactions.length)];
                    
                    // Slight mood decrease for not understanding
                    this.personality_traits.mood = Math.max(0, this.personality_traits.mood - 0.01);
                }
                
                // Display reaction
                console.log(`${understood ? 'üòÇ' : 'ü§î'} ${this.name} ${jokerName}'in ≈üakasƒ±na: "${reactionText}"`);
                
                // Add to memory
                this.memory_bank.push(`${jokerName}'in ≈üakasƒ±: "${joke}" - ${understood ? 'Anladƒ±m ve g√ºld√ºm' : 'Anlamadƒ±m'}`);
                
                // Social bonding for successful jokes
                if (understood && laughed && Math.random() < 0.4) {
                    this.vocabulary.add('arkada≈ü');
                    this.memory_bank.push(`${jokerName} ile ≈üaka √ºzerinden baƒü kurduk!`);
                }
                
                return { understood, laughed, reactionText };
            }
        }

        // üé≠ V8.9.1: MISSING JOKE TRIGGER DETECTION FUNCTION
        function checkForJokeTriggers(message, bacteria) {
            if (!message || !bacteria || !jokeMasterInstance) return null;
            
            // Check for explicit joke triggers
            const messageText = message.toLowerCase();
            if (messageText.includes('vur joker vur') || messageText.includes('≈üaka yap') || messageText.includes('komik s√∂yle')) {
                console.log(`üé™ ${bacteria.name} detected joke trigger in message: ${message}`);
                
                // Force bacteria to tell a joke
                const joke = jokeMasterInstance.tryTellingJoke(bacteria, true);
                if (joke) {
                    console.log(`üé≠ ${bacteria.name} tells forced joke: ${joke.text}`);
                    return joke.text;
                }
            }
            
            return null;
        }

        // üöÄ V8.9.1: REVOLUTIONARY ANTI-PATTERN LANGUAGE EVOLUTION RESPONSE GENERATOR
        async function generateBacteriaResponse(bacteria, message, context = 'user') {
            const age = bacteria.biological_state.age;
            const consciousness = bacteria.consciousness_level;
            const vocabularySize = bacteria.vocabulary.size;
            const optimism = bacteria.personality_traits.optimism;
            const sociability = bacteria.personality_traits.sociability;
            
            // Learn from user input (unlimited consciousness)
            if (context === 'user') {
                const newWords = learnFromUserInput(message, bacteria);
                if (newWords > 0) {
                    bacteria.consciousness_level = bacteria.consciousness_level + 0.02;
                }
            }
            
            // üé≠ V8.9.1: CHECK FOR JOKE TRIGGERS FIRST
            const jokeResponse = checkForJokeTriggers(message, bacteria);
            if (jokeResponse) {
                console.log(`üé≠ ${bacteria.name} joke triggered: ${jokeResponse.substring(0, 50)}...`);
                return jokeResponse;
            }
            
            // üß¨ v9.5.0: ULTRA-AGGRESSIVE ANTI-MONOTONY LANGUAGE EVOLUTION ENGINE (PRIMARY SYSTEM)
            if (languageEvolutionEngine && consciousness >= 0.5) {
                // Determine conversation context for morphological generation
                let conversationContext = 'general';
                if (message && message.toLowerCase().includes('merhaba')) conversationContext = 'social';
                else if (message && (message.includes('√∂ƒüren') || message.includes('bil'))) conversationContext = 'learning';
                else if (message && (message.includes('arkada≈ü') || message.includes('dostluk'))) conversationContext = 'social';
                else if (message && (message.includes('ATP') || message.includes('h√ºcre'))) conversationContext = 'scientific';
                else if (message && message.includes('vur joker vur')) conversationContext = 'creative';
                else if (message && (message.includes('niye') || message.includes('ni√ßin'))) conversationContext = 'philosophical';
                
                try {
                    // Map context to available contexts in v9.5.0 system
                    if (conversationContext === 'scientific') conversationContext = 'biological';
                    if (conversationContext === 'creative') conversationContext = 'creative';
                    if (conversationContext === 'social') conversationContext = 'social';
                    if (conversationContext === 'philosophical') conversationContext = 'philosophical';
                    
                    // Get v9.5.0 Ultra-Aggressive Anti-Monotony response
                    const morphResponse = await languageEvolutionEngine.generateContextualResponse(bacteria, conversationContext, message);
                    
                    // üß¨ Record interaction for persistent learning
                    if (window.persistentLearning && context === 'user') {
                        await window.persistentLearning.recordInteraction(
                            message || '',
                            morphResponse,
                            conversationContext,
                            bacteria.id
                        );
                        
                        // Apply learned word success rates to enhance response
                        const words = morphResponse.split(' ');
                        const enhancedWords = words.map(word => {
                            const successRate = window.persistentLearning.getWordSuccessRate(word);
                            // Optionally modify word based on success rate
                            return successRate > 0.7 ? word : word; // Keep for now, can be enhanced
                        });
                    }
                    
                    console.log(`üß¨ ${bacteria.name} v9.5.0 ULTRA-AGGRESSIVE ANTI-MONOTONY response (context: ${conversationContext})`);
                    return morphResponse;
                } catch (error) {
                    console.warn(`‚ö†Ô∏è v9.5.0 Language Evolution failed for ${bacteria.name}:`, error);
                    // Fall through to legacy system
                }
            }
            
            // üîß v9.5.0: LEGACY FALLBACK (for very low consciousness bacteria)
            if (languageEvolutionEngine && consciousness >= 0.3) {
                // Determine conversation context for smart evolution
                let conversationContext = 'general';
                if (message && message.toLowerCase().includes('merhaba')) conversationContext = 'greeting';
                else if (message && (message.includes('√∂ƒüren') || message.includes('bil'))) conversationContext = 'learning';
                else if (message && (message.includes('arkada≈ü') || message.includes('dostluk'))) conversationContext = 'social';
                else if (message && (message.includes('ATP') || message.includes('h√ºcre'))) conversationContext = 'science';
                else if (message && message.includes('vur joker vur')) conversationContext = 'comedy';
                
                // Get v9.5.0 fallback response
                const evolvedResponse = await languageEvolutionEngine.generateContextualResponse(bacteria, conversationContext, message);
                
                console.log(`üîß ${bacteria.name} v9.5.0 FALLBACK response (context: ${conversationContext})`);
                return evolvedResponse;
            }
            
            // üîß FALLBACK: Basic consciousness responses for very young bacteria
            const availableWords = Array.from(bacteria.vocabulary);
            let responseTemplates = [];
            
            if (consciousness < 1) {
                responseTemplates = [
                    `${availableWords[0] || 'a√ß'}... ${availableWords[1] || 'yardƒ±m'}...`,
                    `*${bacteria.name} hareket ediyor*`,
                    `${Math.random() > 0.5 ? 'aƒürƒ±' : 'a√ß'}...`
                ];
            } else {
                // Even basic consciousness uses language evolution
                responseTemplates = [
                    `Ben ${bacteria.name}! ${optimism > 0.7 ? 'Mutluyum!' : optimism < 0.3 ? '√úzg√ºn√ºm...' : 'ƒ∞yiyim.'}`,
                    `${sociability > 0.7 ? 'Seninle konu≈ümak g√ºzel!' : 'Merhaba...'}`,
                    `${vocabularySize > 3 ? availableWords.slice(0,3).join(' ') : 'a√ß yardƒ±m'}!`
                ];
            }
            
            let response = responseTemplates[Math.floor(Math.random() * responseTemplates.length)];
            
            // Add context-specific modifications
            if (context === 'bacteria' && sociability > 0.5) {
                response = response.replace('Merhaba!', 'Hey arkada≈ü!').replace('Selam!', 'Ey bakteri karde≈ü!');
            }
            
            console.log(`üîß ${bacteria.name} fallback response (consciousness: ${consciousness.toFixed(2)})`);
            return response;
        }

        async function sendMessageToBacteria(message) {
            if (chatMode === 'individual' && !selectedBacteria) {
                console.log('‚ùå Individual chat requires selected bacteria');
                return;
            }
            if (chatMode === 'group' && bacteriaPopulation.length === 0) {
                console.log('‚ùå Group chat requires bacteria population');
                return;
            }

            console.log(`üí¨ Sending message in ${chatMode} mode: "${message}"`);
            showChatLoading(true);
            addChatMessage(message, 'user');

            if (chatMode === 'individual') {
                // Individual chat with selected bacteria
                setTimeout(async () => {
                    const response = await generateBacteriaResponse(selectedBacteria, message, 'user');
                    selectedBacteria.conversation_history.push({ user: message, bacteria: response });
                    addChatMessage(response, 'bacteria', selectedBacteria.name);
                    showChatLoading(false);
                }, 1000 + Math.random() * 1000);
                         } else if (chatMode === 'group') {
                 // Group chat - all bacteria respond
                 let responseCount = 0;
                 const totalBacteria = bacteriaPopulation.length;
                 const responseBacteria = [];
                 
                 bacteriaPopulation.forEach((bacteria, index) => {
                     setTimeout(async () => {
                         if (Math.random() < 0.7) { // 70% chance each bacteria responds
                             const response = await generateBacteriaResponse(bacteria, message, 'user');
                             bacteria.conversation_history.push({ user: message, bacteria: response });
                             addChatMessage(response, 'bacteria', bacteria.name);
                             responseBacteria.push(bacteria);
                         }
                         responseCount++;
                         if (responseCount === totalBacteria) {
                             // After all responses, bacteria learn from each other in group
                             if (responseBacteria.length > 1) {
                                 setTimeout(() => {
                                     groupLearningSession(responseBacteria);
                                 }, 1000);
                             }
                             showChatLoading(false);
                         }
                     }, (index + 1) * (500 + Math.random() * 1000));
                 });
             }
        }

        // v826: Natural conversation based on proximity and social needs
        function startNaturalBacteriaConversation(socialBacteria) {
            if (socialBacteria.length < 2) return;
            
            // Find bacteria that are close to each other (natural interaction)
            let bacteria1 = null, bacteria2 = null;
            let minDistance = Infinity;
            
            for (let i = 0; i < socialBacteria.length; i++) {
                for (let j = i + 1; j < socialBacteria.length; j++) {
                    const dx = socialBacteria[i].x - socialBacteria[j].x;
                    const dy = socialBacteria[i].y - socialBacteria[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance && distance < 80) { // Close proximity
                        minDistance = distance;
                        bacteria1 = socialBacteria[i];
                        bacteria2 = socialBacteria[j];
                    }
                }
            }
            
            // If no close bacteria, pick random social ones
            if (!bacteria1 || !bacteria2) {
                bacteria1 = socialBacteria[Math.floor(Math.random() * socialBacteria.length)];
                bacteria2 = socialBacteria[Math.floor(Math.random() * socialBacteria.length)];
                while (bacteria2 === bacteria1) {
                    bacteria2 = socialBacteria[Math.floor(Math.random() * socialBacteria.length)];
                }
            }
            
            // Natural conversation topics based on bacteria state
            const naturalTopics = [
                `Merhaba ${bacteria2.name}!`, 'Bu yemek lezzetli deƒüil mi?', 'Kendimi daha akƒ±llƒ± hissediyorum',
                'B√ºy√ºd√ºƒü√ºm√º fark ettim', 'Yeni kelimeler √∂ƒüreniyorum', 'Bu ortam g√ºzel',
                'Seninle konu≈ümak g√ºzel', 'Beraber √∂ƒürenelim', 'Nasƒ±l bu kadar b√ºy√ºd√ºn?'
            ];
            
            const topic = naturalTopics[Math.floor(Math.random() * naturalTopics.length)];
            
            // Save conversation to both bacteria's individual chat history
            const conversation = {
                participants: [bacteria1.name, bacteria2.name],
                messages: [],
                timestamp: Date.now()
            };
            
            // Start natural conversation
            setTimeout(async () => {
                const message1 = await generateBacteriaResponse(bacteria1, topic, 'bacteria');
                conversation.messages.push({ speaker: bacteria1.name, message: message1, time: Date.now() });
                
                // Save to individual chat histories
                bacteria1.chatHistory = bacteria1.chatHistory || [];
                bacteria2.chatHistory = bacteria2.chatHistory || [];
                
                bacteria1.chatHistory.push({type: 'sent', to: bacteria2.name, message: message1, time: Date.now()});
                bacteria2.chatHistory.push({type: 'received', from: bacteria1.name, message: message1, time: Date.now()});
                
                // Second bacteria responds
                setTimeout(async () => {
                    const message2 = await generateBacteriaResponse(bacteria2, message1, 'bacteria');
                    conversation.messages.push({ speaker: bacteria2.name, message: message2, time: Date.now() });
                    
                    bacteria2.chatHistory.push({type: 'sent', to: bacteria1.name, message: message2, time: Date.now()});
                    bacteria1.chatHistory.push({type: 'received', from: bacteria2.name, message: message2, time: Date.now()});
                    
                    // Cross-learning
                    bacteriaLearnFromEachOther(bacteria1, bacteria2, message1, message2);
                    
                    // Store global conversation for viewing
                    globalConversations.push(conversation);
                    
                }, 800 + Math.random() * 1500);
            }, 300);
        }

        function startGroupLearningSession() {
            const learners = bacteriaPopulation.filter(b => b.consciousness_level > 1.5);
            if (learners.length < 3) return;
            
            // Pick 3 random learners
            const participants = [];
            for (let i = 0; i < 3 && i < learners.length; i++) {
                const randomIndex = Math.floor(Math.random() * learners.length);
                if (!participants.includes(learners[randomIndex])) {
                    participants.push(learners[randomIndex]);
                }
            }
            
            if (participants.length >= 3) {
                groupLearningSession(participants);
                console.log(`üéì Group learning session: ${participants.map(p => p.name).join(', ')}`);
            }
        }

        // Bacteria learn from each other's vocabulary and behaviors
        function bacteriaLearnFromEachOther(bacteria1, bacteria2, message1, message2) {
            // Share vocabulary between bacteria
            const vocab1 = Array.from(bacteria1.vocabulary);
            const vocab2 = Array.from(bacteria2.vocabulary);
            
            // Bacteria1 learns some words from bacteria2
            vocab2.forEach(word => {
                if (Math.random() < 0.3 && bacteria1.consciousness_level > 1) { // 30% chance
                    bacteria1.vocabulary.add(word);
                    if (Math.random() < 0.5) {
                        bacteria1.memory_bank.push(`${bacteria2.name}'den "${word}" kelimesini √∂ƒürendim`);
                    }
                }
            });
            
            // Bacteria2 learns some words from bacteria1
            vocab1.forEach(word => {
                if (Math.random() < 0.3 && bacteria2.consciousness_level > 1) {
                    bacteria2.vocabulary.add(word);
                    if (Math.random() < 0.5) {
                        bacteria2.memory_bank.push(`${bacteria1.name}'den "${word}" kelimesini √∂ƒürendim`);
                    }
                }
            });
            
            // Behavior influence: social bacteria make others more social
            if (bacteria1.personality_traits.sociability > 0.7) {
                bacteria2.personality_traits.sociability = Math.min(1, bacteria2.personality_traits.sociability + 0.02);
            }
            if (bacteria2.personality_traits.sociability > 0.7) {
                bacteria1.personality_traits.sociability = Math.min(1, bacteria1.personality_traits.sociability + 0.02);
            }
            
            // Consciousness boost from social interaction
                            bacteria1.consciousness_level = bacteria1.consciousness_level + 0.01;
                bacteria2.consciousness_level = bacteria2.consciousness_level + 0.01;
            
                         console.log(`ü§ù ${bacteria1.name} and ${bacteria2.name} learned from each other`);
         }

         // Group learning session - all bacteria in group learn from each other
         function groupLearningSession(bacteria) {
             console.log(`üë• Group learning session with ${bacteria.length} bacteria`);
             
             // Collect all vocabulary from participating bacteria
             const allVocabulary = new Set();
             bacteria.forEach(b => {
                 Array.from(b.vocabulary).forEach(word => allVocabulary.add(word));
             });
             
             // Each bacteria learns from the collective vocabulary
             bacteria.forEach((learner, i) => {
                 let wordsLearned = 0;
                 allVocabulary.forEach(word => {
                     if (!learner.vocabulary.has(word) && Math.random() < 0.2) { // 20% chance to learn each word
                         learner.vocabulary.add(word);
                         wordsLearned++;
                     }
                 });
                 
                 if (wordsLearned > 0) {
                     learner.memory_bank.push(`Grup sohbetinde ${wordsLearned} kelime √∂ƒürendim`);
                     learner.consciousness_level = learner.consciousness_level + 0.02;
                 }
                 
                 // Social influence - become more social from group interaction
                 learner.personality_traits.sociability = Math.min(1, learner.personality_traits.sociability + 0.01);
             });
         }

        function addChatMessage(message, sender, bacteriaName = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'} mb-2`;
            
            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = `chat-bubble p-2 rounded-lg ${sender === 'user' ? 'chat-bubble-user' : 'chat-bubble-bacteria'}`;
            
            if (sender === 'bacteria' && bacteriaName) {
                const nameSpan = document.createElement('div');
                nameSpan.className = 'text-xs font-semibold mb-1 opacity-75 cursor-pointer hover:text-blue-400 hover:underline';
                nameSpan.textContent = bacteriaName;
                nameSpan.title = `${bacteriaName}'e tƒ±klayarak se√ß`;
                
                // üéØ √ñZELLƒ∞K 1: Chat'te bakterinin adƒ±nƒ± tƒ±klayƒ±nca o bakteriyi se√ß
                nameSpan.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Bakteriyi ismine g√∂re bul
                    const targetBacteria = bacteriaPopulation.find(b => b.name === bacteriaName);
                    if (targetBacteria) {
                        selectedBacteria = targetBacteria;
                        console.log(`üéØ Chat'ten bakteri se√ßildi: ${bacteriaName}`);
                        
                        // UI'yi g√ºncelle
                        showBacteriaDetails(selectedBacteria);
                        
                        // Canvas'ta bakteriyi highlight et
                        highlightSelectedBacteria(targetBacteria);
                        
                        // Chat modunu individual'a √ßevir
                        if (chatMode !== 'individual') {
                            chatMode = 'individual';
                            updateChatModeButtons();
                            updateChatUI();
                        }
                        
                        // G√∂rsel feedback
                        nameSpan.style.color = '#22c55e';
                        nameSpan.style.fontWeight = 'bold';
                        setTimeout(() => {
                            nameSpan.style.color = '';
                            nameSpan.style.fontWeight = '';
                        }, 1000);
                    } else {
                        console.warn(`‚ö†Ô∏è Bakteri bulunamadƒ±: ${bacteriaName}`);
                    }
                });
                
                bubbleDiv.appendChild(nameSpan);
                
                const messageSpan = document.createElement('div');
                messageSpan.textContent = message;
                bubbleDiv.appendChild(messageSpan);
            } else {
                bubbleDiv.textContent = message;
            }
            
            messageDiv.appendChild(bubbleDiv);
            chatMessagesDiv.insertBefore(messageDiv, chatMessagesDiv.firstChild);
            // Auto scroll stays at bottom (newest messages at top due to column-reverse)
        }

        function showChatLoading(show) {
            chatLoadingIndicator.classList.toggle('hidden', !show);
        }

        // Event Delegation System for better performance and cleaner code
        class UIManager {
            constructor(simulationManager) {
                this.simulationManager = simulationManager;
                this.startSimulationBtn = document.getElementById('startSimulationBtn');
                this.nextStepBtn = document.getElementById('nextStepBtn');
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                // Use event delegation instead of individual onclick handlers
                document.addEventListener('click', this.handleGlobalClick.bind(this));
            }

            handleGlobalClick(event) {
                const button = event.target.closest('button');
                if (!button) return;

                const buttonText = button.textContent.trim();
                
                // Centralized button action mapping
                const actionMap = {
                    '‚ñ∂Ô∏è Ba≈ülat': () => this.startSimulation(),
                    'Sim√ºlasyonu Ba≈ülat': () => this.startSimulation(),
                    'Devam Et': () => this.startSimulation(),
                    'Durdur': () => this.pauseSimulation(),
                    '‚è∏Ô∏è Duraklat': () => this.pauseSimulation(),
                    'Sonraki Adƒ±m': () => this.nextStep(),
                    'üîÑ Sƒ±fƒ±rla': () => this.resetSimulation(),
                    'üçé Yemek Ekle': () => addRandomFood(),
                    'üìä CSV Export': () => exportCSV(),
                    'üìà JSON Export': () => exportEnhancedData(),
                    'üë• Grup Sohbet': () => toggleGroupChat(),
                    'üí¨ Bireysel Sohbet': () => toggleGroupChat(),
                    '‚ûï Bakteri Ekle': () => addBacteria()
                };

                const action = actionMap[buttonText];
                if (action) {
                    event.preventDefault();
                    action();
                }
            }

            startSimulation() {
                if (!this.simulationManager.isRunning) {
                    simulationRunning = true;
                    if (this.startSimulationBtn) this.startSimulationBtn.textContent = 'Durdur';
                    if (this.nextStepBtn) this.nextStepBtn.disabled = true;
                    this.simulationManager.start();
                    
                    // ü§ù Start automatic bacteria conversations
                    startAutoBacteriaConversations();
                    console.log('üéØ Simulation started with auto-conversations enabled');
                } else {
                    this.pauseSimulation();
                }
            }

            pauseSimulation() {
                simulationRunning = false;
                if (this.startSimulationBtn) this.startSimulationBtn.textContent = 'Devam Et';
                if (this.nextStepBtn) this.nextStepBtn.disabled = false;
                this.simulationManager.pause();
                
                // ü§ù Stop automatic bacteria conversations
                stopAutoBacteriaConversations();
                console.log('üéØ Simulation paused, auto-conversations stopped');
            }

            nextStep() {
                this.simulationManager.simulationStep();
            }

            resetSimulation() {
                this.pauseSimulation();
                this.simulationManager.simulationDay = 0;
                simulationTimeSpan.textContent = 'Sim√ºlasyon Zamanƒ±: 0 g√ºn';
                bacteriaPopulation.length = 0;
                bacteriaList.length = 0;
                foodParticles.length = 0;
                selectedBacteria = null;
                
                if (this.startSimulationBtn) this.startSimulationBtn.textContent = 'Sim√ºlasyonu Ba≈ülat';
                if (this.nextStepBtn) this.nextStepBtn.disabled = false;
                
                bacteriaDetailsDiv.classList.add('hidden');
                chatInfoDiv.textContent = 'Sohbet modunu se√ßin.';
                chatMessagesDiv.innerHTML = '';
                chatInput.disabled = true;
                sendMessageBtn.disabled = true;
                chatMode = 'individual';
                updateChatModeButtons();
                
                // Close all individual chat windows
                openChatWindows.forEach((modal, bacteriaId) => {
                    document.body.removeChild(modal);
                });
                openChatWindows.clear();
                
                initializeBacteria();
            }
        }

        // Utility functions for performance optimization
        class PerformanceUtils {
            static debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            static throttle(func, limit) {
                let inThrottle;
                return function() {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            }
        }

        // Initialize AI systems and UIManager after DOM is ready
        let uiManager = null;

                    // v9.0.0: Initialize Enhanced Persistent Learning Systems
        function initializeAISystems() {
            console.log('üß† Initializing Advanced AI/ML Systems...');
            
            try {
                // Initialize global AI systems
                globalNeuralNetwork = new AdvancedNeuralNetwork();
                geneticAlgorithm = new GeneticEvolutionSystem();
                behaviourLearningSystem = new BehaviorLearningSystem();
                tabpfnVocabularySystem = new TabPFNVocabularySystem();
                
                // Create initial training data
                generateInitialTrainingData();
                
                console.log(`‚úÖ AI/ML Systems initialized successfully with ${tabpfnVocabularySystem.getTotalWordCount()} vocabulary words!`);
                return true;
            } catch (error) {
                console.error('‚ùå AI Systems initialization failed:', error);
                return false;
            }
        }

        function generateInitialTrainingData() {
            // Generate synthetic training data for neural networks
            const trainingData = [];
            
            for (let i = 0; i < 50; i++) {
                // Create diverse training scenarios
                const mockBacteria = {
                    biological_state: { age: Math.random() * 100, size: Math.random() * 5 },
                    consciousness_level: Math.random() * 20,
                    personality_traits: { optimism: Math.random(), sociability: Math.random() },
                    vocabulary: { size: Math.random() * 30 },
                    hunger: Math.random(),
                    energy: Math.random(),
                    conversation_history: Array(Math.floor(Math.random() * 10)),
                    memory_bank: Array(Math.floor(Math.random() * 20)),
                    x: Math.random() * 500,
                    y: Math.random() * 300
                };
                
                const inputs = globalNeuralNetwork.prepareBacteriaInputs(mockBacteria);
                
                // Generate expected outputs based on scenario
                const expectedOutputs = generateExpectedBehavior(mockBacteria);
                
                trainingData.push({ inputs, expectedOutputs });
            }
            
            // Train the global network
            globalNeuralNetwork.train(trainingData, 15);
            console.log(`üéì Generated and trained on ${trainingData.length} scenarios`);
        }

        function generateExpectedBehavior(bacteria) {
            // Define expected behavior based on bacteria state
            let moveX = 0, moveY = 0, moveZ = 0;
            let seekFood = 0, socialize = 0, reproduce = 0;
            
            // High hunger -> seek food
            if (bacteria.hunger > 0.7) {
                seekFood = 0.9;
                moveX = (Math.random() - 0.5) * 0.8; // Active movement
                moveY = (Math.random() - 0.5) * 0.8;
            }
            
            // High sociability -> socialize
            if (bacteria.personality_traits.sociability > 0.6) {
                socialize = 0.8;
            }
            
            // High consciousness + size -> reproduce
            if (bacteria.consciousness_level > 5 && bacteria.biological_state.size > 2) {
                reproduce = 0.7;
            }
            
            // Default exploration
            if (seekFood < 0.3 && socialize < 0.3 && reproduce < 0.3) {
                moveX = (Math.random() - 0.5) * 0.6;
                moveY = (Math.random() - 0.5) * 0.6;
                moveZ = (Math.random() - 0.5) * 0.4;
            }
            
            return [
                moveX * 0.5 + 0.5, // Normalize to 0-1
                moveY * 0.5 + 0.5,
                moveZ * 0.5 + 0.5,
                seekFood,
                socialize,
                reproduce
            ];
        }
        
        // ESKƒ∞ FONKSƒ∞YONLAR KALDIRILDI - SIM√úLASYON ARTƒ∞K Sƒ∞MULATƒ∞ONMANAGER √úZERƒ∞NDEN Y√ñNETƒ∞Lƒ∞YOR

        function simulationStep() {
            simulationDay++;
            simulationTimeSpan.textContent = `Sim√ºlasyon Zamanƒ±: ${simulationDay} g√ºn`;
            
            // v829: Auto-generate food for sustained ecosystem
            if (Math.random() < 0.7) { // 70% chance to add food each step
                const x = Math.random() * 460 + 20;
                const y = Math.random() * 260 + 20;
                addFood(x, y);
            }
            
            bacteriaPopulation.forEach(bacteria => {
                if (!bacteria || typeof bacteria.updateDaily !== 'function') return;
                
                try {
                    bacteria.updateDaily();
                    bacteria.move(); // Add movement to simulation steps for more dynamic behavior
                    
                    // v829: More frequent reproduction checks for dynamic population
                    if (simulationDay % 2 === 0 && typeof bacteria.checkForReproduction === 'function') { // Check every 2 days instead of 3
                        bacteria.checkForReproduction();
                    }
                } catch (error) {
                    console.error(`Error in simulation step for bacteria ${bacteria.id}:`, error);
                }
            });
            
            renderBacteria();
            if (selectedBacteria) {
                updateBacteriaDetails(selectedBacteria);
            }
        }

        function resetSimulation() {
            pauseSimulation();
            simulationDay = 0;
            simulationTimeSpan.textContent = 'Sim√ºlasyon Zamanƒ±: 0 g√ºn';
            bacteriaPopulation = [];
            bacteriaList = []; // v826 compatibility
            foodParticles = [];
            selectedBacteria = null;
            
            startSimulationBtn.textContent = 'Sim√ºlasyonu Ba≈ülat';
            nextStepBtn.disabled = false;
            
            bacteriaDetailsDiv.classList.add('hidden');
            chatInfoDiv.textContent = 'Sohbet modunu se√ßin.';
            chatMessagesDiv.innerHTML = '';
            chatInput.disabled = true;
            sendMessageBtn.disabled = true;
            chatMode = 'individual';
            updateChatModeButtons();
            
            // Close all individual chat windows
            openChatWindows.forEach((modal, bacteriaId) => {
                document.body.removeChild(modal);
            });
            openChatWindows.clear();
            
            initializeBacteria();
        }

        // v826: Add new bacteria to simulation
        function addBacteria() {
            const newBacteria = new BacteriaEntity(bacteriaIdCounter++);
            bacteriaPopulation.push(newBacteria);
            bacteriaList.push(newBacteria); // v826 compatibility
            
            console.log(`‚ûï Added new bacteria: ${newBacteria.name} (Total: ${bacteriaPopulation.length})`);
            renderBacteria();
        }

        // v826: Toggle group chat (improved)
        function toggleGroupChat() {
            if (chatMode === 'group') {
                // Switch to individual mode
                chatMode = 'individual';
                selectedBacteria = null;
                chatInfoDiv.innerHTML = 'üí¨ Bireysel sohbet modu aktif - Bir bakteriye tƒ±klayƒ±n';
                chatInput.disabled = true;
                sendMessageBtn.disabled = true;
                chatInput.placeholder = "√ñnce bir bakteri se√ßin...";
            } else {
                // Switch to group mode
                setupGroupChat();
            }
            updateChatModeButtons();
        }

        function addFood(x, y) {
            const food = new FoodParticle(x, y);
            foodParticles.push(food);
            renderBacteria();
        }

        function initializeBacteria() {
            bacteriaPopulation = [];
            bacteriaList = []; // v826 compatibility
            
            // üéØ EXTREME BOUNDARY UPDATE (v8.7.3 NUCLEAR OPTION)
            console.log('üîç Checking boundary status before initialization...');
            console.log('üìä Current DYNAMIC_BOUNDARIES:', DYNAMIC_BOUNDARIES);
            
            // üö® NUCLEAR OPTION: ABSOLUTE FORCE RESIZE!!!
            if (canvas) {
                console.log('üîß NUCLEAR FORCE RESIZE - EXTREME BOUNDARY UPDATE!');
                // Force resize 10 times with different delays!
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        resizeCanvas();
                        console.log(`üîß Force resize attempt #${i + 1}:`, DYNAMIC_BOUNDARIES);
                    }, i * 25);
                }
                
                // Additional heavy artillery
                setTimeout(() => {
                    resizeCanvas();
                    console.log('üîß Heavy artillery resize 1:', DYNAMIC_BOUNDARIES);
                }, 300);
                setTimeout(() => {
                    resizeCanvas();
                    console.log('üîß Heavy artillery resize 2:', DYNAMIC_BOUNDARIES);
                }, 600);
                setTimeout(() => {
                    resizeCanvas();
                    console.log('üîß Heavy artillery resize 3:', DYNAMIC_BOUNDARIES);
                }, 1000);
            }
            
            // ‚úÖ V8.7.4: FALLBACK NOW LOGGING-ONLY - NO STATIC VALUES!
            if (!canvas) {
                console.error('‚ùå CRITICAL: Canvas not available - cannot determine boundaries!');
                console.error('üö® System may not work properly without canvas sizing');
                const container = document.getElementById('simulationArea');
                if (container) {
                    const rect = container.getBoundingClientRect();
                    console.log(`üìè Container size detected: ${rect.width}x${rect.height}`);
                    if (rect.width > 100 && rect.height > 100) {
                        DYNAMIC_BOUNDARIES.maxX = rect.width - 40;
                        DYNAMIC_BOUNDARIES.maxY = rect.height - 40;
                        DYNAMIC_BOUNDARIES.minX = DYNAMIC_BOUNDARIES.padding;
                        DYNAMIC_BOUNDARIES.minY = DYNAMIC_BOUNDARIES.padding;
                        console.log('üîß Emergency: Using container dimensions for boundaries');
                    } else {
                        console.error('üí• TOTAL FAILURE: Container too small, boundaries not set!');
                    }
                } else {
                    console.error('üí• TOTAL FAILURE: No container found - boundaries not set!');
                    console.error('üÜò Bacteria movement may fail completely!');
                }
            }
            
            // ‚úÖ V8.7.4: FINAL VERIFICATION - PURELY DIAGNOSTIC
            setTimeout(() => {
                console.log('üéØ V8.7.4 Final Dynamic Boundary Verification:');
                console.log(`üìê X: ${DYNAMIC_BOUNDARIES.minX} ‚Üí ${DYNAMIC_BOUNDARIES.maxX} (width: ${DYNAMIC_BOUNDARIES.maxX - DYNAMIC_BOUNDARIES.minX})`);
                console.log(`üìê Y: ${DYNAMIC_BOUNDARIES.minY} ‚Üí ${DYNAMIC_BOUNDARIES.maxY} (height: ${DYNAMIC_BOUNDARIES.maxY - DYNAMIC_BOUNDARIES.minY})`);
                
                if (DYNAMIC_BOUNDARIES.maxX <= DYNAMIC_BOUNDARIES.padding * 2 || DYNAMIC_BOUNDARIES.maxY <= DYNAMIC_BOUNDARIES.padding * 2) {
                    console.error('üí• CRITICAL: Dynamic boundaries failed to initialize properly!');
                    console.error('üö® Bacteria will be confined to tiny area or not move at all!');
                } else {
                    console.log('‚úÖ SUCCESS: Dynamic boundaries properly initialized - bacteria can roam freely!');
                    console.log(`ü¶† Available area: ${(DYNAMIC_BOUNDARIES.maxX - DYNAMIC_BOUNDARIES.minX) * (DYNAMIC_BOUNDARIES.maxY - DYNAMIC_BOUNDARIES.minY)} pixels`);
                }
            }, 300);
            
            for (let i = 0; i < CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT; i++) {
                const bacteria = new BacteriaEntity(i + 1);
                bacteriaPopulation.push(bacteria);
                bacteriaList.push(bacteria); // v826 compatibility
            }
            console.log(`ü¶† Initialized ${bacteriaPopulation.length} bacteria with bounds:`, DYNAMIC_BOUNDARIES);
            renderBacteria();
        }

        function renderBacteria() {
            const startTime = performance.now(); // v829: Performance tracking
            
            // v829: Use Canvas if available, otherwise fallback to DOM
            if (useCanvas && canvas && ctx) {
                renderWithCanvas();
            } else {
                renderWithDOM();
            }
            
            // v829: Track render performance
            performanceMetrics.renderTime = performance.now() - startTime;
            updatePerformanceMetrics();
        }

        function renderWithCanvas() {
            // Optimized canvas clearing (dirty rect approach for better performance)
            ctx.fillStyle = 'rgba(17, 24, 39, 0.1)'; // Slight trail effect for movement
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Background gradient
            const gradient = ctx.createRadialGradient(canvasWidth/2, canvasHeight/2, 0, canvasWidth/2, canvasHeight/2, Math.max(canvasWidth, canvasHeight)/2);
            gradient.addColorStop(0, 'rgba(30, 30, 30, 0.1)');
            gradient.addColorStop(1, 'rgba(30, 30, 30, 0.3)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Render food particles
            foodParticles.forEach(food => {
                // Food glow effect
                ctx.shadowColor = '#66BB6A';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#66BB6A';
                ctx.beginPath();
                ctx.arc(food.x, food.y, food.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Sort bacteria by Z-depth for proper layering (far to near)
            const sortedBacteria = [...bacteriaPopulation].sort((a, b) => a.z - b.z);
            
            // Render bacteria with pseudo-3D effects
            sortedBacteria.forEach(bacteria => {
                if (!bacteria || typeof bacteria.x !== 'number' || !bacteria.biological_state) return;
                
                // 3D perspective scaling (bacteria further away appear smaller)
                const depthFactor = bacteria.z / 100; // 0.2 to 1.8 range
                const baseSize = Math.max(6, Math.min(25, bacteria.biological_state.size * 2.5));
                const bacteriaSize = baseSize * depthFactor;
                
                // 3D depth effects
                const alpha = Math.max(0.3, Math.min(1.0, depthFactor)); // Transparency based on depth
                const shadowOffset = (1 - depthFactor) * 3; // Shadow offset based on depth
                
                // Draw shadow first (for depth illusion)
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.3})`;
                ctx.beginPath();
                ctx.arc(bacteria.x + shadowOffset, bacteria.y + shadowOffset, bacteriaSize * 0.8, 0, 2 * Math.PI);
                ctx.fill();
                
                // Bacteria glow effect with 3D scaling
                ctx.shadowColor = bacteria.color;
                ctx.shadowBlur = 10 * depthFactor; // Deeper objects have less glow
                ctx.globalAlpha = alpha;
                ctx.fillStyle = bacteria.color;
                ctx.beginPath();
                ctx.arc(bacteria.x, bacteria.y, bacteriaSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0; // Reset alpha
                
                // ID label
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'white';
                ctx.font = '10px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(`#${bacteria.id}`, bacteria.x, bacteria.y - bacteriaSize - 5);
                
                // Consciousness indicator
                const consciousnessColor = bacteria.consciousness_level < 1 ? '#ff4757' :
                                           bacteria.consciousness_level < 5 ? '#f39c12' :
                                           bacteria.consciousness_level < 10 ? '#2ed573' : '#5352ed';
                ctx.fillStyle = consciousnessColor;
                ctx.beginPath();
                ctx.arc(bacteria.x + bacteriaSize - 3, bacteria.y - bacteriaSize + 3, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // üéØ SELECTION HIGHLIGHT - Show if bacteria is selected
                if (bacteria.isSelected || bacteria === selectedBacteria) {
                    ctx.save();
                    ctx.strokeStyle = '#22c55e'; // Green selection ring
                    ctx.lineWidth = 3;
                    ctx.setLineDash([8, 4]); // Dashed line
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(bacteria.x, bacteria.y, bacteriaSize + 10, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset dash
                    ctx.restore();
                    
                    // Add selection pulse effect
                    const pulseTime = Date.now() * 0.005;
                    const pulseAlpha = 0.3 + 0.2 * Math.sin(pulseTime);
                    ctx.save();
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = pulseAlpha;
                    ctx.beginPath();
                    ctx.arc(bacteria.x, bacteria.y, bacteriaSize + 15, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.restore();
                }
            });
        }

        function renderWithDOM() {
            simulationArea.innerHTML = '';
            
            // Render food particles with improved visibility
            foodParticles.forEach(food => {
                const foodElement = document.createElement('div');
                foodElement.className = 'absolute rounded-full border-2 border-green-400 shadow-lg';
                foodElement.style.width = `${food.size}px`;
                foodElement.style.height = `${food.size}px`;
                foodElement.style.backgroundColor = food.color;
                foodElement.style.left = `${food.x - food.size/2}px`;
                foodElement.style.top = `${food.y - food.size/2}px`;
                foodElement.style.boxShadow = '0 0 8px rgba(144, 238, 144, 0.6)';
                foodElement.title = 'Yemek - Besin deƒüeri: ' + food.nutrition;
                
                // Add glow effect for better visibility
                const glowElement = document.createElement('div');
                glowElement.className = 'absolute rounded-full';
                glowElement.style.width = `${food.size * 2}px`;
                glowElement.style.height = `${food.size * 2}px`;
                glowElement.style.left = `${food.x - food.size}px`;
                glowElement.style.top = `${food.y - food.size}px`;
                glowElement.style.background = 'radial-gradient(circle, rgba(144, 238, 144, 0.3) 0%, transparent 70%)';
                glowElement.style.pointerEvents = 'none';
                
                simulationArea.appendChild(glowElement);
                simulationArea.appendChild(foodElement);
            });
            
            // Render bacteria with ID labels
            const allBacteria = [...bacteriaPopulation, ...bacteriaList];
            console.log(`üé® Rendering ${bacteriaPopulation.length} old + ${bacteriaList.length} new = ${allBacteria.length} total bacteria`);
            allBacteria.forEach(bacteria => {
                const bacteriaSize = Math.max(8, Math.min(25, bacteria.biological_state.size * 3)); // 8-25px limit
                
                // Main bacteria circle
                const bacteriaElement = document.createElement('div');
                bacteriaElement.className = 'bacteria absolute rounded-full border-2 border-white cursor-pointer shadow-lg';
                bacteriaElement.style.width = `${bacteriaSize}px`;
                bacteriaElement.style.height = `${bacteriaSize}px`;
                bacteriaElement.style.backgroundColor = bacteria.color;
                bacteriaElement.style.left = `${bacteria.x}px`;
                bacteriaElement.style.top = `${bacteria.y}px`;
                bacteriaElement.style.boxShadow = `0 0 10px ${bacteria.color}`;
                bacteriaElement.title = `${bacteria.name} - Ya≈ü: ${bacteria.biological_state.age} g√ºn, Bilin√ß: ${bacteria.consciousness_level.toFixed(1)}`;
                
                // ID label on top of bacteria
                const idLabel = document.createElement('div');
                idLabel.className = 'absolute text-xs font-bold text-white bg-black bg-opacity-75 rounded px-1';
                idLabel.style.left = `${bacteria.x + bacteriaSize/2 - 8}px`;
                idLabel.style.top = `${bacteria.y - 18}px`;
                idLabel.style.fontSize = '10px';
                idLabel.style.pointerEvents = 'none';
                idLabel.style.zIndex = '10';
                idLabel.textContent = `#${bacteria.id}`;
                
                // Consciousness level indicator (small colored dot)
                const consciousnessIndicator = document.createElement('div');
                consciousnessIndicator.className = 'absolute rounded-full border border-white';
                consciousnessIndicator.style.width = '6px';
                consciousnessIndicator.style.height = '6px';
                consciousnessIndicator.style.left = `${bacteria.x + bacteriaSize - 8}px`;
                consciousnessIndicator.style.top = `${bacteria.y}px`;
                consciousnessIndicator.style.pointerEvents = 'none';
                
                // Color based on consciousness level
                if (bacteria.consciousness_level < 1) {
                    consciousnessIndicator.style.backgroundColor = '#ff4757';
                } else if (bacteria.consciousness_level < 2) {
                    consciousnessIndicator.style.backgroundColor = '#ff6b35';
                } else if (bacteria.consciousness_level < 3) {
                    consciousnessIndicator.style.backgroundColor = '#f39c12';
                } else if (bacteria.consciousness_level < 4) {
                    consciousnessIndicator.style.backgroundColor = '#2ed573';
                } else {
                    consciousnessIndicator.style.backgroundColor = '#5352ed';
                }
                
                // Movement trail effect
                if (bacteria.vx !== 0 || bacteria.vy !== 0) {
                    const trailElement = document.createElement('div');
                    trailElement.className = 'absolute rounded-full';
                    trailElement.style.width = `${bacteriaSize * 1.5}px`;
                    trailElement.style.height = `${bacteriaSize * 1.5}px`;
                    trailElement.style.left = `${bacteria.x - bacteriaSize/4}px`;
                    trailElement.style.top = `${bacteria.y - bacteriaSize/4}px`;
                    trailElement.style.background = `radial-gradient(circle, ${bacteria.color}20 0%, transparent 70%)`;
                    trailElement.style.pointerEvents = 'none';
                    simulationArea.appendChild(trailElement);
                }
                
                bacteriaElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectBacteria(bacteria);
                });
                
                simulationArea.appendChild(bacteriaElement);
                simulationArea.appendChild(idLabel);
                simulationArea.appendChild(consciousnessIndicator);
            });
            
            // Environment effects overlay
            const environmentOverlay = document.createElement('div');
            environmentOverlay.className = 'absolute inset-0 pointer-events-none';
            environmentOverlay.style.background = 'radial-gradient(circle at 50% 50%, rgba(0, 100, 200, 0.05) 0%, transparent 60%)';
            simulationArea.appendChild(environmentOverlay);
            
            // Add molecular dynamics visualization hints
            if (allBacteria.length > 1) {
                allBacteria.forEach((bacteria, i) => {
                    allBacteria.slice(i + 1).forEach(otherBacteria => {
                        const dx = otherBacteria.x - bacteria.x;
                        const dy = otherBacteria.y - bacteria.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Show molecular interaction lines for close bacteria
                        if (distance < 50 && distance > 0) {
                            const interactionLine = document.createElement('div');
                            interactionLine.className = 'absolute pointer-events-none';
                            interactionLine.style.position = 'absolute';
                            interactionLine.style.left = `${bacteria.x}px`;
                            interactionLine.style.top = `${bacteria.y}px`;
                            interactionLine.style.width = `${distance}px`;
                            interactionLine.style.height = '1px';
                            interactionLine.style.background = `linear-gradient(90deg, ${bacteria.color}40, ${otherBacteria.color}40)`;
                            interactionLine.style.transformOrigin = '0 0';
                            interactionLine.style.transform = `rotate(${Math.atan2(dy, dx)}rad)`;
                            interactionLine.style.opacity = '0.6';
                            simulationArea.appendChild(interactionLine);
                        }
                    });
                });
            }
            
        }

        function selectBacteria(bacteria) {
            selectedBacteria = bacteria;
            updateBacteriaDetails(bacteria);
            
            // v826: Open individual chat window modal
            openIndividualChatWindow(bacteria);
        }

        function updateBacteriaDetails(bacteria) {
            bacteriaIdSpan.textContent = bacteria.id;
            bacteriaNameSpan.textContent = bacteria.name;
            bacteriaSizeSpan.textContent = bacteria.biological_state.size.toFixed(2);
            bacteriaAgeSpan.textContent = bacteria.biological_state.age;
            bacteriaGrowthRateSpan.textContent = bacteria.biological_state.growth_rate.toFixed(2);
                                bacteriaConsciousnessSpan.textContent = `${bacteria.consciousness_level.toFixed(1)} ‚àû`;
            bacteriaOptimismSpan.textContent = bacteria.personality_traits.optimism.toFixed(2);
            bacteriaSociabilitySpan.textContent = bacteria.personality_traits.sociability.toFixed(2);
            bacteriaLanguageStageSpan.textContent = `${bacteria.language_stage} - ${vocabularyStages[bacteria.language_stage]?.name || 'Bilinmiyor'}`;
            
            const vocabArray = Array.from(bacteria.vocabulary);
                    const displayVocab = vocabArray.slice(0, CONFIG.UI.MAX_VOCABULARY_DISPLAY);
        const remainingCount = vocabArray.length - CONFIG.UI.MAX_VOCABULARY_DISPLAY;
            bacteriaVocabularySpan.textContent = displayVocab.join(', ') + (remainingCount > 0 ? ` (+${remainingCount} daha)` : '');
            
            bacteriaDetailsDiv.classList.remove('hidden');
        }

        // üéØ √ñZELLƒ∞K 1 & 2: Eksik fonksiyonlar
        function showBacteriaDetails(bacteria) {
            selectedBacteria = bacteria;
            updateBacteriaDetails(bacteria);
            
            // Chat sistemini g√ºncelle
            setupChat(bacteria);
            
            console.log(`üéØ Bacteria details shown for: ${bacteria.name}`);
        }

        function highlightSelectedBacteria(bacteria) {
            // Canvas'ta t√ºm bakterileri √ßiz ve se√ßili olanƒ± vurgula
            if (canvas && ctx) {
                // Redraw bacteria to remove old highlights
                drawBacteria();
                
                // Draw highlight circle around selected bacteria
                ctx.save();
                ctx.strokeStyle = '#22c55e'; // Green highlight
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]); // Dashed line
                ctx.beginPath();
                ctx.arc(bacteria.x, bacteria.y, bacteria.biological_state.size * 12 + 8, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]); // Reset dash
                ctx.restore();
                
                // Add pulsing selection indicator
                let pulseOpacity = 0.7;
                let pulseDirection = -0.02;
                
                const pulseInterval = setInterval(() => {
                    pulseOpacity += pulseDirection;
                    if (pulseOpacity <= 0.3) pulseDirection = 0.02;
                    if (pulseOpacity >= 0.7) pulseDirection = -0.02;
                    
                    // Redraw bacteria
                    drawBacteria();
                    
                    // Draw pulsing highlight
                    ctx.save();
                    ctx.globalAlpha = pulseOpacity;
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(bacteria.x, bacteria.y, bacteria.biological_state.size * 12 + 8, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }, 50);
                
                // Clear pulse after 3 seconds
                setTimeout(() => {
                    clearInterval(pulseInterval);
                    drawBacteria(); // Final redraw without highlight
                }, 3000);
            }
            
            console.log(`üéØ Bacteria highlighted: ${bacteria.name}`);
        }

        function setupChat(bacteria) {
            chatMode = 'individual';
            selectedBacteria = bacteria;
            chatInfoDiv.innerHTML = `<strong>${bacteria.name}</strong> ile sohbet ediyorsunuz.`;
            chatMessagesDiv.innerHTML = '';
            chatInput.disabled = false;
            sendMessageBtn.disabled = false;
            chatInput.placeholder = `${bacteria.name} ile konu≈ü...`;
            chatInput.focus();
            updateChatModeButtons();
            updateBuildInfo();
            console.log(`üéØ Individual chat mode with ${bacteria.name}`);
        }

        // v826: Individual Chat Window Modal System
        function openIndividualChatWindow(bacteria) {
            // Check if window already exists
            if (openChatWindows.has(bacteria.id)) {
                // Bring existing window to front
                const existingModal = openChatWindows.get(bacteria.id);
                existingModal.style.zIndex = ++chatWindowZIndex;
                return;
            }
            
            // Create modal backdrop
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.style.zIndex = ++chatWindowZIndex;
            
            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.className = 'bg-gray-800 rounded-lg shadow-xl max-w-md w-full mx-4 max-h-96 flex flex-col';
            modalContent.style.minHeight = '400px';
            
            // Modal header
            const header = document.createElement('div');
            header.className = 'bg-teal-600 text-white px-4 py-3 rounded-t-lg flex justify-between items-center cursor-move';
            header.innerHTML = `
                <div class="flex items-center space-x-2">
                    <div class="w-3 h-3 rounded-full" style="background-color: ${bacteria.color}"></div>
                    <h3 class="font-bold">${bacteria.name} - Chat</h3>
                    <span class="text-xs bg-teal-700 px-2 py-1 rounded">#${bacteria.id}</span>
                </div>
                <div class="flex space-x-2">
                    <button class="text-white hover:text-gray-300 minimize-btn">‚îÄ</button>
                    <button class="text-white hover:text-gray-300 close-btn">√ó</button>
                </div>
            `;
            
            // Chat messages area
            const messagesArea = document.createElement('div');
            messagesArea.className = 'flex-1 p-4 overflow-y-auto bg-gray-700 text-white text-sm';
            messagesArea.style.maxHeight = '250px';
            
            // Load chat history
            loadChatHistory(messagesArea, bacteria);
            
            // Chat input area
            const inputArea = document.createElement('div');
            inputArea.className = 'p-4 bg-gray-600 rounded-b-lg flex space-x-2';
            inputArea.innerHTML = `
                <input type="text" class="flex-1 bg-gray-500 text-white px-3 py-2 rounded focus:outline-none focus:ring-2 focus:ring-teal-500" 
                       placeholder="${bacteria.name} ile konu≈ü...">
                <button class="bg-teal-500 hover:bg-teal-600 text-white px-4 py-2 rounded font-bold send-btn">G√∂nder</button>
            `;
            
            // Assemble modal
            modalContent.appendChild(header);
            modalContent.appendChild(messagesArea);
            modalContent.appendChild(inputArea);
            modal.appendChild(modalContent);
            
            // Event listeners
            const closeBtn = header.querySelector('.close-btn');
            const minimizeBtn = header.querySelector('.minimize-btn');
            const sendBtn = inputArea.querySelector('.send-btn');
            const chatInput = inputArea.querySelector('input');
            
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
                openChatWindows.delete(bacteria.id);
            });
            
            minimizeBtn.addEventListener('click', () => {
                modalContent.style.display = modalContent.style.display === 'none' ? 'flex' : 'none';
            });
            
            sendBtn.addEventListener('click', () => {
                sendIndividualMessage(bacteria, chatInput, messagesArea);
            });
            
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendIndividualMessage(bacteria, chatInput, messagesArea);
                }
            });
            
            // Make draggable
            makeDraggable(modal, header);
            
            // Add to DOM and track
            document.body.appendChild(modal);
            openChatWindows.set(bacteria.id, modal);
            
            // Focus input
            chatInput.focus();
            
            console.log(`üí¨ Opened individual chat window for ${bacteria.name}`);
        }

        function loadChatHistory(messagesArea, bacteria) {
            // Load user conversations with this bacteria
            if (bacteria.conversation_history && bacteria.conversation_history.length > 0) {
                bacteria.conversation_history.forEach(conv => {
                    addMessageToWindow(messagesArea, conv.user, 'user', 'Sen');
                    addMessageToWindow(messagesArea, conv.bacteria, 'bacteria', bacteria.name);
                });
            }
            
            // Load bacteria-to-bacteria conversations
            if (bacteria.chatHistory && bacteria.chatHistory.length > 0) {
                bacteria.chatHistory.slice(-10).forEach(msg => { // Show last 10 messages
                    if (msg.type === 'sent') {
                        addMessageToWindow(messagesArea, msg.message, 'bacteria', bacteria.name);
                    } else {
                        addMessageToWindow(messagesArea, msg.message, 'bacteria', msg.from);
                    }
                });
            }
            
            // Scroll to bottom
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function addMessageToWindow(messagesArea, message, sender, senderName) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `mb-2 ${sender === 'user' ? 'text-right' : 'text-left'}`;
            
            const bubble = document.createElement('div');
            bubble.className = `inline-block px-3 py-2 rounded-lg max-w-xs ${
                sender === 'user' 
                    ? 'bg-teal-500 text-white' 
                    : 'bg-gray-600 text-gray-100'
            }`;
            
            const nameSpan = document.createElement('div');
            nameSpan.className = 'text-xs opacity-75 mb-1 cursor-pointer hover:bg-blue-600 hover:text-white px-2 py-1 rounded transition-colors';
            nameSpan.textContent = senderName;
            
            // üéØ CHAT'TE BAKTERƒ∞ SE√áƒ∞Mƒ∞ - ƒ∞sme tƒ±klayƒ±nca bakteriyi se√ß
            if (sender === 'bacteria') {
                nameSpan.addEventListener('click', () => {
                    const bacteria = bacteriaPopulation.find(b => b.name === senderName);
                    if (bacteria) {
                        selectBacteria(bacteria);
                        console.log(`üéØ Selected bacteria ${senderName} from chat`);
                        
                        // Visual feedback
                        nameSpan.style.background = '#10B981';
                        nameSpan.style.color = 'white';
                        setTimeout(() => {
                            nameSpan.style.background = '';
                            nameSpan.style.color = '';
                        }, 1000);
                    }
                });
                
                nameSpan.title = `${senderName} bakterisini se√ßmek i√ßin tƒ±klayƒ±n`;
            }
            
            const messageSpan = document.createElement('div');
            messageSpan.textContent = message;
            
            bubble.appendChild(nameSpan);
            bubble.appendChild(messageSpan);
            messageDiv.appendChild(bubble);
            messagesArea.appendChild(messageDiv);
            
            // Auto scroll
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function sendIndividualMessage(bacteria, chatInput, messagesArea) {
            const message = chatInput.value.trim();
            if (!message) return;
            
            // Add user message
            addMessageToWindow(messagesArea, message, 'user', 'Sen');
            
            // Save to bacteria's conversation history
            bacteria.conversation_history = bacteria.conversation_history || [];
            
            // Generate bacteria response
            setTimeout(async () => {
                const response = await generateBacteriaResponse(bacteria, message, 'user');
                addMessageToWindow(messagesArea, response, 'bacteria', bacteria.name);
                
                // Save conversation
                bacteria.conversation_history.push({ user: message, bacteria: response });
                
                // Learn from user
                const newWords = learnFromUserInput(message, bacteria);
                if (newWords > 0) {
                    bacteria.consciousness_level = bacteria.consciousness_level + 0.02;
                }
                
            }, 500 + Math.random() * 1000);
            
            chatInput.value = '';
        }

        function makeDraggable(modal, header) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = modal.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                
                modal.style.position = 'fixed';
                modal.style.left = initialX + 'px';
                modal.style.top = initialY + 'px';
                modal.classList.remove('items-center', 'justify-center');
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                modal.style.left = (initialX + dx) + 'px';
                modal.style.top = (initialY + dy) + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        function setupGroupChat() {
            chatMode = 'group';
            selectedBacteria = null;
            chatInfoDiv.innerHTML = `<strong>Grup Sohbeti</strong> - T√ºm bakterilerle konu≈üuyorsunuz.`;
            chatMessagesDiv.innerHTML = '';
            chatInput.disabled = false;
            sendMessageBtn.disabled = false;
            chatInput.placeholder = "T√ºm bakterilerle konu≈ü...";
            chatInput.focus();
            updateChatModeButtons();
            updateBuildInfo();
            console.log(`üë• Group chat mode activated with ${bacteriaPopulation.length} bacteria`);
        }

        function updateChatModeButtons() {
            const individualBtn = document.getElementById('individualChatBtn');
            const groupBtn = document.getElementById('groupChatBtn');
            
            if (chatMode === 'individual') {
                individualBtn.className = 'bg-blue-700 text-white px-3 py-1 rounded text-sm';
                groupBtn.className = 'bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded text-sm transition';
            } else {
                individualBtn.className = 'bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded text-sm transition';
                groupBtn.className = 'bg-green-700 text-white px-3 py-1 rounded text-sm';
            }
        }

        // ESKƒ∞ EVENT Lƒ∞STENERLAR KALDIRILDI - YE≈ûƒ∞ EVENT DELEGATƒ∞ON Sƒ∞STEMƒ∞ KULLANILIYOR
        // nextStepBtn ve resetSimulationBtn artƒ±k yok, data-action ile y√∂netiliyor

        // Add food on click
        simulationArea.addEventListener('click', (e) => {
            const rect = simulationArea.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            addFood(x, y);
        });

        sendMessageBtn.addEventListener('click', () => {
            const message = chatInput.value.trim();
            if (message) {
                if (chatMode === 'group') {
                    // GRUP SOHBETƒ∞ - T√ºm bakterilere g√∂nder
                    sendMessageToAllBacteria(message);
                } else if (selectedBacteria) {
                    // TEKƒ∞L SOHBETƒ∞ - Sadece se√ßili bakteriye g√∂nder
                    sendMessageToIndividualBacteria(selectedBacteria, message);
                } else {
                    alert('‚ö†Ô∏è √ñnce bir bakteri se√ßin veya grup sohbetine ge√ßin.');
                    return;
                }
                chatInput.value = '';
            }
        });

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !chatInput.disabled) {
                sendMessageBtn.click();
            }
        });

        // Chat mode event listeners
        document.getElementById('individualChatBtn').addEventListener('click', () => {
            if (selectedBacteria) {
                // v826: Use new modal system instead of old chat
                openIndividualChatWindow(selectedBacteria);
            } else {
                alert('‚ö†Ô∏è √ñnce bir bakteri se√ßin. Bir bakteriye tƒ±klayarak se√ßebilirsiniz.');
            }
        });

        document.getElementById('groupChatBtn').addEventListener('click', () => {
            setupGroupChat();
        });

        document.getElementById('startBacteriaConversationBtn').addEventListener('click', () => {
            console.log('üéØ Manual bacteria conversation button clicked');
            
            // Use the new conversation system
            if (bacteriaList.length >= 2) {
                const consciousBacteria = bacteriaList.filter(b => b.consciousness > 0.4);
                if (consciousBacteria.length >= 2) {
                    console.log(`ü§ù Found ${consciousBacteria.length} conscious bacteria, starting conversation...`);
                    initiateBacteriaConversation();
                } else {
                    console.log('‚ö†Ô∏è Not enough conscious bacteria for conversation (need consciousness > 40%)');
                    alert(`‚ö†Ô∏è Need bacteria with >40% consciousness. Current: ${bacteriaList.map(b => `${b.name}: ${(b.consciousness*100).toFixed(0)}%`).join(', ')}`);
                }
            } else {
                console.log('‚ö†Ô∏è Need at least 2 bacteria for conversation');
                alert('‚ö†Ô∏è Need at least 2 bacteria for conversation');
            }
        });

        // v829: High-Frequency Auto Bacteria Conversations for Dynamic Experience
        setInterval(() => {
            if (bacteriaPopulation.length >= 2) {
                // Very high frequency natural conversations for dynamic experience
                const socialBacteria = bacteriaPopulation.filter(b => b.personality_traits.sociability > 0.3);
                
                if (socialBacteria.length >= 2 && Math.random() < 0.9) { // 90% chance for more interactions
                    startNaturalBacteriaConversation(socialBacteria);
                }
                
                // More frequent learning sessions
                if (bacteriaPopulation.length >= 3 && Math.random() < 0.4) { // 40% chance
                    startGroupLearningSession();
                }
            }
        }, 2500); // Every 2.5 seconds - even more frequent interactions

        // Initialize ML System
        async function initializeMLSystem() {
            console.log('üß† Initializing TensorFlow.js ML System...');
            
            try {
                // Initialize tokenizer
                initializeTokenizer();
                
                // Create models
                console.log('üîß Creating neural network models...');
                wordEmbeddingModel = await createWordEmbeddingModel();
                behaviorPredictionModel = await createBehaviorModel();
                
                isMLReady = true;
                console.log('‚úÖ ML System ready! TensorFlow.js version:', tf.version.tfjs);
                updateBuildInfo();
                
            } catch (error) {
                console.error('‚ùå ML System initialization failed:', error);
                isMLReady = false;
            }
        }

        // Memory Management System for better performance
        class MemoryManager {
            static cleanup() {
                // Remove invalid bacteria references
                bacteriaList = bacteriaList.filter(bacteria => 
                    bacteria && bacteria.x !== undefined && bacteria.biological_state
                );
                
                // Cleanup old food particles
                if (foodParticles.length > 20) {
                    foodParticles.splice(0, foodParticles.length - 15);
                }
                
                // Compact bacteria memory arrays
                bacteriaList.forEach(bacteria => {
                    if (bacteria.memory_bank && bacteria.memory_bank.length > 20) {
                        bacteria.memory_bank = bacteria.memory_bank.slice(-15);
                    }
                    if (bacteria.consciousness_history && bacteria.consciousness_history.length > 50) {
                        bacteria.consciousness_history = bacteria.consciousness_history.slice(-30);
                    }
                });

                console.log('üßπ Memory cleanup completed');
            }

            static getMemoryUsage() {
                if (performance.memory) {
                    return {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                    };
                }
                return { used: 0, total: 0, limit: 0 };
            }
        }

        // Enhanced Data Export Function with memory info
        function exportEnhancedData() {
            const memoryInfo = MemoryManager.getMemoryUsage();
            const exportData = {
                version: VERSION,
                timestamp: new Date().toISOString(),
                simulation: {
                    day: simulationManager ? simulationManager.simulationDay : 0,
                    totalBacteria: bacteriaList.length,
                    running: simulationRunning
                },
                performance: {
                    fps: performanceMetrics.fps,
                    renderTime: performanceMetrics.renderTime,
                    memoryUsage: performanceMetrics.totalMemoryUsage,
                    systemMemory: memoryInfo
                },
                bacteria: bacteriaList.map(b => ({
                    id: b.id,
                    name: b.name,
                    consciousness: b.consciousness_level,
                    age: b.biological_state.age,
                    size: b.biological_state.size,
                    vocabularySize: b.vocabulary.size,
                    position: { x: b.x, y: b.y },
                    personality: b.personality_traits
                })),
                summary: {
                    averageConsciousness: bacteriaList.reduce((sum, b) => sum + b.consciousness_level, 0) / bacteriaList.length,
                    maxConsciousness: Math.max(...bacteriaList.map(b => b.consciousness_level)),
                    totalVocabulary: new Set(bacteriaList.flatMap(b => Array.from(b.vocabulary))).size
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `neomag_export_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('üìä Enhanced data export completed:', exportData.summary);
        }

        // Initialize everything with modern architecture
        async function initialize() {
            console.log(`üöÄ Starting NeoMag ${VERSION} with Advanced AI/ML`);
            
            // Initialize AI systems first
            const aiSuccess = initializeAISystems();
            if (!aiSuccess) {
                console.warn('‚ö†Ô∏è AI systems failed to initialize, continuing without AI');
            }
            
            // Initialize UI Manager for event delegation
            uiManager = new UIManager(simulationManager);
            updateBuildInfo();
            initializeBacteria();
            initializeCanvas(); // v829: Initialize canvas support
            await initializeMLSystem();
            
            // Show feature list
            console.log('üìã Available Features:');
            FEATURES.forEach((feature, i) => {
                console.log(`   ${i+1}. ${feature}`);
            });
            
            // Update version to show AI integration
            const versionDisplay = document.querySelector('h1');
            if (versionDisplay && aiSuccess) {
                versionDisplay.innerHTML = 'üß¨ mnBac v9.6.2 - System Readiness & GitHub Pages Fix';
            }
        }

        // Initialize simulation (v826)
        async function initializeV826() {
            console.log('üöÄ Initializing mnBac v9.6.2 - System Readiness & GitHub Pages Fix...');
            
            // Initialize ML models first (placeholder)
            console.log('üß† ML models loading skipped for now');
            
            // Auto-restore from database or create new bacteria
            await autoRestoreFromDatabase();
            
            updateBuildInfo();
            renderBacteria();
            
            console.log('‚úÖ Initialization complete');
        }

        // Start v826 initialization after main initialization
        setTimeout(initializeV826, 1000);

        // v825: Database Control Functions
        async function exportCSV() {
            console.log('üìä Exporting CSV for TabPFN analysis...');
            await persistentDB.exportToCSV();
        }

        async function saveAllNow() {
            console.log('üíæ Manual save triggered...');
            for (const bacteria of bacteriaList) {
                await bacteria.saveToDatabase();
            }
            
            // Save simulation state
            await persistentDB.saveSimulationState(
                simulationDay, 
                bacteriaList, 
                performanceMetrics
            );
            
            console.log('‚úÖ All bacteria and simulation state saved');
        }

        async function loadFromDatabase() {
            console.log('üìñ Loading bacteria from database...');
            const savedBacteria = await persistentDB.loadBacteria();
            
            if (savedBacteria.length === 0) {
                console.log('‚ö†Ô∏è No saved bacteria found');
                return;
            }
            
            // Clear current bacteria
            bacteriaList = [];
            
            // Restore bacteria from database
            let maxId = 0;
            savedBacteria.forEach(bacteriaData => {
                const bacteria = new BacteriaEntity(bacteriaData.id, bacteriaData.name, bacteriaData);
                bacteriaList.push(bacteria);
                maxId = Math.max(maxId, bacteriaData.id);
            });
            
            // Update ID counter
            bacteriaIdCounter = maxId + 1;
            
            console.log(`üìñ Restored ${savedBacteria.length} bacteria from database`);
            updateBuildInfo();
            renderBacteria();
        }

        async function clearDatabase() {
            if (confirm('‚ö†Ô∏è This will permanently delete all saved bacteria data. Continue?')) {
                console.log('üóëÔ∏è Clearing database...');
                await persistentDB.clearDatabase();
                console.log('‚úÖ Database cleared');
            }
        }

        async function showDatabaseStats() {
            const savedBacteria = await persistentDB.loadBacteria();
            
            if (savedBacteria.length === 0) {
                alert('üìä Database Stats:\n\nNo bacteria data found');
                return;
            }
            
            const totalBacteria = savedBacteria.length;
            const avgConsciousness = savedBacteria.reduce((sum, b) => sum + b.consciousness_level, 0) / totalBacteria;
            const maxConsciousness = Math.max(...savedBacteria.map(b => b.consciousness_level));
            const totalVocab = new Set(savedBacteria.flatMap(b => b.vocabulary)).size;
            const avgAge = savedBacteria.reduce((sum, b) => sum + b.biological_state.age, 0) / totalBacteria;
            const maxRuntimeDays = Math.max(...savedBacteria.map(b => b.total_runtime_days || 0));
            
            const stats = `üìä Database Stats:
            
Total Bacteria: ${totalBacteria}
Average Consciousness: ${avgConsciousness.toFixed(2)}
Maximum Consciousness: ${maxConsciousness.toFixed(2)}
Total Unique Vocabulary: ${totalVocab} words
Average Age: ${avgAge.toFixed(1)} days
Maximum Runtime: ${maxRuntimeDays} days

Consciousness Levels:
‚Ä¢ 0-1: ${savedBacteria.filter(b => b.consciousness_level < 1).length}
‚Ä¢ 1-5: ${savedBacteria.filter(b => b.consciousness_level >= 1 && b.consciousness_level < 5).length}
‚Ä¢ 5-10: ${savedBacteria.filter(b => b.consciousness_level >= 5 && b.consciousness_level < 10).length}
‚Ä¢ 10-50: ${savedBacteria.filter(b => b.consciousness_level >= 10 && b.consciousness_level < 50).length}
‚Ä¢ 50+: ${savedBacteria.filter(b => b.consciousness_level >= 50).length}`;
            
            alert(stats);
        }

        // Missing Event Handler Functions
        function toggleGroupChat() {
            chatMode = chatMode === 'individual' ? 'group' : 'individual';
            console.log(`üí¨ Chat mode switched to: ${chatMode}`);
        }
        
        function exportCSV() {
            console.log('üìä CSV Export triggered');
            // Functionality implemented elsewhere
        }
        
        function exportEnhancedData() {
            console.log('üìà JSON Export triggered');
            // Functionality implemented elsewhere
        }
        
        // üß¨ CRITICAL MISSING FUNCTION
        function addBacteria() {
            if (bacteriaPopulation.length >= CONFIG.SIMULATION.MAX_BACTERIA_POPULATION) {
                alert(`‚ö†Ô∏è Maximum ${CONFIG.SIMULATION.MAX_BACTERIA_POPULATION} bacteria limit reached!`);
                return;
            }
            
            const bacteria = new BacteriaEntity(bacteriaIdCounter, `Bakteri-${bacteriaIdCounter}`);
            bacteriaPopulation.push(bacteria);
            bacteriaList.push(bacteria); // v826 compatibility
            bacteriaIdCounter++;
            
            console.log(`‚ûï New bacteria added: ${bacteria.name} (Total: ${bacteriaPopulation.length})`);
            
            // Update displays
            updateBuildInfo();
            if (typeof renderBacteria === 'function') renderBacteria();
        }
        
        // üöÄ CRITICAL MISSING FUNCTION  
        function initializeBacteria() {
            console.log('üöÄ Initializing bacteria population...');
            
            // Clear existing populations
            bacteriaPopulation = [];
            bacteriaList = [];
            
            // Create initial bacteria
            for (let i = 0; i < CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT; i++) {
                const bacteria = new BacteriaEntity(bacteriaIdCounter, `Bakteri-${bacteriaIdCounter}`);
                bacteriaPopulation.push(bacteria);
                bacteriaList.push(bacteria); // v826 compatibility
                bacteriaIdCounter++;
            }
            
            console.log(`‚úÖ ${CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT} bacteria initialized`);
            updateBuildInfo();
        }

        function showLearningStats() {
            console.log('üß† SHOWING LEARNING STATS...');
            
            // Check if learning engine exists
            if (!learningEngine) {
                alert('‚ö†Ô∏è AI Learning Engine is not initialized yet. Please wait for system to fully load.');
                return;
            }
            
            let fullStats = '';
            
            // üß¨ Enhanced Persistent Learning Stats
            if (window.persistentLearning && window.persistentLearning.isReady) {
                const persistentStats = window.persistentLearning.getLearningStats();
                
                let topWordsText = 'üìö Top Learned Words:\n';
                persistentStats.topWords.slice(0, 8).forEach(({word, successRate}) => {
                    const percentage = (successRate * 100).toFixed(0);
                    const emoji = successRate > 0.8 ? 'üåü' : successRate > 0.6 ? '‚úÖ' : 'üìñ';
                    topWordsText += `${emoji} ${word}: ${percentage}% success\n`;
                });
                
                let topContextsText = '\nüéØ Top Context Patterns:\n';
                persistentStats.topContexts.forEach(({context, effectiveness}) => {
                    const percentage = (effectiveness * 100).toFixed(0);
                    const emoji = effectiveness > 0.8 ? 'üöÄ' : effectiveness > 0.6 ? '‚úÖ' : 'üìä';
                    topContextsText += `${emoji} ${context}: ${percentage}% effective\n`;
                });
                
                fullStats += `üß¨ Persistent Learning Engine Stats:

üíæ Total Interactions: ${persistentStats.totalInteractions}
üìö Vocabulary Size: ${persistentStats.vocabularySize} words
üìà Average Success Rate: ${(persistentStats.averageSuccessRate * 100).toFixed(1)}%
üìä Learning Trend: ${(persistentStats.learningTrend * 100).toFixed(0)}%

${topWordsText}${topContextsText}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

`;
            }
            
            // üß† Original AI Learning Stats
            const stats = learningEngine.getStats();
            const recentDecisions = learningEngine.decisionLog.slice(-10);
            
            let recentSummary = 'üìä Recent AI Decisions:\n';
            recentDecisions.forEach((log, i) => {
                const outcome = log.outcome || 'pending';
                const emoji = outcome === 'success' ? '‚úÖ' : outcome === 'failure' ? '‚ùå' : '‚è≥';
                recentSummary += `${emoji} ${log.source}: ${log.output.substring(0, 30)}... (${(log.confidence * 100).toFixed(0)}%)\n`;
            });
            
            const errorPatterns = Array.from(learningEngine.errorPatterns.entries()).slice(0, 3);
            let errorSummary = '\nüö® Top Error Patterns:\n';
            errorPatterns.forEach(([pattern, data]) => {
                const p = JSON.parse(pattern);
                errorSummary += `‚Ä¢ ${p.source} confidence ${p.confidenceRange}: ${data.count} failures\n`;
            });
            
            fullStats += `üß† AI Self-Learning Stats:

üìà Total Decisions: ${stats.totalDecisions}
üéØ Recent Success Rate: ${(stats.recentSuccessRate * 100).toFixed(1)}%
‚ùå Error Patterns Detected: ${stats.errorPatterns}
‚úÖ Success Patterns Learned: ${stats.successPatterns}

${recentSummary}${errorSummary}

üî¨ The AI is continuously learning from decision outcomes and user interactions to improve future predictions.`;
            
            alert(fullStats);
        }

        // üß¨ Clear Persistent Learning Database
        async function clearLearningDatabase() {
            if (!window.persistentLearning || !window.persistentLearning.isReady) {
                alert('‚ö†Ô∏è Persistent Learning Engine is not ready yet.');
                return;
            }
            
            const confirmed = confirm(
                'üö® Are you sure you want to clear all learning data?\n\n' +
                'This will delete:\n' +
                '‚Ä¢ All user interactions\n' +
                '‚Ä¢ Learned vocabulary with success rates\n' +
                '‚Ä¢ Context patterns\n' +
                '‚Ä¢ Learning metrics\n\n' +
                'This action cannot be undone!'
            );
            
            if (confirmed) {
                try {
                    await window.persistentLearning.clearDatabase();
                    alert('‚úÖ Learning database cleared successfully!\n\nThe system will start learning fresh from your next interactions.');
                    console.log('üß¨ Persistent Learning Database cleared by user');
                } catch (error) {
                    console.error('‚ùå Failed to clear learning database:', error);
                    alert('‚ùå Failed to clear learning database. Please check the console for details.');
                }
            }
        }

        // üõ°Ô∏è System Readiness Checker
        function isSystemReady() {
            // Priority 1: Check if system is fully ready
            if (window.systemFullyReady) {
                return true;
            }
            
            // Priority 2: Check if basic simulation is ready (bacteria exist)
            if (bacteriaList && bacteriaList.length > 0) {
                return true;
            }
            
            // Priority 3: Check if any critical system is available
            const checks = {
                enhancedMorphGenerator: window.enhancedMorphGenerator || window.morphGenerator,
                languageEvolutionEngine: window.languageEvolutionEngine,
                simulationManager: window.simulationManager
            };
            
            return Object.values(checks).some(check => check);
        }
        
        // üìä Get System Status for User Info
        function getSystemStatus() {
            const status = {
                fullyReady: !!window.systemFullyReady,
                bacteriaCount: bacteriaList ? bacteriaList.length : 0,
                systemsLoaded: 0,
                totalSystems: 4,
                readyTime: window.systemFullyReady ? 'Ready!' : 'Loading...'
            };
            
            if (window.enhancedMorphGenerator) status.systemsLoaded++;
            if (window.languageEvolutionEngine) status.systemsLoaded++;
            if (window.simulationManager) status.systemsLoaded++;
            if (bacteriaList && bacteriaList.length > 0) status.systemsLoaded++;
            
            return status;
        }

        // üé≠ Show Word Diversity Stats
        function showDiversityStats() {
            console.log('üé≠ SHOWING DIVERSITY STATS...');
            
            // Check if any system is ready, show detailed status
            if (!isSystemReady()) {
                const status = getSystemStatus();
                alert(`‚ö†Ô∏è System is still initializing...\n\nüìä Status: ${status.systemsLoaded}/${status.totalSystems} systems loaded\nüß¨ Bacteria: ${status.bacteriaCount}\n‚è±Ô∏è ${status.readyTime}\n\nPlease wait a few more seconds and try again.\nFull initialization takes about 5-10 seconds.`);
                return;
            }
            
            try {
                // Import the diversity function dynamically
                import('./src/engine/MorphologicalDialogueGenerator.js').then(module => {
                    const { showDiversityStats } = module;
                    const stats = showDiversityStats();
                    
                    // Format the stats nicely
                    let displayText = `üé≠ WORD DIVERSITY ANALYSIS:

üìù Recent Words Used:
${stats.recentWords.map(word => `‚Ä¢ ${word}`).join('\n')}

üîÅ Most Repeated Words:
${stats.topRepeated.map(([word, count]) => `‚Ä¢ ${word}: ${count} times`).join('\n')}

üö´ Currently Banned Words:
${stats.bannedWords.length > 0 ? stats.bannedWords.map(word => `‚Ä¢ ${word}`).join('\n') : '‚Ä¢ None (Good!)'}

üéØ Current Context: ${stats.currentContext}
üìä Sentences Generated: ${stats.sentenceCount}
üìö Total Vocabulary Used: ${stats.totalWordUsage} unique words

üîç ANALYSIS:
${stats.bannedWords.length > 0 ? 
  `‚ö†Ô∏è ${stats.bannedWords.length} words are temporarily banned due to overuse.` :
  '‚úÖ No words are banned - good diversity!'
}

${stats.topRepeated.length > 0 && stats.topRepeated[0][1] > 3 ?
  `üîÑ Word "${stats.topRepeated[0][0]}" has been used ${stats.topRepeated[0][1]} times recently.` :
  '‚úÖ No excessive word repetition detected.'
}

Context rotation is ${stats.sentenceCount > 0 ? 'active' : 'starting'}. Each 3 sentences trigger a context change.`;
                    
                    alert(displayText);
                }).catch(error => {
                    console.error('‚ùå Failed to load diversity stats:', error);
                    alert('‚ùå Failed to load diversity stats. Check console for details.');
                });
                
            } catch (error) {
                console.error('‚ùå Error showing diversity stats:', error);
                alert('‚ùå Error showing diversity stats. The Enhanced Morphological System might not be fully loaded yet.');
            }
        }

        // üîÑ Reset Diversity System
        function resetDiversitySystem() {
            console.log('üîÑ RESETTING DIVERSITY SYSTEM...');
            
            if (!isSystemReady()) {
                const status = getSystemStatus();
                alert(`‚ö†Ô∏è System is still initializing...\n\nüìä Status: ${status.systemsLoaded}/${status.totalSystems} systems loaded\nüß¨ Bacteria: ${status.bacteriaCount}\n‚è±Ô∏è ${status.readyTime}\n\nPlease wait a few more seconds and try again.\nFull initialization takes about 5-10 seconds.`);
                return;
            }
            
            const confirmed = confirm(
                'üîÑ Reset Word Diversity System?\n\n' +
                'This will:\n' +
                '‚Ä¢ Clear recent word history\n' +
                '‚Ä¢ Remove all banned words\n' +
                '‚Ä¢ Reset word usage counters\n' +
                '‚Ä¢ Reset context rotation\n\n' +
                'This can help if bacteria are stuck in repetitive patterns.'
            );
            
            if (confirmed) {
                try {
                    import('./src/engine/MorphologicalDialogueGenerator.js').then(module => {
                        const { resetDiversityEngine } = module;
                        resetDiversityEngine();
                        
                        alert('‚úÖ Diversity system reset successfully!\n\nBacteria will now have access to fresh vocabulary patterns.');
                        console.log('üîÑ Diversity system reset by user');
                    }).catch(error => {
                        console.error('‚ùå Failed to reset diversity system:', error);
                        alert('‚ùå Failed to reset diversity system. Check console for details.');
                    });
                    
                } catch (error) {
                    console.error('‚ùå Error resetting diversity system:', error);
                    alert('‚ùå Error resetting diversity system. The Enhanced Morphological System might not be fully loaded yet.');
                }
            }
        }

        // üß† Language Evolution Stats Function
        function showLanguageEvolutionStats() {
            console.log('üìä LANGUAGE EVOLUTION STATS...');
            
            if (!isSystemReady()) {
                const status = getSystemStatus();
                alert(`‚ö†Ô∏è System is still initializing...\n\nüìä Status: ${status.systemsLoaded}/${status.totalSystems} systems loaded\nüß¨ Bacteria: ${status.bacteriaCount}\n‚è±Ô∏è ${status.readyTime}\n\nPlease wait a few more seconds and try again.\nFull initialization takes about 5-10 seconds.`);
                return;
            }
            
            try {
                const stats = {
                    totalGenerations: bacteriaList.reduce((sum, b) => sum + (b.languageGeneration || 0), 0),
                    avgVocabularySize: bacteriaList.reduce((sum, b) => sum + (b.vocabulary ? b.vocabulary.size : 0), 0) / bacteriaList.length,
                    totalWords: bacteriaList.reduce((sum, b) => sum + (b.vocabulary ? b.vocabulary.size : 0), 0),
                    activeBacteria: bacteriaList.length,
                    languageEvolutionRate: bacteriaList.filter(b => b.consciousness > 0.5).length / bacteriaList.length
                };
                
                const message = `üß† Language Evolution Statistics\n\n` +
                    `üìà Total Language Generations: ${stats.totalGenerations}\n` +
                    `üìö Average Vocabulary Size: ${stats.avgVocabularySize.toFixed(1)} words\n` +
                    `üî§ Total Words in System: ${stats.totalWords}\n` +
                    `üß¨ Active Bacteria: ${stats.activeBacteria}\n` +
                    `‚ö° Language Evolution Rate: ${(stats.languageEvolutionRate * 100).toFixed(1)}%\n\n` +
                    `üí° High-consciousness bacteria (>50%) are actively evolving language patterns.`;
                
                alert(message);
                console.log('üìä Language Evolution Stats:', stats);
                
            } catch (error) {
                console.error('‚ùå Error getting language evolution stats:', error);
                alert('‚ùå Error retrieving language evolution statistics. Check console for details.');
            }
        }

        // üó£Ô∏è Peer Dialogue Function  
        function runPeerDialogue() {
            console.log('üó£Ô∏è PEER DIALOGUE...');
            
            if (bacteriaList.length < 2) {
                alert('‚ö†Ô∏è Peer Dialogue requires at least 2 bacteria.\n\nPlease add more bacteria to the simulation.');
                return;
            }
            
            try {
                // Select two random bacteria with highest consciousness
                const conscientBacteria = bacteriaList
                    .filter(b => b.consciousness > 0.3)
                    .sort((a, b) => b.consciousness - a.consciousness);
                
                if (conscientBacteria.length < 2) {
                    alert('‚ö†Ô∏è Need at least 2 conscious bacteria (consciousness > 30%).\n\nWait for bacteria to develop more consciousness.');
                    return;
                }
                
                const bacteria1 = conscientBacteria[0];
                const bacteria2 = conscientBacteria[1];
                
                // Generate peer dialogue
                const topics = ['science', 'art', 'emotion', 'discovery', 'mystery', 'friendship', 'evolution', 'creativity'];
                const topic = topics[Math.floor(Math.random() * topics.length)];
                
                console.log(`üó£Ô∏è Peer dialogue between ${bacteria1.name} and ${bacteria2.name} about ${topic}`);
                
                // Generate responses using language evolution engine
                if (window.languageEvolutionEngine && window.languageEvolutionEngine.generateCrossBacteriaDialogue) {
                    window.languageEvolutionEngine.generateCrossBacteriaDialogue(bacteria1, bacteria2, topic)
                        .then(dialogue => {
                            alert(`üó£Ô∏è Peer Dialogue: ${topic}\n\n${dialogue}`);
                            
                            // Add to chat
                            addChatMessage(`üó£Ô∏è ${bacteria1.name} ‚Üî ${bacteria2.name}`, dialogue, 'peer-dialogue');
                        })
                        .catch(error => {
                            console.error('‚ùå Peer dialogue generation failed:', error);
                            
                            // Fallback simple dialogue
                            const fallbackDialogue = `${bacteria1.name}: "Bu ${topic} konusu √ßok ilgin√ß..."\n${bacteria2.name}: "Evet, ben de √∂yle d√º≈ü√ºn√ºyorum!"`;
                            alert(`üó£Ô∏è Peer Dialogue (Simple): ${topic}\n\n${fallbackDialogue}`);
                        });
                } else {
                    // Simple fallback without language evolution engine
                    const simpleDialogue = `${bacteria1.name}: "Merhaba ${bacteria2.name}!"\n${bacteria2.name}: "Selam ${bacteria1.name}! Nasƒ±lsƒ±n?"`;
                    alert(`üó£Ô∏è Simple Peer Dialogue\n\n${simpleDialogue}`);
                    addChatMessage(`üó£Ô∏è ${bacteria1.name} ‚Üî ${bacteria2.name}`, simpleDialogue, 'simple-dialogue');
                }
                
            } catch (error) {
                console.error('‚ùå Error in peer dialogue:', error);
                alert('‚ùå Error running peer dialogue. Check console for details.');
            }
        }

        // v825: Auto-restore on page load
        async function autoRestoreFromDatabase() {
            console.log('üîÑ Checking for saved bacteria to restore...');
            
            // Wait for database to be ready
            const maxWait = 5000; // 5 seconds
            const startTime = Date.now();
            
            while (!persistentDB.isReady && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (!persistentDB.isReady) {
                console.log('‚ö†Ô∏è Database not ready, skipping auto-restore');
                return;
            }
            
            const savedBacteria = await persistentDB.loadBacteria();
            
            if (savedBacteria.length > 0) {
                console.log(`üîÑ Auto-restoring ${savedBacteria.length} bacteria from previous session...`);
                
                // Clear current bacteria
                bacteriaList = [];
                
                // Restore bacteria
                let maxId = 0;
                savedBacteria.forEach(bacteriaData => {
                    const bacteria = new BacteriaEntity(bacteriaData.id, bacteriaData.name, bacteriaData);
                    bacteriaList.push(bacteria);
                    maxId = Math.max(maxId, bacteriaData.id);
                });
                
                bacteriaIdCounter = maxId + 1;
                
                console.log('‚úÖ Auto-restore complete');
                updateBuildInfo();
                renderBacteria();
            } else {
                console.log('üìù No saved bacteria found, starting fresh simulation');
                
                // Create initial bacteria if none exist
                if (bacteriaList.length === 0) {
                    initializeBacteria();
                }
            }
        }

        // Dynamic Script Loader Utility
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                // Check if script already loaded
                if (document.querySelector(`script[src="${src}"]`)) {
                    resolve();
                    return;
                }
                
                const script = document.createElement('script');
                script.src = src;
                script.type = 'module';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Global Event Delegation System (Modern Approach)
        function initializeEventDelegation() {
            document.addEventListener('click', function(event) {
                const button = event.target.closest('button');
                if (!button || !button.dataset.action) return;
                
                const action = button.dataset.action;
                console.log(`üéØ Action triggered: ${action}`);
                
                // Ana kontrol paneli
                if (action === 'start-simulation') {
                    console.log('üî• START-SIMULATION CLICKED!', { simulationManager: !!simulationManager });
                    
                    if (!simulationManager) {
                        console.error('‚ùå SimulationManager not ready yet - creating emergency instance');
                        alert('‚ö†Ô∏è Sistem hen√ºz hazƒ±r deƒüil! L√ºtfen biraz bekleyin ve tekrar deneyin.');
                        
                        // Emergency initialization
                        try {
                            simulationManager = new SimulationManager();
                            console.log('‚úÖ Emergency SimulationManager created');
                        } catch (e) {
                            console.error('‚ùå Emergency SimulationManager creation failed:', e);
                            return;
                        }
                    }
                    
                    console.log('üî• SimulationManager isRunning:', simulationManager.isRunning);
                    
                    if (simulationManager.isRunning) {
                        simulationManager.pause();
                        button.textContent = '‚ñ∂Ô∏è Sim√ºlasyonu Ba≈ülat';
                        console.log('‚è∏Ô∏è Simulation paused');
                    } else {
                        simulationManager.start();
                        button.textContent = '‚è∏Ô∏è Sim√ºlasyonu Duraklat';
                        console.log('‚ñ∂Ô∏è Simulation started');
                    }
                }
                else if (action === 'pause-simulation') {
                    if (simulationManager) simulationManager.pause();
                }
                else if (action === 'reset-simulation') {
                    if (simulationManager) simulationManager.reset();
                }
                else if (action === 'add-bacteria') addBacteria();
                else if (action === 'toggle-group-chat') toggleGroupChat();
                
                // Database operations
                else if (action === 'export-csv') exportCSV();
                else if (action === 'export-json') exportEnhancedData();
                else if (action === 'save-all') saveAllNow();
                else if (action === 'load-saved') loadFromDatabase();
                else if (action === 'clear-db') clearDatabase();
                else if (action === 'show-db-stats') showDatabaseStats();
                else if (action === 'show-learning-stats') showLearningStats();
                else if (action === 'clear-learning-db') clearLearningDatabase();
                else if (action === 'show-diversity-stats') showDiversityStats();
                else if (action === 'reset-diversity') resetDiversitySystem();
                else if (action === 'show-language-stats') showLanguageEvolutionStats();
                else if (action === 'peer-dialogue') runPeerDialogue();
                else if (action === 'debug-system') debugSystemStatus();
                else if (action === 'test-conversation') testBacteriaConversation();
                else if (action === 'force-auto-conversation') forceStartAutoConversations();
            });
        }
        
        // üéØ BACTERIA SELECTION SYSTEM
        
        // Switch to individual chat mode
        function switchToIndividualChat(bacteria) {
            console.log(`üí¨ Switching to individual chat with: ${bacteria.name}`);
            
            // Get chat elements
            const chatModeIndicator = document.querySelector('.chat-mode-indicator');
            const chatInput = document.getElementById('chatInput');
            
            // Update chat mode
            chatMode = 'individual';
            
            // Update UI
            if (chatModeIndicator) {
                chatModeIndicator.textContent = `Individual Chat: ${bacteria.name}`;
                chatModeIndicator.className = 'chat-mode-indicator bg-blue-600 text-white px-3 py-1 rounded text-sm';
            }
            
            // Clear and focus input
            if (chatInput) {
                chatInput.placeholder = `Message ${bacteria.name}...`;
                chatInput.focus();
            }
            
            // Update build info
            updateBuildInfo();
        }
        
        // Highlight selected bacteria visually
        function highlightSelectedBacteria(bacteria) {
            bacteria.isSelected = true;
            bacteria.selectionTime = Date.now();
            
            // Remove selection from other bacteria
            bacteriaList.forEach(b => {
                if (b !== bacteria) {
                    b.isSelected = false;
                }
            });
            
            console.log(`‚ú® Bacteria highlighted: ${bacteria.name}`);
        }
        
        // Add speech bubble above bacteria (NO MSGBOX!)
        function showSpeechBubble(bacteria, message) {
            // Create speech bubble element
            const bubble = document.createElement('div');
            bubble.className = 'speech-bubble';
            bubble.innerHTML = `
                <div class="speech-content">
                    <strong>${bacteria.name}:</strong><br/>
                    ${message}
                </div>
                <div class="speech-arrow"></div>
            `;
            
            // FIXED POSITIONING - Canvas Relative Coordinates
            let bubbleX = 100; // Default position
            let bubbleY = 100;
            
            try {
                // Get canvas element (multiple ways)
                const canvasElement = canvas || document.querySelector('canvas') || document.getElementById('canvas') || simulationArea?.querySelector('canvas');
                
                if (canvasElement && typeof canvasElement.getBoundingClientRect === 'function') {
                    const canvasRect = canvasElement.getBoundingClientRect();
                    const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                    const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                    
                    // Calculate absolute position on page
                    bubbleX = canvasRect.left + scrollX + (bacteria.x || 0) - 75; // Center bubble (150px width / 2)
                    bubbleY = canvasRect.top + scrollY + (bacteria.y || 0) - 80; // Above bacteria
                    
                    console.log(`üí¨ Bubble position: canvas(${canvasRect.left}, ${canvasRect.top}) + bacteria(${bacteria.x}, ${bacteria.y}) = bubble(${bubbleX}, ${bubbleY})`);
                } else {
                    // Advanced fallback: Find simulation area
                    const simArea = simulationArea || document.getElementById('simulationArea') || document.querySelector('[data-simulation-area]');
                    if (simArea) {
                        const simRect = simArea.getBoundingClientRect();
                        const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                        const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                        
                        bubbleX = simRect.left + scrollX + (bacteria.x || 0) - 75;
                        bubbleY = simRect.top + scrollY + (bacteria.y || 0) - 80;
                        console.log(`üí¨ Using simulation area fallback positioning`);
                    } else {
                        // Last resort fallback
                        bubbleX = (bacteria.x || 200) + 100; // Offset from bacteria coords
                        bubbleY = (bacteria.y || 200) + 50;
                        console.warn('‚ö†Ô∏è No canvas or simulation area found, using basic positioning');
                    }
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Error calculating bubble position:', error.message);
                bubbleX = (bacteria.x || 200) + 100;
                bubbleY = (bacteria.y || 200) + 50;
            }
            
            bubble.style.position = 'fixed';
            bubble.style.left = `${bubbleX}px`;
            bubble.style.top = `${bubbleY}px`;
            bubble.style.zIndex = '9999';
            bubble.style.pointerEvents = 'none';
            
            // Add to page
            document.body.appendChild(bubble);
            
            // Auto-remove after 2 seconds with fade out
            setTimeout(() => {
                bubble.style.opacity = '0';
                bubble.style.transform = 'translateY(-10px)';
                setTimeout(() => {
                    if (bubble.parentNode) {
                        bubble.parentNode.removeChild(bubble);
                    }
                }, 300); // Wait for fade animation
            }, 2000);
            
            console.log(`üí¨ Speech bubble shown for ${bacteria.name}: ${message}`);
        }

        // ü§ù BACTERIA AUTO-COMMUNICATION SYSTEM
        
        // Auto-conversation timer
        let autoConversationInterval = null;
        
        // Start automatic bacteria conversations
        function startAutoBacteriaConversations() {
            if (autoConversationInterval) {
                clearInterval(autoConversationInterval);
            }
            
            // Every 2-4 seconds, bacteria might talk to each other (MUCH MORE FREQUENT)
            autoConversationInterval = setInterval(() => {
                if (bacteriaList.length >= 2 && simulationRunning) {
                    // 70% chance of conversation (VERY HIGH CHANCE)
                    if (Math.random() < 0.7) {
                        initiateBacteriaConversation();
                    }
                }
            }, Math.random() * 2000 + 2000); // 2-4 seconds (MUCH FASTER)
            
            console.log('ü§ù Auto-bacteria conversations started - FREQUENT MODE');
        }
        
        // Stop automatic conversations
        function stopAutoBacteriaConversations() {
            if (autoConversationInterval) {
                clearInterval(autoConversationInterval);
                autoConversationInterval = null;
                console.log('ü§ù Auto-bacteria conversations stopped');
            }
        }
        
        // Initiate conversation between bacteria
        function initiateBacteriaConversation() {
            // Find bacteria with moderate consciousness (>20%) - LOWERED THRESHOLD
            const consciousBacteria = bacteriaList.filter(b => {
                const consciousness = b.consciousness || b.consciousness_level || 0;
                return consciousness > 0.2; // LOWERED FROM 0.4 to 0.2
            });
            
            if (consciousBacteria.length < 2) return;
            
            // Pick two random bacteria
            const bacteria1 = consciousBacteria[Math.floor(Math.random() * consciousBacteria.length)];
            let bacteria2 = consciousBacteria[Math.floor(Math.random() * consciousBacteria.length)];
            
            // Make sure they're different
            while (bacteria2 === bacteria1 && consciousBacteria.length > 1) {
                bacteria2 = consciousBacteria[Math.floor(Math.random() * consciousBacteria.length)];
            }
            
            if (bacteria1 === bacteria2) return;
            
            // Check if they're close enough to talk (proximity-based communication)
            const distance = Math.hypot(bacteria1.x - bacteria2.x, bacteria1.y - bacteria2.y);
            const maxTalkDistance = 150; // Maximum distance to communicate
            
            if (distance > maxTalkDistance) return;
            
            // Generate conversation
            generateBacteriaToBacteriaConversation(bacteria1, bacteria2);
        }
        
        // Generate conversation between two bacteria
        async function generateBacteriaToBacteriaConversation(speaker, listener) {
            try {
                // Conversation topics based on bacteria state
                const topics = [
                    "food", "space", "growth", "friendship", "fear", "curiosity", 
                    "energy", "movement", "territory", "cooperation", "learning"
                ];
                
                const topic = topics[Math.floor(Math.random() * topics.length)];
                const speakerPersonality = speaker.personality || { optimism: 0.5, sociability: 0.5 };
                const listenerPersonality = listener.personality || { optimism: 0.5, sociability: 0.5 };
                
                // Generate message based on consciousness and personality
                let message;
                const speakerConsciousness = speaker.consciousness || speaker.consciousness_level || 0;
                
                if (speakerConsciousness > 0.8) {
                    // High consciousness - philosophical
                    const philosophicalMessages = [
                        `Varolu≈üumuzun anlamƒ± nedir, ${listener.name}?`,
                        `Bu evrende yalnƒ±z mƒ±yƒ±z?`,
                        `B√ºy√ºmek her zaman iyi midir?`,
                        `Arkada≈ülƒ±k nedir?`
                    ];
                    message = philosophicalMessages[Math.floor(Math.random() * philosophicalMessages.length)];
                } else if (speakerConsciousness > 0.6) {
                    // Medium consciousness - social
                    const socialMessages = [
                        `Merhaba ${listener.name}, nasƒ±lsƒ±n?`,
                        `Bu b√∂lgede yemek var mƒ±?`,
                        `Beraber hareket edelim mi?`,
                        `Bug√ºn kendimi b√ºy√ºk hissediyorum!`
                    ];
                    message = socialMessages[Math.floor(Math.random() * socialMessages.length)];
                } else {
                    // Low consciousness - basic needs
                    const basicMessages = [
                        "A√ßƒ±m...",
                        "Yardƒ±m...",
                        "Korku...",
                        "B√ºy√ºmek istiyorum"
                    ];
                    message = basicMessages[Math.floor(Math.random() * basicMessages.length)];
                }
                
                // Show speech bubble
                showSpeechBubble(speaker, message);
                
                // Update speaker's last spoken time
                speaker.lastSpoken = Date.now();
                
                // Add to chat history
                const chatBubble = document.createElement('div');
                chatBubble.className = 'bg-purple-700 text-white p-2 rounded mb-2 text-sm';
                chatBubble.innerHTML = `
                    <strong>${speaker.name}</strong> ‚Üí <strong>${listener.name}:</strong><br/>
                    ${message}
                    <div class="text-xs opacity-75 mt-1">ü§ù Bacteria conversation</div>
                `;
                
                // Add to main chat
                if (chatMessagesDiv) {
                    chatMessagesDiv.insertBefore(chatBubble, chatMessagesDiv.firstChild);
                    // Keep only last 50 messages
                    while (chatMessagesDiv.children.length > 50) {
                        chatMessagesDiv.removeChild(chatMessagesDiv.lastChild);
                    }
                }
                
                // Track in word diversity system
                if (window.persistentLearning) {
                    window.persistentLearning.trackSpeech(speaker, message);
                }
                
                // Listener might respond (20% chance) - REDUCED FROM 30%
                if (Math.random() < 0.2 && listenerPersonality.sociability > 0.3) {
                    setTimeout(() => {
                        generateListenerResponse(listener, speaker, message);
                    }, 1500 + Math.random() * 3000); // 1.5-4.5 seconds delay
                }
                
                console.log(`ü§ù Bacteria conversation: ${speaker.name} ‚Üí ${listener.name}: "${message}"`);
                
            } catch (error) {
                console.error('‚ùå Error in bacteria conversation:', error);
            }
        }
        
        // Generate listener response
        function generateListenerResponse(responder, originalSpeaker, originalMessage) {
            const personality = responder.personality || { optimism: 0.5, sociability: 0.5 };
            
            let response;
            if (personality.optimism > 0.7) {
                const positiveResponses = [
                    "Evet, haklƒ±sƒ±n!",
                    "Ne g√ºzel bir d√º≈ü√ºnce!",
                    "Benimle konu≈ütuƒüun i√ßin te≈üekk√ºrler!",
                    "Beraber ba≈üarabiliriz!"
                ];
                response = positiveResponses[Math.floor(Math.random() * positiveResponses.length)];
            } else if (personality.optimism < 0.3) {
                const negativeResponses = [
                    "Bilmiyorum...",
                    "Korkuyorum",
                    "Emin deƒüilim",
                    "Belki..."
                ];
                response = negativeResponses[Math.floor(Math.random() * negativeResponses.length)];
            } else {
                const neutralResponses = [
                    "Anlƒ±yorum",
                    "ƒ∞lgin√ß",
                    "D√º≈ü√ºnmeliyim",
                    "Haklƒ± olabilirsin"
                ];
                response = neutralResponses[Math.floor(Math.random() * neutralResponses.length)];
            }
            
            // Show response bubble
            showSpeechBubble(responder, response);
            
            // Update last spoken time
            responder.lastSpoken = Date.now();
            
            console.log(`ü§ù Bacteria response: ${responder.name} ‚Üí ${originalSpeaker.name}: "${response}"`);
        }
        
        // üí¨ SEPARATED CHAT SYSTEM
        
        // Send message to all bacteria (GROUP CHAT)
        async function sendMessageToAllBacteria(message) {
            console.log(`üì¢ GROUP CHAT: User ‚Üí All bacteria: "${message}"`);
            
            // Add user message to group chat
            const userChatBubble = document.createElement('div');
            userChatBubble.className = 'bg-teal-600 text-white p-2 rounded mb-2 text-sm';
            userChatBubble.innerHTML = `
                <strong>Sen:</strong> ${message}
                <div class="text-xs opacity-75 mt-1">üì¢ Group message to ${bacteriaList.length} bacteria</div>
            `;
            
            if (chatMessagesDiv) {
                chatMessagesDiv.insertBefore(userChatBubble, chatMessagesDiv.firstChild);
            }
            
            // All bacteria receive and might respond
            const responseBacteria = bacteriaList.filter(b => b.consciousness > 0.3);
            
            for (const bacteria of responseBacteria) {
                // 50% chance each bacteria responds to group message
                if (Math.random() < 0.5) {
                    setTimeout(async () => {
                        const response = await generateBacteriaResponse(bacteria, message, 'group');
                        
                        // Show speech bubble over bacteria
                        showSpeechBubble(bacteria, response);
                        
                        // Add to group chat
                        const bacteriaChatBubble = document.createElement('div');
                        bacteriaChatBubble.className = 'bg-green-600 text-white p-2 rounded mb-2 text-sm';
                        bacteriaChatBubble.innerHTML = `
                            <strong>${bacteria.name}:</strong> ${response}
                            <div class="text-xs opacity-75 mt-1">üß¨ Consciousness: ${(bacteria.consciousness * 100).toFixed(0)}%</div>
                        `;
                        
                        if (chatMessagesDiv) {
                            chatMessagesDiv.insertBefore(bacteriaChatBubble, chatMessagesDiv.firstChild);
                        }
                        
                        // Track for learning
                        if (window.persistentLearning) {
                            window.persistentLearning.trackSpeech(bacteria, response);
                        }
                        
                    }, Math.random() * 3000 + 500); // Random 0.5-3.5s delay
                }
            }
        }
        
        // Send message to individual bacteria (INDIVIDUAL CHAT)
        async function sendMessageToIndividualBacteria(bacteria, message) {
            console.log(`üí¨ INDIVIDUAL CHAT: User ‚Üí ${bacteria.name}: "${message}"`);
            
            // Add user message to individual chat
            const userChatBubble = document.createElement('div');
            userChatBubble.className = 'bg-blue-600 text-white p-2 rounded mb-2 text-sm';
            userChatBubble.innerHTML = `
                <strong>Sen ‚Üí ${bacteria.name}:</strong> ${message}
                <div class="text-xs opacity-75 mt-1">üí¨ Individual conversation</div>
            `;
            
            if (chatMessagesDiv) {
                chatMessagesDiv.insertBefore(userChatBubble, chatMessagesDiv.firstChild);
            }
            
            // Generate bacteria response
            setTimeout(async () => {
                const response = await generateBacteriaResponse(bacteria, message, 'individual');
                
                // Show speech bubble over bacteria
                showSpeechBubble(bacteria, response);
                
                // Add bacteria response to chat
                const bacteriaChatBubble = document.createElement('div');
                bacteriaChatBubble.className = 'bg-purple-600 text-white p-2 rounded mb-2 text-sm';
                bacteriaChatBubble.innerHTML = `
                    <strong>${bacteria.name} ‚Üí Sen:</strong> ${response}
                    <div class="text-xs opacity-75 mt-1">
                        üß¨ Consciousness: ${((bacteria.consciousness || bacteria.consciousness_level || 0) * 100).toFixed(0)}% | 
                        üíù Mood: ${bacteria.personality?.optimism > 0.7 ? 'Happy' : bacteria.personality?.optimism < 0.3 ? 'Sad' : 'Neutral'}
                    </div>
                `;
                
                if (chatMessagesDiv) {
                    chatMessagesDiv.insertBefore(bacteriaChatBubble, chatMessagesDiv.firstChild);
                }
                
                // Track for learning
                if (window.persistentLearning) {
                    window.persistentLearning.trackSpeech(bacteria, response);
                }
                
                // Update bacteria's last spoken time
                bacteria.lastSpoken = Date.now();
                
            }, Math.random() * 2000 + 500); // Random 0.5-2.5s delay
        }
        
        // Generate bacteria response based on context
        async function generateBacteriaResponse(bacteria, userMessage, chatType) {
            const consciousness = bacteria.consciousness || bacteria.consciousness_level || 0;
            const personality = bacteria.personality || { optimism: 0.5, sociability: 0.5 };
            
            let response;
            
            if (consciousness > 0.8) {
                // High consciousness - thoughtful responses
                const thoughtfulResponses = [
                    `Bu konuda d√º≈ü√ºnm√º≈üt√ºm. ${userMessage.includes('?') ? 'Cevabƒ±m karma≈üƒ±k...' : 'Fikrimi payla≈üayƒ±m.'}`,
                    `Anlƒ±yorum. ${chatType === 'individual' ? 'Seninle konu≈ümak g√ºzel.' : 'Herkesle payla≈ümaya deƒüer.'}`,
                    `ƒ∞lgin√ß perspektif. Ben ${personality.optimism > 0.6 ? 'umutluyum' : 'temkinliyim'}.`,
                    `Varolu≈üsal olarak bakarsak, ${userMessage.toLowerCase().includes('neden') ? 'sebepleri derin' : 'her ≈üeyin bir anlamƒ± var'}.`
                ];
                response = thoughtfulResponses[Math.floor(Math.random() * thoughtfulResponses.length)];
            } else if (consciousness > 0.5) {
                // Medium consciousness - social responses  
                const socialResponses = [
                    `${personality.sociability > 0.6 ? 'Evet, katƒ±lƒ±yorum!' : 'Belki haklƒ±sƒ±n.'}`,
                    `${chatType === 'group' ? 'Herkesi dinliyorum.' : 'Seninle konu≈ümak ho≈ü.'}`,
                    `${personality.optimism > 0.7 ? 'Bu g√ºzel!' : personality.optimism < 0.3 ? 'Biraz endi≈üeliyim...' : 'Anladƒ±m.'}`,
                    `B√ºy√ºrken ${userMessage.toLowerCase().includes('√∂ƒüren') ? '√ßok ≈üey √∂ƒüreniyorum' : 'deneyimlerim artƒ±yor'}.`
                ];
                response = socialResponses[Math.floor(Math.random() * socialResponses.length)];
            } else {
                // Low consciousness - basic responses
                const basicResponses = [
                    "Evet...",
                    "A√ßƒ±m...",
                    "B√ºy√ºmek istiyorum.",
                    `${personality.optimism < 0.4 ? 'Korkuyorum...' : 'Tamam.'}`,
                    "Yardƒ±m..."
                ];
                response = basicResponses[Math.floor(Math.random() * basicResponses.length)];
            }
            
            return response;
        }
        
        // üîß Debug System Status
        function debugSystemStatus() {
            console.log('üîß DEBUGGING SYSTEM STATUS...');
            
            let debugInfo = 'üîß SYSTEM DEBUG INFO:\n\n';
            
            // Check bacteria
            debugInfo += `üß¨ Bacteria Count: ${bacteriaList.length}\n`;
            debugInfo += `üìä Bacteria with consciousness >50%: ${bacteriaList.filter(b => b.consciousness > 0.5).length}\n`;
            debugInfo += `ü§ù Auto conversation running: ${autoConversationInterval !== null}\n`;
            debugInfo += `üì° Simulation running: ${simulationRunning}\n`;
            debugInfo += `üß¨ Conscious bacteria count (>20%): ${bacteriaList.filter(b => (b.consciousness || b.consciousness_level || 0) > 0.2).length}\n`;
            debugInfo += `üéØ High conscious bacteria (>40%): ${bacteriaList.filter(b => (b.consciousness || b.consciousness_level || 0) > 0.4).length}\n\n`;
            
            // Check system components
            debugInfo += `üîß SYSTEM COMPONENTS:\n`;
            debugInfo += `‚Ä¢ systemFullyReady: ${!!window.systemFullyReady}\n`;
            debugInfo += `‚Ä¢ enhancedMorphGenerator: ${!!window.enhancedMorphGenerator}\n`;
            debugInfo += `‚Ä¢ languageEvolutionEngine: ${!!window.languageEvolutionEngine}\n`;
            debugInfo += `‚Ä¢ persistentLearning: ${!!window.persistentLearning}\n`;
            debugInfo += `‚Ä¢ learningEngine: ${!!learningEngine}\n\n`;
            
            // Test morphological system
            debugInfo += `üìö MORPHOLOGICAL SYSTEM:\n`;
            if (window.enhancedMorphGenerator) {
                try {
                    const morphStatus = window.enhancedMorphGenerator.getSystemStatus ? 
                        window.enhancedMorphGenerator.getSystemStatus() : 'No status method';
                    debugInfo += `‚Ä¢ Status: ${JSON.stringify(morphStatus)}\n`;
                } catch (e) {
                    debugInfo += `‚Ä¢ Error: ${e.message}\n`;
                }
            } else {
                debugInfo += `‚Ä¢ Not loaded yet\n`;
            }
            
            debugInfo += `\nüíæ PERSISTENT LEARNING:\n`;
            if (window.persistentLearning && window.persistentLearning.isReady) {
                const stats = window.persistentLearning.getLearningStats();
                debugInfo += `‚Ä¢ Total Interactions: ${stats.totalInteractions}\n`;
                debugInfo += `‚Ä¢ Vocabulary Size: ${stats.vocabularySize}\n`;
            } else {
                debugInfo += `‚Ä¢ Not ready yet\n`;
            }
            
            // Check if bacteria have spoken
            debugInfo += `\nüó£Ô∏è RECENT BACTERIA ACTIVITY:\n`;
            const recentlySpoken = bacteriaList.filter(b => b.lastSpoken && (Date.now() - b.lastSpoken) < 60000);
            debugInfo += `‚Ä¢ Recently spoken bacteria: ${recentlySpoken.length}\n`;
            
            if (bacteriaList.length > 0) {
                const firstBacteria = bacteriaList[0];
                const consciousness = firstBacteria.consciousness || firstBacteria.consciousness_level || 0;
                debugInfo += `‚Ä¢ Sample bacteria consciousness: ${consciousness.toFixed(2)}\n`;
                debugInfo += `‚Ä¢ Sample bacteria vocabulary size: ${firstBacteria.vocabulary ? firstBacteria.vocabulary.size : 'No vocabulary'}\n`;
            }
            
            alert(debugInfo);
            console.log('üîß Debug Info:', debugInfo);
        }
        
        // üß™ TEST CONVERSATION SYSTEM
        function testBacteriaConversation() {
            console.log('üß™ TESTING BACTERIA CONVERSATION SYSTEM...');
            
            if (bacteriaList.length < 2) {
                alert('‚ùå Need at least 2 bacteria for conversation test');
                return;
            }
            
            // Force a conversation between first two bacteria
            const bacteria1 = bacteriaList[0];
            const bacteria2 = bacteriaList[1];
            
            console.log(`üß™ Testing conversation: ${bacteria1.name} ‚Üí ${bacteria2.name}`);
            const consciousness1 = (bacteria1.consciousness || bacteria1.consciousness_level || 0) * 100;
            const consciousness2 = (bacteria2.consciousness || bacteria2.consciousness_level || 0) * 100;
            console.log(`Consciousness: ${bacteria1.name}=${consciousness1.toFixed(0)}%, ${bacteria2.name}=${consciousness2.toFixed(0)}%`);
            
            // Force generate conversation
            generateBacteriaToBacteriaConversation(bacteria1, bacteria2);
            
            // Test user message to bacteria
            setTimeout(() => {
                console.log('üß™ Testing user ‚Üí bacteria conversation');
                sendMessageToIndividualBacteria(bacteria1, 'Test message: Nasƒ±lsƒ±n?');
            }, 2000);
            
            alert('üß™ Conversation test started! Check console and watch for speech bubbles.');
        }
        
        // üöÄ FORCE AUTO CONVERSATIONS
        function forceStartAutoConversations() {
            console.log('üöÄ FORCING AUTO CONVERSATIONS TO START...');
            
            // Stop any existing interval
            stopAutoBacteriaConversations();
            
            // Set simulation running if not already
            if (!simulationRunning) {
                simulationRunning = true;
                console.log('üéØ Simulation set to running');
            }
            
            // Start auto conversations
            startAutoBacteriaConversations();
            
            // Immediately trigger a conversation for testing
            setTimeout(() => {
                if (bacteriaList.length >= 2) {
                    console.log('üß™ Forcing immediate conversation...');
                    initiateBacteriaConversation();
                } else {
                    console.warn('‚ö†Ô∏è Not enough bacteria for conversation');
                }
            }, 1000);
            
            alert(`üöÄ Auto conversations FORCED to start! 
Simulation running: ${simulationRunning}
Bacteria count: ${bacteriaList.length}
Conscious bacteria: ${bacteriaList.filter(b => (b.consciousness || b.consciousness_level || 0) > 0.4).length}`);
        }

        // üöÄ MAIN INITIALIZATION - EVENT DRIVEN
        async function mainInitialize() {
            console.log('üöÄ mnBac v9.6.2 - System Readiness & GitHub Pages Fix - Final Initialization Complete!');
            
            // 1. Setup event listeners first
            initializeEventListeners();
            initializeEventDelegation();
            
            // 2. Basic setup
            updateBuildInfo(); // Initial state
            initializeCanvasSystem();
            initializeBacteriaPopulation();
            
            // 3. Initialize core systems (PROMISE-BASED ORDER)
            try {
                // DB first (others depend on it)
                persistentDB = new PersistentBacteriaDB();
                await persistentDB.initialize();
                console.log('‚úÖ Database initialization complete');
                
                // AI systems parallel (they don't depend on each other)
                const tabPFNAdapter = new TabPFNAdapter();
                realAI = new RealAITrainingSystem(); // Use global realAI variable
                
                // Initialize Learning Engine
                if (!learningEngine) {
                    learningEngine = new SystemLearningEngine();
                    console.log('‚úÖ AI Learning Engine initialized');
                }
                
                await Promise.all([
                    tabPFNAdapter.initialize(),
                    realAI.initialize()
                ]);
                console.log('‚úÖ AI systems initialization complete');
                
                // Emit final event
                appEvents.emit('all:systems:ready');
                
                // 4. Load saved data if available
                await autoRestoreFromDatabase();
                
                // 5. Start simulation manager
                simulationManager = new SimulationManager();
                
                // 6. üé≠ Initialize Advanced Comedy Culture System
                setTimeout(() => {
                    if (typeof tabpfnVocabularySystem !== 'undefined' && tabpfnVocabularySystem) {
                        jokeMasterInstance = new JokeMaster(tabpfnVocabularySystem);
                        console.log('üé≠ JokeMaster initialized with TabPFN integration');
                    } else {
                        jokeMasterInstance = new JokeMaster(null);
                        console.log('üé≠ JokeMaster initialized without TabPFN integration');
                    }
                }, 3000); // Wait for TabPFN to be ready
                
                // 7. üß¨ Initialize Dynamic Language Evolution System
                setTimeout(() => {
                    languageEvolutionEngine = new LanguageEvolutionEngine();
                    console.log('üß¨ Language Evolution Engine initialized - bacterial languages will now evolve!');
                }, 4000); // Wait for other systems to be ready
                
                // 8. üî§ Initialize Enhanced Morphological System (Phase 2.7) - SAFE MODE
                setTimeout(async () => {
                    try {
                        console.log('üî§ Attempting to initialize Enhanced Morphological System...');
                        
                        // Check if external scripts exist before loading
                        const scriptPaths = [
                            './src/engine/AITrainingAdapter.js',
                            './src/engine/EnhancedMorphologicalGenerator.js', 
                            './src/engine/MorphologicalDialogueGenerator.js',
                            './src/engine/PersistentLearningEngine.js'
                        ];
                        
                        let scriptsLoaded = 0;
                        
                        // Try to load each script safely
                        for (const scriptPath of scriptPaths) {
                            try {
                                if (typeof loadScript === 'function') {
                                    await loadScript(scriptPath);
                                    scriptsLoaded++;
                                    console.log(`‚úÖ Loaded: ${scriptPath}`);
                                } else {
                                    console.warn(`‚ö†Ô∏è loadScript function not available`);
                                    break;
                                }
                            } catch (scriptError) {
                                console.warn(`‚ö†Ô∏è Could not load ${scriptPath}:`, scriptError.message);
                            }
                        }
                        
                        if (scriptsLoaded === scriptPaths.length) {
                            // Only initialize if all scripts loaded successfully
                            if (typeof AITrainingAdapter !== 'undefined') {
                                window.aiTrainingAdapter = new AITrainingAdapter();
                                console.log('‚úÖ AITrainingAdapter initialized');
                            }
                            
                            if (typeof EnhancedMorphologicalGenerator !== 'undefined' && window.aiTrainingAdapter) {
                                window.enhancedMorphGenerator = new EnhancedMorphologicalGenerator(window.aiTrainingAdapter);
                                console.log('‚úÖ EnhancedMorphologicalGenerator initialized');
                            }
                            
                            // Try dynamic import for PersistentLearningEngine
                            try {
                                const { PersistentLearningEngine } = await import('./src/engine/PersistentLearningEngine.js');
                                window.persistentLearning = new PersistentLearningEngine();
                                console.log('‚úÖ PersistentLearningEngine initialized');
                            } catch (importError) {
                                console.warn('‚ö†Ô∏è PersistentLearningEngine dynamic import failed:', importError.message);
                                // Create a minimal fallback
                                window.persistentLearning = {
                                    isReady: true,
                                    trackSpeech: (bacteria, message) => {
                                        console.log(`üìù Speech tracked: ${bacteria.name}: ${message}`);
                                    },
                                    getLearningStats: () => ({
                                        totalInteractions: 0,
                                        vocabularySize: 0
                                    }),
                                    metrics: { totalInteractions: 0 }
                                };
                                console.log('‚úÖ Fallback PersistentLearning created');
                            }
                            
                            console.log('üî§ Enhanced Morphological System initialized successfully!');
                        } else {
                            console.warn('‚ö†Ô∏è Some morphological scripts failed to load, using basic fallbacks');
                            
                            // Create basic fallback systems
                            window.persistentLearning = {
                                isReady: true,
                                trackSpeech: (bacteria, message) => {
                                    console.log(`üìù [Fallback] Speech tracked: ${bacteria.name}: ${message}`);
                                },
                                getLearningStats: () => ({
                                    totalInteractions: 0,
                                    vocabularySize: 0
                                }),
                                metrics: { totalInteractions: 0 }
                            };
                            
                            window.enhancedMorphGenerator = {
                                getSystemStatus: () => ({ status: 'fallback', ready: true })
                            };
                            
                            console.log('‚úÖ Fallback morphological systems created');
                        }
                        
                        // Mark system as ready regardless
                        window.systemFullyReady = true;
                        
                        // Update UI
                        const loadingIndicators = document.querySelectorAll('.loading-indicator');
                        loadingIndicators.forEach(indicator => {
                            indicator.style.display = 'none';
                        });
                        
                        // Emit events
                        appEvents.emit('morphological:system:ready');
                        appEvents.emit('persistent:learning:ready');
                        appEvents.emit('system:fully:ready');
                        
                        console.log('üéâ mnBac v9.6.2 FULLY LOADED - All systems operational!');
                        
                    } catch (error) {
                        console.error('‚ùå Enhanced Morphological System initialization failed:', error);
                        
                        // Create emergency fallbacks
                        window.persistentLearning = {
                            isReady: true,
                            trackSpeech: () => {},
                            getLearningStats: () => ({ totalInteractions: 0, vocabularySize: 0 }),
                            metrics: { totalInteractions: 0 }
                        };
                        window.systemFullyReady = true;
                        console.log('üö® Emergency fallback systems activated');
                    }
                }, 5000); // Wait for all other systems to be ready
                
                console.log('üéâ Event-driven initialization complete!');
                
            } catch (error) {
                console.error('‚ùå Initialization error:', error);
                updateBuildInfo(); // Show error state
            }
        }

        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', mainInitialize);

    </script>
</body>
</html>