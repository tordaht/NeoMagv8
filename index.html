<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mnBac v9.6.2 - System Readiness & GitHub Pages Fix</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Note: Tailwind CDN is used for rapid prototyping. For production, use PostCSS or CLI installation -->
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <style>
        /* CSS Variables for better maintainability */
        :root {
            --color-primary: #3D5AFE;
            --color-secondary: #00C853;
            --color-accent: #FFC107;
            --color-bg-dark: #121212;
            --color-bg-panel: #1E1E1E;
            --color-text-light: #E0E0E0;
            --color-text-muted: #B0B0B0;
            --color-border: #333;
            --radius-lg: 12px;
            --radius-sm: 6px;
            --transition-fast: 0.2s ease;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .bacteria {
            transition: all 0.5s ease-in-out;
            cursor: pointer;
        }
        .bacteria:hover {
            transform: scale(1.1);
        }
        .chat-bubble {
            max-width: 70%;
            word-wrap: break-word;
        }
        .chat-bubble-user {
            background-color: #3b82f6; /* blue-500 */
            color: white;
        }
        .chat-bubble-bacteria {
            background-color: #e5e7eb; /* gray-200 */
            color: #1f2937; /* gray-800 */
        }
        .smooth-scroll {
            scroll-behavior: smooth;
        }
        /* Custom scrollbar for chat */
        #chatMessages::-webkit-scrollbar {
            width: 8px;
        }
        #chatMessages::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #chatMessages::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        #chatMessages::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Loading spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 5px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
            
        /* ğŸ­ TabPFN Speech Bubble Animations */
        @keyframes speechBubbleAnim {
            0% { 
                transform: scale(0.8) translateY(10px); 
                opacity: 0; 
            }
            15% { 
                transform: scale(1.05) translateY(-5px); 
                opacity: 1; 
            }
            20% { 
                transform: scale(1) translateY(0px); 
                opacity: 1; 
            }
            80% { 
                transform: scale(1) translateY(0px); 
                opacity: 1; 
            }
            100% { 
                transform: scale(0.9) translateY(-10px); 
                opacity: 0; 
            }
        }

        /* ğŸ’¬ SPEECH BUBBLE SYSTEM - Modern Design */
        .speech-bubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 16px;
            border-radius: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            min-width: 150px;
            max-width: 300px;
            word-wrap: break-word;
            opacity: 0.95;
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .speech-bubble:hover {
            transform: scale(1.02) translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.4);
            opacity: 1;
        }

        .speech-content {
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
            line-height: 1.4;
        }

        .speech-content strong {
            color: #FFD700;
            font-weight: 600;
            font-size: 13px;
        }

        /* Speech bubble arrow pointing down */
        .speech-arrow {
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-top: 12px solid #667eea;
            filter: drop-shadow(0 3px 6px rgba(0,0,0,0.2));
        }

        /* Context-specific bubble styles */
        .speech-food_seeking {
            border-left: 4px solid #FFD700;
        }

        .speech-social_interaction {
            border-left: 4px solid #00FFFF;
        }

        .speech-philosophical {
            border-left: 4px solid #FF4500;
            font-style: italic;
        }

        .speech-learning {
            border-left: 4px solid #32CD32;
        }

        </style>
    </head>
<body class="bg-gray-900 text-gray-100 flex flex-col min-h-screen">

    <!-- Header -->
    <header class="bg-gray-800 shadow-lg p-4 sticky top-0 z-50">
        <div class="flex justify-between items-center">
            <h1 class="text-2xl font-bold text-teal-400">ğŸ§¬ mnBac v9.6.2 - System Readiness & GitHub Pages Fix</h1>
            <div class="flex gap-2 text-xs">
                <div class="bg-green-600 text-white px-2 py-1 rounded" id="fpsDisplay">FPS: --</div>
                <div class="bg-blue-600 text-white px-2 py-1 rounded" id="bacteriaCount">Bakteri: 0</div>
                <div class="bg-purple-600 text-white px-2 py-1 rounded" id="dayDisplay">GÃ¼n: 0</div>
            </div>
        </div>
        <div class="text-center text-xs text-teal-300 mt-1">
            ğŸ“± Mobile Ready TabPFN | ğŸ¯ Smart Word Usage | âš¡ < 1 Second Predictions | ğŸ§  Single HTML Solution
        </div>
        <div id="buildInfo" class="text-center text-xs text-gray-400 mt-1">
            Build: Loading...
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow container mx-auto p-2 sm:p-4 grid grid-cols-1 lg:grid-cols-3 gap-4">
        
        <!-- Sol Panel SimÃ¼lasyon ve Detaylar -->
        <div class="lg:col-span-2 bg-gray-800 p-4 rounded-lg shadow-xl flex flex-col">
            <h2 class="text-xl font-semibold mb-3 text-teal-300 border-b border-gray-700 pb-2">SimÃ¼lasyon AlanÄ±</h2>
            <div id="simulationArea" class="bg-gray-700 rounded-md p-4 relative h-[400px] w-full overflow-hidden cursor-crosshair border-2 border-gray-600">
                <!-- Canvas akan buraya eklendi -->
                <canvas id="simCanvas" class="w-full h-full absolute top-0 left-0"></canvas>
                <div class="absolute top-2 left-2 text-xs text-teal-300 bg-gray-800 bg-opacity-75 px-2 py-1 rounded">
                    ğŸ Yemek eklemek iÃ§in tÄ±klayÄ±n | ğŸ§¬ Bakteriler iÃ§in tÄ±klayÄ±n
                </div>
                <div class="absolute top-2 right-2 text-xs text-blue-300 bg-gray-800 bg-opacity-75 px-2 py-1 rounded">
                    âš—ï¸ MolekÃ¼ler Dinamik SimÃ¼lasyonu | FPS: <span id="canvasFpsDisplay">--</span>
                </div>
            </div>
            <div class="mt-4 p-3 bg-gray-750 rounded-md">
                <h3 class="text-lg font-semibold mb-2 text-teal-300">Kontrol Paneli</h3>
                <div class="flex space-x-2">
                    <!-- ESKÄ° BUTTONLAR KALDIRILDI - YENÄ° EVENT DElEGATÄ°ON SÄ°STEMÄ° KULLANILIYOR -->
                    <p class="text-sm text-gray-400">Kontrol butonlarÄ± aÅŸaÄŸÄ±da â¬‡ï¸</p>
                </div>
                <p id="simulationTime" class="mt-2 text-sm text-gray-400">SimÃ¼lasyon ZamanÄ±: 0 gÃ¼n</p>
            </div>
            <div id="bacteriaDetails" class="mt-4 p-3 bg-gray-750 rounded-md hidden">
                <h3 class="text-lg font-semibold mb-2 text-teal-300" id="detailsHeader">Bakteri DetaylarÄ±</h3>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 text-sm">
                    <p><strong>ID:</strong> <span id="bacteriaId" class="text-gray-300"></span></p>
                    <p><strong>Ä°sim:</strong> <span id="bacteriaName" class="text-gray-300"></span></p>
                    <p><strong>Boyut:</strong> <span id="bacteriaSize" class="text-gray-300"></span> Âµm</p>
                    <p><strong>YaÅŸ:</strong> <span id="bacteriaAge" class="text-gray-300"></span> gÃ¼n</p>
                    <p><strong>BÃ¼yÃ¼me HÄ±zÄ±:</strong> <span id="bacteriaGrowthRate" class="text-gray-300"></span></p>
                    <p><strong>BilinÃ§ Seviyesi:</strong> <span id="bacteriaConsciousness" class="text-gray-300"></span></p>
                    <p><strong>KiÅŸilik (Ä°yimserlik):</strong> <span id="bacteriaOptimism" class="text-gray-300"></span></p>
                    <p><strong>KiÅŸilik (Sosyallik):</strong> <span id="bacteriaSociability" class="text-gray-300"></span></p>
                    <p><strong>Dil AÅŸamasÄ±:</strong> <span id="bacteriaLanguageStage" class="text-gray-300"></span></p>
                    <p><strong>Kelime Haznesi:</strong> <span id="bacteriaVocabulary" class="text-gray-300 break-all"></span></p>
                </div>
            </div>
        </div>

        <!-- SaÄŸ Panel Sohbet -->
        <div class="bg-gray-800 p-4 rounded-lg shadow-xl flex flex-col max-h-[80vh] lg:max-h-full">
            <h2 class="text-xl font-semibold mb-3 text-teal-300 border-b border-gray-700 pb-2">Bakteri Sohbet Merkezi</h2>
            
            <!-- Chat Mode Selector -->
            <div class="mb-3 flex space-x-2">
                <button id="individualChatBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm transition">Tekil Sohbet</button>
                <button id="groupChatBtn" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm transition">Grup Sohbeti</button>
                <button id="startBacteriaConversationBtn" class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded text-sm transition">Bakteriler KonuÅŸsun</button>
            </div>
            
            <div id="chatInfo" class="mb-2 text-sm text-gray-400">Sohbet modunu seÃ§in.</div>
            <div id="chatMessages" class="flex-grow bg-gray-700 rounded-md p-3 overflow-y-auto mb-3 smooth-scroll space-y-2 h-64 min-h-[16rem] max-h-[20rem]" style="display: flex; flex-direction: column-reverse;">
                <!-- Sohbet mesajlarÄ± buraya eklenecek -->
            </div>
            <div id="chatLoadingIndicator" class="hidden text-center py-2">
                <div class="loader"></div>
                <p class="text-sm text-gray-400">Bakteri dÃ¼ÅŸÃ¼nÃ¼yor...</p>
            </div>
            <div class="flex">
                <input type="text" id="chatInput" class="flex-grow bg-gray-600 text-gray-200 border border-gray-500 rounded-l-lg p-2 focus:ring-teal-500 focus:border-teal-500 outline-none" placeholder="MesajÄ±nÄ±zÄ± yazÄ±n..." disabled>
                <button id="sendMessageBtn" class="bg-teal-500 hover:bg-teal-600 text-white font-bold p-2 rounded-r-lg transition duration-150 ease-in-out" disabled>GÃ¶nder</button>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-gray-800 text-center p-3 text-sm text-gray-500">
        NeoMag v8.0.0 - SimÃ¼lasyon ArayÃ¼zÃ¼ Prototipi
    </footer>

    <!-- Controls -->
    <div class="bg-gray-800 p-4 rounded-lg mb-4">
        <div class="flex flex-wrap gap-2 mb-4">
            <button id="startSimulationBtn" data-action="start-simulation" class="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-lg text-lg font-bold">
                â–¶ï¸ SimÃ¼lasyonu BaÅŸlat
            </button>
            <button data-action="pause-simulation" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded">
                â¸ï¸ Duraklat
            </button>
            <button data-action="reset-simulation" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">
                ğŸ”„ Reset
            </button>
            <button data-action="add-bacteria" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">
                â• Bakteri Ekle
            </button>
            <button data-action="toggle-group-chat" class="bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded">
                ğŸ’¬ Grup Chat
            </button>
        </div>
        
        <!-- v825: Database Controls -->
        <div class="flex flex-wrap gap-2 mb-2">
            <button data-action="export-csv" class="bg-cyan-600 hover:bg-cyan-700 px-3 py-1 rounded text-sm">
                ğŸ“Š CSV Export
            </button>
            <button data-action="export-json" class="bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded text-sm">
                ğŸ“ˆ JSON Export
            </button>
            <button data-action="save-all" class="bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded text-sm">
                ğŸ’¾ Save All
            </button>
            <button data-action="load-saved" class="bg-teal-600 hover:bg-teal-700 px-3 py-1 rounded text-sm">
                ğŸ“– Load Saved
            </button>
            <button data-action="clear-db" class="bg-red-500 hover:bg-red-600 px-3 py-1 rounded text-sm">
                ğŸ—‘ï¸ Clear DB
            </button>
            <button data-action="show-db-stats" class="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm">
                ğŸ“ˆ DB Stats
            </button>
            <button data-action="show-learning-stats" class="bg-purple-600 hover:bg-purple-700 px-3 py-1 rounded text-sm">
                ğŸ§  AI Learning
            </button>
            <button data-action="clear-learning-db" class="bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-sm">
                ğŸ§¬ Clear Learning
            </button>
            <button data-action="show-diversity-stats" class="bg-teal-600 hover:bg-teal-700 px-3 py-1 rounded text-sm">
                ğŸ­ Word Diversity
            </button>
            <button data-action="reset-diversity" class="bg-orange-600 hover:bg-orange-700 px-3 py-1 rounded text-sm">
                ğŸ”„ Reset Diversity
            </button>
            <button data-action="show-language-stats" class="bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded text-sm">
                ğŸ§  Language Stats
            </button>
            <button data-action="peer-dialogue" class="bg-pink-600 hover:bg-pink-700 px-3 py-1 rounded text-sm">
                ğŸ—£ï¸ Peer Dialogue
            </button>
            <button data-action="debug-system" class="bg-yellow-600 hover:bg-yellow-700 px-3 py-1 rounded text-sm">
                ğŸ”§ Debug System
            </button>
            <button data-action="test-conversation" class="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-sm">
                ğŸ§ª Test Conversation
            </button>
            <button data-action="force-auto-conversation" class="bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-sm">
                ğŸš€ FORCE Auto Talk
            </button>
        </div>
        
        <div class="text-xs text-gray-300">
            ğŸ§¾ Persistent Database: Auto-save every 30s | â™¾ï¸ Unlimited Consciousness | ğŸ“Š TabPFN-ready CSV | ğŸ¨ Canvas Rendering
        </div>
    </div>

    <script>
        // DOM Elements
        const simulationArea = document.getElementById('simulationArea');
        const bacteriaDetailsDiv = document.getElementById('bacteriaDetails');
        const detailsHeader = document.getElementById('detailsHeader');
        const bacteriaIdSpan = document.getElementById('bacteriaId');
        const bacteriaNameSpan = document.getElementById('bacteriaName');
        const bacteriaSizeSpan = document.getElementById('bacteriaSize');
        const bacteriaAgeSpan = document.getElementById('bacteriaAge');
        const bacteriaGrowthRateSpan = document.getElementById('bacteriaGrowthRate');
        const bacteriaConsciousnessSpan = document.getElementById('bacteriaConsciousness');
        const bacteriaOptimismSpan = document.getElementById('bacteriaOptimism');
        const bacteriaSociabilitySpan = document.getElementById('bacteriaSociability');
        const bacteriaLanguageStageSpan = document.getElementById('bacteriaLanguageStage');
        const bacteriaVocabularySpan = document.getElementById('bacteriaVocabulary');

        const chatInfoDiv = document.getElementById('chatInfo');
        const chatMessagesDiv = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const chatLoadingIndicator = document.getElementById('chatLoadingIndicator');

        const startSimulationBtn = document.getElementById('startSimulationBtn');
        const nextStepBtn = document.getElementById('nextStepBtn');
        const resetSimulationBtn = document.getElementById('resetSimulationBtn');
        const simulationTimeSpan = document.getElementById('simulationTime');

        // Simulation State
        let bacteriaPopulation = [];
        let bacteriaList = []; // v826 compatibility
        let bacteriaIdCounter = 1; // v826 ID tracking
        let foodParticles = [];
        let selectedBacteria = null;
        let simulationRunning = false;
        let simulationDay = 0; // Global simulation day counter
        
        // Initialize persistentDB early (null safety)
        var persistentDB = null;
        
        // ğŸ¯ EVENT-DRIVEN INITIALIZATION SYSTEM
        class SimpleEventEmitter {
            constructor() {
                this.listeners = {};
            }
            
            on(event, callback) {
                if (!this.listeners[event]) {
                    this.listeners[event] = [];
                }
                this.listeners[event].push(callback);
            }
            
            emit(event, data) {
                if (this.listeners[event]) {
                    this.listeners[event].forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error(`ğŸš¨ Event callback error for '${event}':`, error);
                        }
                    });
                }
            }
            
            off(event, callback) {
                if (this.listeners[event]) {
                    this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
                }
            }
        }
        
        // Global event system
        const appEvents = new SimpleEventEmitter();
        
        // Initialize AI Learning Engine globally
        let learningEngine = null;
        
        // ğŸ§  SELF-IMPROVEMENT SYSTEM
        class SystemLearningEngine {
            constructor() {
                this.decisionLog = [];
                this.errorPatterns = new Map();
                this.successPatterns = new Map();
                this.confidenceThreshold = 0.7;
                this.maxLogSize = 1000;
                this.isLearning = true;
            }
            
            // Log AI decision with context
            logDecision(source, input, output, confidence, context = {}) {
                const logEntry = {
                    timestamp: Date.now(),
                    source, // 'tabpfn', 'tfjs', 'genetic' etc.
                    input: this.sanitizeInput(input),
                    output,
                    confidence,
                    context,
                    outcome: null // Will be filled later
                };
                
                this.decisionLog.push(logEntry);
                
                // Keep log size manageable
                if (this.decisionLog.length > this.maxLogSize) {
                    this.decisionLog.shift();
                }
                
                return logEntry;
            }
            
            // Track the outcome of a decision
            trackOutcome(logEntry, outcome, metrics = {}) {
                if (logEntry && typeof logEntry === 'object') {
                    logEntry.outcome = outcome; // 'success', 'failure', 'neutral'
                    logEntry.metrics = metrics; // age, consciousness change, survival etc.
                    
                    this.updatePatterns(logEntry);
                }
            }
            
            updatePatterns(logEntry) {
                const pattern = this.extractPattern(logEntry);
                const patternKey = JSON.stringify(pattern);
                
                if (logEntry.outcome === 'success') {
                    const current = this.successPatterns.get(patternKey) || { count: 0, confidence: 0 };
                    current.count++;
                    current.confidence = (current.confidence * (current.count - 1) + logEntry.confidence) / current.count;
                    this.successPatterns.set(patternKey, current);
                } else if (logEntry.outcome === 'failure') {
                    const current = this.errorPatterns.get(patternKey) || { count: 0, avgConfidence: 0 };
                    current.count++;
                    current.avgConfidence = (current.avgConfidence * (current.count - 1) + logEntry.confidence) / current.count;
                    this.errorPatterns.set(patternKey, current);
                }
            }
            
            extractPattern(logEntry) {
                // Extract key features that might indicate success/failure patterns
                return {
                    source: logEntry.source,
                    inputType: typeof logEntry.input,
                    confidenceRange: Math.floor(logEntry.confidence * 10) / 10,
                    contextSize: Object.keys(logEntry.context).length
                };
            }
            
            // Check if a decision might be risky based on learned patterns
            assessRisk(source, input, confidence, context = {}) {
                const pattern = {
                    source,
                    inputType: typeof input,
                    confidenceRange: Math.floor(confidence * 10) / 10,
                    contextSize: Object.keys(context).length
                };
                
                const patternKey = JSON.stringify(pattern);
                const errorPattern = this.errorPatterns.get(patternKey);
                
                if (errorPattern && errorPattern.count > 3) {
                    return {
                        isRisky: true,
                        riskLevel: Math.min(errorPattern.count / 10, 1),
                        suggestion: 'Consider using fallback or lower confidence threshold'
                    };
                }
                
                return { isRisky: false, riskLevel: 0 };
            }
            
            sanitizeInput(input) {
                // Prevent circular references and limit size
                try {
                    return JSON.parse(JSON.stringify(input));
                } catch {
                    return { type: typeof input, size: String(input).length };
                }
            }
            
            getStats() {
                return {
                    totalDecisions: this.decisionLog.length,
                    errorPatterns: this.errorPatterns.size,
                    successPatterns: this.successPatterns.size,
                    recentSuccessRate: this.calculateRecentSuccessRate()
                };
            }
            
            calculateRecentSuccessRate() {
                const recent = this.decisionLog.slice(-50); // Last 50 decisions
                const withOutcome = recent.filter(log => log.outcome);
                const successes = withOutcome.filter(log => log.outcome === 'success');
                return withOutcome.length > 0 ? successes.length / withOutcome.length : 0;
            }
        }
        
        // Global learning engine - initialization will be done in mainInitialize()
        // learningEngine is already declared as let above
        
        // ğŸ¨ CANVAS SYSTEM INITIALIZATION
        function initializeCanvasSystem() {
            const canvas = document.getElementById('simCanvas');
            if (!canvas) {
                console.warn('Canvas element not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            // ğŸ¯ STATÄ°K SIZE ATAMASI KALDIRILDI - resizeCanvas() kullanÄ±lacak
            // canvas.width ve canvas.height artÄ±k dinamik olarak ayarlanÄ±yor
            
            console.log('âœ… Canvas system initialized');
        }
        
        // ğŸ§¬ BACTERIA POPULATION INITIALIZATION
        function initializeBacteriaPopulation() {
            bacteriaPopulation = [];
            bacteriaList = [];
            
            for (let i = 0; i < CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT; i++) {
                const bacteria = new BacteriaEntity(bacteriaIdCounter, `Bakteri-${bacteriaIdCounter}`);
                bacteriaPopulation.push(bacteria);
                bacteriaList.push(bacteria); // v826 compatibility
                bacteriaIdCounter++;
            }
            
            console.log(`âœ… ${CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT} bacteria initialized`);
        }
        // Simulation State Management
        class SimulationManager {
            constructor() {
                this.isRunning = false;
                this.simulationDay = 0;
                this.lastFrameTime = 0;
                this.lastSimulationStep = 0;
                this.frameCount = 0;
                this.fpsDisplay = document.getElementById('fpsDisplay');
                this.gameLoop = this.gameLoop.bind(this);
                
                // ğŸ—£ï¸ Enhanced Peer Communication System
                this.stepCount = 0;
                this.CHAT_INTERVAL = 5; // Her 5 adÄ±mda peer chat
                this.GROUP_CHAT_INTERVAL = 15; // Her 15 adÄ±mda grup sohbeti
                this.speechBubbles = new Map(); // KonuÅŸma balonlarÄ± tracking
                
                // Mood-based vocabulary lists
                this.POSITIVE_WORDS = new Set([
                    'iyi', 'mutlu', 'hoÅŸ', 'gÃ¼zel', 'harika', 'mÃ¼kemmel', 'sevgi', 
                    'dostluk', 'neÅŸe', 'umut', 'baÅŸarÄ±', 'kazanÃ§', 'bÃ¼yÃ¼me', 'geliÅŸim'
                ]);
                
                this.NEGATIVE_WORDS = new Set([
                    'kÃ¶tÃ¼', 'Ã¼zgÃ¼n', 'berbat', 'korkunÃ§', 'baÅŸarÄ±sÄ±z', 'kayÄ±p', 
                    'aÄŸrÄ±', 'acÄ±', 'kÄ±rÄ±k', 'yalnÄ±z', 'depresif', 'karanlÄ±k'
                ]);
            }

            gameLoop(timestamp) {
                if (!this.isRunning) return;
                
                // Calculate FPS
                this.frameCount++;
                const deltaTime = timestamp - this.lastFrameTime;
                
                // Update FPS display every second with memory info
                if (deltaTime >= CONFIG.UI.FPS_UPDATE_INTERVAL) {
                    const fps = Math.round(this.frameCount / (deltaTime / 1000));
                    const memInfo = MemoryManager.getMemoryUsage();
                    const displayText = memInfo.used > 0 
                        ? `FPS: ${fps} | MEM: ${memInfo.used}MB`
                        : `FPS: ${fps}`;
                    if (this.fpsDisplay) this.fpsDisplay.textContent = displayText;
                    
                    // Header bilgilerini gÃ¼ncelle (GÃ¼n ve Bakteri SayÄ±sÄ±)
                    const dayDisplay = document.getElementById('dayDisplay');
                    const bacteriaCountDisplay = document.getElementById('bacteriaCount');
                    if (dayDisplay) dayDisplay.textContent = `GÃ¼n: ${this.simulationDay}`;
                    if (bacteriaCountDisplay) bacteriaCountDisplay.textContent = `Bakteri: ${bacteriaPopulation.length}`;
                    
                    this.frameCount = 0;
                    this.lastFrameTime = timestamp;
                }
                
                // Run simulation step at intervals
                if (timestamp - this.lastSimulationStep >= CONFIG.SIMULATION.STEP_INTERVAL) {
                    this.simulationStep();
                    this.lastSimulationStep = timestamp;
                }
                
                // Render (every frame for smooth animation)
                renderBacteria();
                
                requestAnimationFrame(this.gameLoop);
            }

            start() {
                if (this.isRunning) return;
                this.isRunning = true;
                this.lastFrameTime = performance.now();
                this.lastSimulationStep = performance.now();
                requestAnimationFrame(this.gameLoop);
                systemStatus.simulation = true;
                appEvents.emit('simulation:started');
                console.log('ğŸš€ Simulation started with requestAnimationFrame');
            }

            pause() {
                this.isRunning = false;
                systemStatus.simulation = false;
                appEvents.emit('simulation:paused');
                console.log('â¸ï¸ Simulation paused');
            }

            reset() {
                this.pause();
                this.simulationDay = 0;
                simulationDay = 0;
                bacteriaPopulation = [];
                bacteriaList = [];
                foodParticles = [];
                selectedBacteria = null;
                bacteriaIdCounter = 1;
                console.log('ğŸ”„ Simulation reset completed');
            }

            simulationStep() {
                this.simulationDay++;
                this.stepCount++; // ğŸ—£ï¸ Peer communication tracking
                simulationDay = this.simulationDay; // Global ile senkronize
                simulationTimeSpan.textContent = `SimÃ¼lasyon ZamanÄ±: ${this.simulationDay} gÃ¼n`;
                
                // Auto-generate food for sustained ecosystem
                if (Math.random() < CONFIG.SIMULATION.AUTO_FOOD_GENERATION_CHANCE) {
                    addRandomFood();
                }
                
                // ğŸ—£ï¸ Enhanced Peer Communication System
                if (bacteriaPopulation.length >= 2) {
                    // Regular peer chats
                    if (this.stepCount % this.CHAT_INTERVAL === 0) {
                        this.runPeerChats();
                    }
                    
                    // Group therapy sessions
                    if (this.stepCount % this.GROUP_CHAT_INTERVAL === 0) {
                        this.runGroupChat();
                    }
                    
                    // Support for depressed bacteria
                    this.checkDepressedBacteria();
                }
                
                bacteriaPopulation.forEach((bacteria, index) => {
                    if (!bacteria || typeof bacteria.updateDaily !== 'function') {
                        console.warn(`âš ï¸ Invalid bacteria at index ${index}, removing...`);
                        return;
                    }
                    
                    try {
                        bacteria.updateDaily();
                        bacteria.move();
                        
                        // More frequent reproduction checks for dynamic population
                        if (this.simulationDay % 2 === 0 && typeof bacteria.checkForReproduction === 'function') {
                            bacteria.checkForReproduction();
                        }
                    } catch (error) {
                        console.error(`âŒ Error in simulation step for bacteria ${bacteria.id}:`, error);
                        // Remove problematic bacteria to prevent further errors
                        bacteriaPopulation.splice(index, 1);
                    }
                });
                
                // Remove dead or invalid bacteria
                bacteriaPopulation = bacteriaPopulation.filter(bacteria => 
                    bacteria && typeof bacteria.x === 'number' && bacteria.biological_state
                );
                
                // Periodic memory cleanup (every 100 simulation steps)
                if (this.simulationDay % 100 === 0) {
                    MemoryManager.cleanup();
                }
                
                if (selectedBacteria) {
                    updateBacteriaDetails(selectedBacteria);
                }
            }
            
            // ğŸ—£ï¸ Enhanced Peer Communication Methods
            
            /**
             * Her bakteri rastgele bir eÅŸ seÃ§er ve sohbet eder
             */
            async runPeerChats() {
                const socialBacteria = bacteriaPopulation.filter(b => 
                    b.consciousness_level > 0.5 && b.personality_traits.sociability > 0.3
                );
                
                if (socialBacteria.length < 2) return;
                
                // Her bakteriye partner bul ve konuÅŸ
                for (const bacteria of socialBacteria) {
                    if (Math.random() < 0.7) { // %70 ÅŸans ile konuÅŸma
                        const partner = this.getRandomNeighbor(bacteria, socialBacteria);
                        if (partner) {
                            await this.exchangeDialog(bacteria, partner);
                        }
                    }
                }
                
                console.log(`ğŸ—£ï¸ Peer chats completed: ${socialBacteria.length} bacteria participated`);
            }
            
            /**
             * Rastgele komÅŸu bakteri seÃ§ (proximity veya random)
             */
            getRandomNeighbor(bacteria, pool = bacteriaPopulation) {
                const others = pool.filter(x => x !== bacteria);
                if (others.length === 0) return null;
                
                // YakÄ±nlÄ±k bazlÄ± seÃ§im (%30 ÅŸans)
                if (Math.random() < 0.3) {
                    const nearby = others.filter(other => {
                        const dx = bacteria.x - other.x;
                        const dy = bacteria.y - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance < 100; // 100px yakÄ±nlÄ±k
                    });
                    
                    if (nearby.length > 0) {
                        return nearby[Math.floor(Math.random() * nearby.length)];
                    }
                }
                
                // Random seÃ§im
                return others[Math.floor(Math.random() * others.length)];
            }
            
            /**
             * Ä°ki bakteri arasÄ± Ã§ift yÃ¶nlÃ¼ diyalog
             */
            async exchangeDialog(bacteriaA, bacteriaB) {
                try {
                    // A'dan B'ye mesaj
                    const contextA = this.getBacteriaContext(bacteriaA);
                    const messageA = await this.generatePeerMessage(bacteriaA, contextA);
                    
                    // B mesajÄ± Ã¶ÄŸrenir ve mood etkilenir
                    this.learnFromPeer(bacteriaB, messageA, bacteriaA);
                    this.renderSpeechBubble(bacteriaA, messageA, 3000);
                    
                    // B'den A'ya cevap (kÄ±sa gecikme)
                    setTimeout(async () => {
                        const contextB = this.getBacteriaContext(bacteriaB);
                        const messageB = await this.generatePeerMessage(bacteriaB, contextB);
                        
                        this.learnFromPeer(bacteriaA, messageB, bacteriaB);
                        this.renderSpeechBubble(bacteriaB, messageB, 3000);
                    }, 500 + Math.random() * 1000);
                    
                } catch (error) {
                    console.warn('âš ï¸ Peer dialog failed:', error);
                }
            }
            
            /**
             * Bakterinin mevcut context'ini belirle
             */
                         getBacteriaContext(bacteria) {
                 // Mood'a gÃ¶re context seÃ§ (personality_traits.mood kullan)
                 if (bacteria.personality_traits.mood < 0.3) return 'sad';
                 if (bacteria.personality_traits.mood > 0.7) return 'happy';
                 if (bacteria.energy && bacteria.energy < 0.3) return 'hungry';
                 if (bacteria.biological_state.energy < 0.3) return 'hungry';
                 if (bacteria.consciousness_level > 2.0) return 'philosophical';
                 if (bacteria.personality_traits.sociability > 0.7) return 'social';
                 
                 const contexts = ['general', 'friendly', 'curious', 'learning'];
                 return contexts[Math.floor(Math.random() * contexts.length)];
             }
            
            /**
             * Peer mesajÄ± Ã¼ret (Enhanced Morphological System v2.7 veya fallback)
             */
            async generatePeerMessage(bacteria, context) {
                // Enhanced Morphological System v2.7 kullan
                if (window.generateEnhancedMorphSentence && bacteria.consciousness_level >= 0.8) {
                    try {
                        const mood = bacteria.personality_traits.mood || 0.5;
                        const contextEmbed = { context: context };
                        
                        return await window.generateEnhancedMorphSentence(
                            contextEmbed,
                            'simple',
                            {
                                emotionalTone: mood > 0.7 ? 'mutlu' : mood < 0.3 ? 'hÃ¼zÃ¼nlÃ¼' : 'normal',
                                complexity: bacteria.consciousness_level > 1.5 ? 'complex' : 'simple',
                                consciousness: bacteria.consciousness_level,
                                enableStyle: mood > 0.4,
                                enableComposition: mood > 0.6,
                                mood: mood
                            }
                        );
                    } catch (error) {
                        console.warn('âš ï¸ Enhanced morphology failed, using fallback');
                    }
                }
                
                // Fallback - basit mesaj Ã¼retimi
                return this.generateSimplePeerMessage(bacteria, context);
            }
            
            /**
             * Basit peer mesajÄ± (fallback)
             */
            generateSimplePeerMessage(bacteria, context) {
                                 const templates = {
                     'sad': ['Moralim bozuk...', 'Kendimi kÃ¶tÃ¼ hissediyorum', 'YardÄ±ma ihtiyacÄ±m var'],
                     'happy': ['Harika hissediyorum!', 'Bu gÃ¼n Ã§ok gÃ¼zel!', 'Seninle konuÅŸmak gÃ¼zel'],
                     'hungry': ['AcÄ±ktÄ±m...', 'Yemek arÄ±yorum', 'Enerji lazÄ±m'],
                     'philosophical': ['VaroluÅŸ hakkÄ±nda dÃ¼ÅŸÃ¼nÃ¼yorum', 'BilinÃ§ nedir?', 'BÃ¼yÃ¼mek gÃ¼zel'],
                     'social': ['Merhaba arkadaÅŸ!', 'NasÄ±lsÄ±n?', 'Birlikte takÄ±lalÄ±m'],
                     'general': ['Selam!', 'Ne yapÄ±yorsun?', 'GÃ¼zel gÃ¼n'],
                     'friendly': ['ArkadaÅŸÄ±m!', 'Seni gÃ¶rmek gÃ¼zel', 'Beraber olalÄ±m'],
                     'curious': ['Bu nedir?', 'Ã–ÄŸrenmek istiyorum', 'Merak ediyorum'],
                     'learning': ['Yeni ÅŸeyler Ã¶ÄŸreniyorum', 'AkÄ±llanÄ±yorum', 'GeliÅŸiyorum'],
                     'supportive': ['ÃœzÃ¼lme arkadaÅŸ!', 'Her ÅŸey dÃ¼zelecek', 'YanÄ±ndayÄ±m', 'Moralini bozma', 'Birlikte gÃ¼Ã§lÃ¼yÃ¼z'],
                     'group_social': ['Herkese merhaba!', 'GÃ¼zel bir grup', 'Hep birlikte gÃ¼zeliz', 'Bu sohbet Ã§ok hoÅŸ']
                 };
                
                const contextTemplates = templates[context] || templates['general'];
                const template = contextTemplates[Math.floor(Math.random() * contextTemplates.length)];
                
                // Vocabulary'den kelime ekle
                if (bacteria.vocabulary && bacteria.vocabulary.size > 0) {
                    const vocab = Array.from(bacteria.vocabulary);
                    const randomWord = vocab[Math.floor(Math.random() * vocab.length)];
                    return `${template} ${randomWord}!`;
                }
                
                return template;
            }
            
            /**
             * Peer'den Ã¶ÄŸrenme ve mood etkileÅŸimi
             */
            learnFromPeer(receiver, message, sender) {
                // Kelimeleri Ã§Ä±kar ve Ã¶ÄŸren
                const words = message.toLowerCase()
                    .replace(/[^\wÃ§ÄŸÄ±Ã¶ÅŸÃ¼Ã¢Ã®Ã»\s]/g, ' ')
                    .split(/\s+/)
                    .filter(word => word.length > 2);
                
                // Yeni kelimeleri vocabulary'ye ekle
                let newWordsLearned = 0;
                words.forEach(word => {
                    if (!receiver.vocabulary.has(word) && Math.random() < 0.4) { // %40 Ã¶ÄŸrenme ÅŸansÄ±
                        receiver.vocabulary.add(word);
                        newWordsLearned++;
                    }
                });
                
                // Mood analizi ve gÃ¼ncelleme
                let moodDelta = 0;
                words.forEach(word => {
                    if (this.POSITIVE_WORDS.has(word)) {
                        moodDelta += 0.05;
                    } else if (this.NEGATIVE_WORDS.has(word)) {
                        moodDelta -= 0.03;
                    }
                });
                
                // Sosyal etkileÅŸim bonus
                moodDelta += 0.02; // KonuÅŸmak genel olarak mood artÄ±rÄ±r
                
                                 // Mood gÃ¼ncelle (0-1 arasÄ± sÄ±nÄ±rla) - personality_traits.mood kullan
                 receiver.personality_traits.mood = Math.max(0, Math.min(1, receiver.personality_traits.mood + moodDelta));
                
                // Consciousness artÄ±ÅŸÄ± (peer learning bonus)
                if (newWordsLearned > 0) {
                    receiver.consciousness_level += newWordsLearned * 0.01;
                }
                
                // Persistent Learning'e kaydet
                if (window.persistentLearning) {
                    window.persistentLearning.recordInteraction(
                        message,
                        `Learned from ${sender.name}`,
                        'peer_learning',
                        receiver.id
                    );
                }
                
                                 console.log(`ğŸ§  ${receiver.name} learned ${newWordsLearned} words from ${sender.name}, mood: ${receiver.personality_traits.mood.toFixed(2)}`);
            }
            
            /**
             * Grup sohbeti (3-4 bakteri)
             */
            async runGroupChat() {
                const activeBacteria = bacteriaPopulation.filter(b => 
                    b.consciousness_level > 1.0 && b.personality_traits.sociability > 0.4
                );
                
                if (activeBacteria.length < 3) return;
                
                // 3-4 bakteri seÃ§
                const groupSize = Math.min(4, activeBacteria.length);
                const group = this.shuffleArray(activeBacteria).slice(0, groupSize);
                
                console.log(`ğŸ‘¥ Group chat started with: ${group.map(b => b.name).join(', ')}`);
                
                // Her bakteri sÄ±rayla konuÅŸur
                for (let i = 0; i < group.length; i++) {
                    const speaker = group[i];
                    const context = 'group_social';
                    
                    const message = await this.generatePeerMessage(speaker, context);
                    this.renderSpeechBubble(speaker, message, 4000);
                    
                    // DiÄŸer grup Ã¼yeleri Ã¶ÄŸrenir
                    group.filter(b => b !== speaker).forEach(listener => {
                        this.learnFromPeer(listener, message, speaker);
                    });
                    
                    // KÄ±sa gecikme
                    await new Promise(resolve => setTimeout(resolve, 800));
                }
            }
            
            /**
             * Depresif bakterilere destek
             */
                         async checkDepressedBacteria() {
                 const depressedBacteria = bacteriaPopulation.filter(b => b.personality_traits.mood < 0.3);
                
                for (const depressed of depressedBacteria) {
                    // Pozitif bakteri bul
                                         const supporter = bacteriaPopulation.find(b => 
                         b !== depressed && 
                         b.personality_traits.mood > 0.6 && 
                         b.personality_traits.sociability > 0.5
                     );
                    
                    if (supporter && Math.random() < 0.3) { // %30 ÅŸans ile destek
                        const supportMessage = await this.generatePeerMessage(supporter, 'supportive');
                        this.learnFromPeer(depressed, supportMessage, supporter);
                        this.renderSpeechBubble(supporter, `â†’ ${depressed.name}: ${supportMessage}`, 4000);
                        
                                                 // Extra mood boost for support
                         depressed.personality_traits.mood = Math.min(1, depressed.personality_traits.mood + 0.1);
                        
                        console.log(`ğŸ’ ${supporter.name} supported depressed ${depressed.name}`);
                    }
                }
            }
            
            /**
             * ğŸ¯ Ã–ZELLÄ°K 2: KonuÅŸma balonu render (isim + mesaj)
             */
            renderSpeechBubble(bacteria, message, duration = 3000) {
                // Previous bubble'Ä± temizle
                if (this.speechBubbles.has(bacteria.id)) {
                    clearTimeout(this.speechBubbles.get(bacteria.id).timeout);
                }
                
                // Bubble element oluÅŸtur veya gÃ¼ncelle
                let bubble = document.getElementById(`speech-${bacteria.id}`);
                if (!bubble) {
                    bubble = document.createElement('div');
                    bubble.id = `speech-${bacteria.id}`;
                    bubble.className = 'speech-bubble';
                    bubble.style.cssText = `
                        position: absolute;
                        background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(240, 248, 255, 0.9));
                        border: 1px solid #3b82f6;
                        border-radius: 12px;
                        padding: 6px 10px;
                        font-size: 11px;
                        max-width: 140px;
                        word-wrap: break-word;
                        z-index: 1000;
                        pointer-events: auto;
                        box-shadow: 0 3px 8px rgba(0,0,0,0.15);
                        cursor: pointer;
                        transition: all 0.3s ease, opacity 0.8s ease, transform 0.8s ease;
                        opacity: 1;
                        transform: scale(1) translateY(0);
                    `;
                    
                    // ğŸ¯ Bubble'a tÄ±klayÄ±nca bakteriyi seÃ§
                    bubble.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        selectedBacteria = bacteria;
                        console.log(`ğŸ¯ Speech bubble'dan bakteri seÃ§ildi: ${bacteria.name}`);
                        
                        // UI'yi gÃ¼ncelle
                        showBacteriaDetails(selectedBacteria);
                        highlightSelectedBacteria(bacteria);
                        
                        // Chat modunu individual'a Ã§evir
                        if (chatMode !== 'individual') {
                            chatMode = 'individual';
                            updateChatModeButtons();
                            updateChatUI();
                        }
                        
                        // GÃ¶rsel feedback
                        bubble.style.transform = 'scale(1.1)';
                        bubble.style.borderColor = '#22c55e';
                        setTimeout(() => {
                            bubble.style.transform = 'scale(1)';
                            bubble.style.borderColor = '#3b82f6';
                        }, 300);
                    });
                    
                    // Hover efektleri
                    bubble.addEventListener('mouseenter', () => {
                        bubble.style.transform = 'scale(1.05)';
                        bubble.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
                    });
                    
                    bubble.addEventListener('mouseleave', () => {
                        bubble.style.transform = 'scale(1)';
                        bubble.style.boxShadow = '0 3px 8px rgba(0,0,0,0.15)';
                    });
                    
                    simulationArea.appendChild(bubble);
                }
                
                // ğŸ¯ Ä°sim + mesaj iÃ§eriÄŸini oluÅŸtur
                const nameDiv = document.createElement('div');
                nameDiv.style.cssText = `
                    font-weight: bold;
                    color: #1e40af;
                    font-size: 9px;
                    margin-bottom: 2px;
                    border-bottom: 1px solid rgba(59, 130, 246, 0.3);
                    padding-bottom: 1px;
                `;
                nameDiv.textContent = bacteria.name;
                
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    color: #374151;
                    line-height: 1.2;
                `;
                messageDiv.textContent = message.substring(0, 45) + (message.length > 45 ? '...' : '');
                
                // Bubble iÃ§eriÄŸini temizle ve yeniden oluÅŸtur
                bubble.innerHTML = '';
                bubble.appendChild(nameDiv);
                bubble.appendChild(messageDiv);
                
                // Pozisyon gÃ¼ncelle (bakterinin biraz Ã¼stÃ¼nde)
                bubble.style.left = `${bacteria.x - 20}px`;
                bubble.style.top = `${bacteria.y - 35}px`;
                bubble.style.display = 'block';
                
                // ğŸ­ Entrance animasyonu
                bubble.style.opacity = '0';
                bubble.style.transform = 'scale(0.5) translateY(10px)';
                
                // Hemen entrance animasyonunu baÅŸlat
                setTimeout(() => {
                    bubble.style.opacity = '1';
                    bubble.style.transform = 'scale(1) translateY(0)';
                }, 10);
                
                // ğŸ­ GÃ¼zel fade out animasyonu
                const timeout = setTimeout(() => {
                    if (bubble && bubble.parentNode) {
                        // 1. YukarÄ± kaydÄ±rma ve fade out baÅŸlat
                        bubble.style.opacity = '0';
                        bubble.style.transform = 'scale(0.8) translateY(-10px)';
                        bubble.style.pointerEvents = 'none';
                        
                        // 2. Animasyon tamamlandÄ±ktan sonra temizle
                        setTimeout(() => {
                            if (bubble && bubble.parentNode) {
                                bubble.style.display = 'none';
                                bubble.style.opacity = '1';
                                bubble.style.transform = 'scale(1) translateY(0)';
                                bubble.style.pointerEvents = 'auto';
                            }
                        }, 800); // Transition sÃ¼resi kadar bekle
                    }
                    this.speechBubbles.delete(bacteria.id);
                }, duration - 800); // Animasyon sÃ¼resini duration'dan Ã§Ä±kar
                
                this.speechBubbles.set(bacteria.id, { bubble, timeout });
            }
            
            /**
             * Array karÄ±ÅŸtÄ±rma utility
             */
            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
        }

        // Global simulation manager (will be initialized in mainInitialize)
        let simulationManager = null;

        // Configuration Constants (centralized for better maintainability)
        const CONFIG = {
            SIMULATION: {
                INITIAL_BACTERIA_COUNT: 10,
                STEP_INTERVAL: 500, // ms - 6x faster simulation
                MAX_BACTERIA_POPULATION: 20,
                AUTO_FOOD_GENERATION_CHANCE: 0.7
            },
            BACTERIA: {
                MAX_SIZE: 3.5,
                BASE_GROWTH_RATE: 0.08,
                REPRODUCTION_MIN_AGE: 3,
                REPRODUCTION_MIN_SIZE: 1.2,
                REPRODUCTION_MIN_CONSCIOUSNESS: 1.0,
                REPRODUCTION_MIN_VOCABULARY: 5
            },
            CANVAS: {
                // âœ… V8.7.4: ALL STATIC SIZES REMOVED - FULLY DYNAMIC NOW!
                // No static width/height - canvas uses 100% responsive sizing
                // SIMULATION_AREA_* COMPLETELY REMOVED - only DYNAMIC_BOUNDARIES used
            },
            UI: {
                MAX_VOCABULARY_DISPLAY: 10,
                FOOD_SIZE: 8,
                FPS_UPDATE_INTERVAL: 1000,
                PERFORMANCE_LOG_INTERVAL: 10000
            },
            PHYSICS: {
                INTERACTION_RANGE: 50,
                Z_DEPTH_MIN: 20,
                Z_DEPTH_MAX: 180,
                BOUNDARY_ENERGY_LOSS: 0.9
            },
            AI: {
                NEURAL_NETWORK_LAYERS: [12, 16, 12, 6], // Input, Hidden1, Hidden2, Output
                LEARNING_RATE: 0.15,
                MEMORY_CAPACITY: 100,
                EXPERIENCE_REPLAY_SIZE: 30,
                GENETIC_MUTATION_RATE: 0.12,
                FITNESS_DECAY: 0.92,
                BEHAVIOR_ADAPTATION_RATE: 0.1,
                NEURAL_EVOLUTION_RATE: 0.05,
                DECISION_THRESHOLD: 0.6,
                CONSCIOUSNESS_BOOST_RATE: 0.02
            },
            VOCABULARY: {
                TABPFN_ACCELERATION: true,
                CONTEXTUAL_LEARNING_RATE: 0.25,
                PROGRESSIVE_UNLOCK_THRESHOLD: 0.8,
                SOCIAL_LEARNING_MULTIPLIER: 1.5,
                CONSCIOUSNESS_WORD_RATIO: 0.1 // Words per consciousness level
            }
        };

        // Version and Build Info (moved up to prevent hoisting issues)  
        const VERSION = 'v9.6.2 GitHub Pages Fix';
        const BUILD_DATE = new Date().toISOString().slice(0,19);
        const FEATURES = [
            'Frontend-Only TabPFN (Mobile Compatible)',
            'Smart Contextual Word Usage',
            'Intelligent Vocabulary Management',
            'TabPFN-Style Behavior Classification',
            'Enhanced Conversation Intelligence',
            'Single HTML File Solution',
            'Real-time < 1 Second Predictions',
            'Dynamic AI Model Training',
            'Live Training Data Collection',
            'Dynamic Hunger & Energy Systems',
            'Persistent Database System',
            'Unlimited Consciousness Levels',
            'CSV Data Export/Import',
            'State Restoration',
            'Enhanced Environment Visualization',
            'Bacteria ID Labels',
            'Cross-Bacteria Learning',
            'Group Chat System',
            'Molecular Dynamics Simulation',
            'High-Speed Movement & Dynamics',
            'Auto Food Generation',
            'Enhanced Reproduction System'
        ];
        const FOOD_NUTRITION = 0.5;

        // Chat State
        let chatMode = 'individual'; // 'individual', 'group'
        let bacteriaConversationTimer = null;
        let lastBacteriaConversationTime = 0;
        
        // v826: Individual Chat Windows System
        let globalConversations = []; // All bacteria-to-bacteria conversations
        let openChatWindows = new Map(); // bacteria.id -> modal element
        let chatWindowZIndex = 1000;

        // Advanced AI/ML State  
        let wordEmbeddingModel = null;
        let behaviorPredictionModel = null;
        let isMLReady = false;
        let wordTokenizer = new Map();
        let globalNeuralNetwork = null;
        let geneticAlgorithm = null;
        let behaviourLearningSystem = null;
        let tabpfnVocabularySystem = null;

        // ğŸ­ JOKE SYSTEM CONFIGURATION
        const JOKE_CONFIG = {
            PREDEFINED_JOKE_CHANCE: 0.7,      // 70% chance for predefined jokes
            JOKE_COOLDOWN: 15000,              // 15 seconds cooldown between jokes
            JOKE_MORALE_BOOST: 0.1,            // 10% morale boost from jokes
            MAX_JOKE_DISTANCE: 100,            // Maximum distance to hear jokes
            MIN_CONSCIOUSNESS_FOR_JOKES: 3,    // Minimum consciousness to tell jokes
            JOKE_SUCCESS_THRESHOLD: 0.5        // Minimum success rate for joke attempts
        };

        // ğŸ­ MATHEMATICAL COMEDY THEORY SYSTEM v8.6.1
        // Based on Incongruity Theory + Surprisal + Sigmoid Modeling
        const COMEDY_MATH_CONFIG = {
            // Incongruity (Surprisal) Parameters
            MIN_SURPRISAL: 1.0, // Minimum surprisal bits for comedy effect
            MAX_SURPRISAL: 4.0, // Maximum useful surprisal
            SURPRISAL_WEIGHT: 1.2, // Î± parameter for incongruity influence
            
            // Sigmoid Function Parameters for Joke Probability
            MOOD_WEIGHT: 1.0, // Î³ parameter for mood influence  
            SOCIABILITY_WEIGHT: 0.8, // Î´ parameter for social influence
            CONSCIOUSNESS_THRESHOLD: 2.5,
            MIN_MOOD_THRESHOLD: 0.6,
            MIN_OPTIMISM_THRESHOLD: 0.6,
            MIN_SOCIABILITY_THRESHOLD: 0.5,
            
            // Listener Reaction Parameters
            LISTENER_ETA: 1.5, // Î· - how strongly listeners absorb incongruity
            LISTENER_ZETA: 1.0, // Î¶ - stress dampening factor
            UNDERSTANDING_THRESHOLD: 0.4, // Min probability to "understand" joke
            
            // Cultural Evolution
            CULTURAL_PROMOTION_THRESHOLD: 0.8, // 80% success rate for cultural status
            MIN_LISTENERS_FOR_CULTURE: 3, // Minimum audience for cultural promotion
            CULTURAL_MEMORY_DECAY: 0.95, // How cultural jokes lose relevance over time
            
            // System Parameters
            PREDEFINED_JOKE_CHANCE: 0.6,
            DYNAMIC_JOKE_CHANCE: 0.4,
            JOKE_COOLDOWN: 30000,
            MAX_JOKE_DISTANCE: 150,
            BASE_MORALE_BOOST: 0.05,
            RITUAL_BONUS: 0.1
        };

        // ğŸ§® MATHEMATICAL COMEDY FUNCTIONS
        class ComedyMath {
            // Calculate surprisal value for word in context
            static calculateSurprisal(word, context, bacteria) {
                if (!bacteria.vocabulary || bacteria.vocabulary.size === 0) return 0;
                
                const vocabularySize = bacteria.vocabulary.size;
                const wordFrequency = bacteria.wordFrequencies?.get(word) || 1;
                const totalWords = Array.from(bacteria.wordFrequencies?.values() || [1]).reduce((a, b) => a + b, vocabularySize);
                
                // P(word | context) estimation
                const probability = wordFrequency / totalWords;
                
                // Surprisal = -log2(P(word | context))
                const surprisal = -Math.log2(Math.max(probability, 0.001)); // Avoid log(0)
                
                return Math.min(surprisal, COMEDY_MATH_CONFIG.MAX_SURPRISAL);
            }
            
            // Sigmoid function for probability calculations
            static sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }
            
            // Calculate joke-telling probability using sigmoid model
            static calculateJokeProbability(bacteria) {
                if (!bacteria.vocabulary || bacteria.vocabulary.size < 3) return 0;
                
                // Sample words from vocabulary for surprisal calculation
                const words = Array.from(bacteria.vocabulary);
                const avgSurprisal = words.slice(0, 3).reduce((sum, word) => 
                    sum + this.calculateSurprisal(word, 'joke_context', bacteria), 0) / 3;
                
                if (avgSurprisal < COMEDY_MATH_CONFIG.MIN_SURPRISAL) return 0;
                
                // Sigmoid calculation: P_joke = Ïƒ(Î±*(I-I_min) + Î³*(M-M_min) + Î´*(S-S_min))
                const x = COMEDY_MATH_CONFIG.SURPRISAL_WEIGHT * (avgSurprisal - COMEDY_MATH_CONFIG.MIN_SURPRISAL) +
                         COMEDY_MATH_CONFIG.MOOD_WEIGHT * (bacteria.personality_traits.mood - COMEDY_MATH_CONFIG.MIN_MOOD_THRESHOLD) +
                         COMEDY_MATH_CONFIG.SOCIABILITY_WEIGHT * (bacteria.personality_traits.sociability - COMEDY_MATH_CONFIG.MIN_SOCIABILITY_THRESHOLD);
                
                return this.sigmoid(x);
            }
            
            // Calculate listener's incongruity absorption (IA)
            static calculateIncongruityAbsorption(joke, listener, jokeSuprisal) {
                const stress = listener.stress || (1 - listener.personality_traits.mood); // Estimate stress from mood
                
                // IA = Ïƒ(Î· * I_joke - Î¶ * stress)
                const x = COMEDY_MATH_CONFIG.LISTENER_ETA * jokeSuprisal - 
                         COMEDY_MATH_CONFIG.LISTENER_ZETA * stress;
                
                return this.sigmoid(x);
            }
            
            // Calculate laugh probability for a listener
            static calculateLaughProbability(incongruityAbsorption, listener) {
                // P_laugh = IA Ã— S Ã— M
                return incongruityAbsorption * 
                       listener.personality_traits.sociability * 
                       listener.personality_traits.mood;
            }
            
            // Determine if joke should be promoted to cultural status
            static shouldPromoteToCulture(successRate, listenerCount) {
                return successRate >= COMEDY_MATH_CONFIG.CULTURAL_PROMOTION_THRESHOLD &&
                       listenerCount >= COMEDY_MATH_CONFIG.MIN_LISTENERS_FOR_CULTURE;
            }
            
            // Calculate cultural value decay over time
            static calculateCulturalDecay(joke, timeSinceCreation) {
                const ageInDays = timeSinceCreation / (1000 * 60 * 60 * 24);
                return Math.pow(COMEDY_MATH_CONFIG.CULTURAL_MEMORY_DECAY, ageInDays);
            }
        }

        // ğŸ“š Comprehensive Joke Database with Categories and Responses
        const PREDEFINED_JOKES = new Map([
            ["vur joker VUUÄRR", { 
                responses: ["oyna oyna oyna! ğŸ®", "VUUÄRR! ğŸƒ", "joker iyidir! ğŸ˜„", "hahaha klasik! ğŸ¤£"], 
                category: "rituel",
                successRate: 0.9,
                culturalValue: 1.0 // How "cultural" this joke is
            }],
            ["neden elektron mutsuzdu?", { 
                responses: ["Ã§Ã¼nkÃ¼ hep negatifti! âš¡", "pozitif dÃ¼ÅŸÃ¼nseydi! ğŸ˜‚", "anlamadÄ±m ama komik? ğŸ¤”"], 
                category: "bilimsel_espri",
                successRate: 0.7,
                culturalValue: 0.6
            }],
            ["ATP ne der?", { 
                responses: ["enerji veriyorum! âš¡", "yoruldum! ğŸ˜´", "sentez yapalÄ±m! ğŸ§¬"], 
                category: "biyokimya_mizahi",
                successRate: 0.75,
                culturalValue: 0.8
            }],
            ["mikroorganizma toplantÄ±sÄ±nda", { 
                responses: ["herkes Ã§ok kÃ¼Ã§Ã¼k geldi! ğŸ˜…", "bÃ¼yÃ¼tece ihtiyaÃ§ var! ğŸ”", "bÃ¶lÃ¼nelim mi? ğŸ˜„"], 
                category: "sosyal_mizah",
                successRate: 0.6,
                culturalValue: 0.7
            }]
        ]);

        // ğŸª Dynamic Joke Generation Templates
        const JOKE_TEMPLATES = [
            "{scientific_word} + {emotion_word} = {silly_result}",
            "Neden {organism} {action}? Ã‡Ã¼nkÃ¼ {reason}!",
            "{character} ne der? '{expression}!'",
            "{process} yaparken {unexpected_thing} oldu!"
        ];

        // ğŸ­ JOKE MASTER V8.8.0 - CSV-Powered Kategorik YatkÄ±nlÄ±k Sistemi
        class JokeMaster {
            constructor(vocabularySystem) {
                this.vocabularySystem = vocabularySystem;
                this.predefinedJokes = PREDEFINED_JOKES;
                this.csvJokes = []; // SAKALAR.csv data
                this.categoryAffinities = new Map(); // bacteria_id -> {category: affinity_score}
                this.jokePopularity = new Map(); // joke_id -> popularity (1-100)
                this.learnedJokes = new Map(); // Dynamic jokes learned from community
                this.culturalJokes = new Map(); // Jokes that became cultural references
                this.jokeHistory = []; // Track all told jokes for analysis
                this.generation = 0; // Joke evolution generation
                
                this.initializeCSVJokes();
                console.log('ğŸ­ JokeMaster V8.8.0 initialized with CSV Comedy System!');
            }

            // ğŸ¯ CSV Integration System
            async initializeCSVJokes() {
                try {
                    const response = await fetch('./SAKALAR.csv');
                    const csvText = await response.text();
                    this.csvJokes = this.parseCSVJokes(csvText);
                    
                    // Initialize popularity scores (50-100 range)
                    this.csvJokes.forEach(joke => {
                        this.jokePopularity.set(joke.SakaID, 50 + Math.random() * 50);
                    });
                    
                    console.log(`ğŸª Loaded ${this.csvJokes.length} jokes from SAKALAR.csv`);
                } catch (error) {
                    console.warn('ğŸ“ SAKALAR.csv not found, using fallback system');
                    this.initializeFallbackJokes();
                }
            }

            parseCSVJokes(csvText) {
                const lines = csvText.split('\n').slice(1); // Skip header
                return lines.filter(line => line.trim()).map((line, index) => {
                    const parts = line.split(',');
                    return {
                        SakaID: index + 1,
                        Kategori: (parts[0] && parts[0].trim()) || 'Genel',
                        SakaMetni: (parts[1] && parts[1].replace(/"/g, '').trim()) || '',
                        TepkiMetinleri: (parts[2] && parts[2].split('|').map(r => r.trim())) || ['ğŸ˜„', 'ğŸ¤”', 'ğŸ˜…'],
                        UygunlukSeviyesi: parseInt(parts[3]) || 1,
                        KaraMizahSeviyesi: parseInt(parts[4]) || 0
                    };
                }).filter(joke => joke.SakaMetni.length > 5);
            }

            initializeFallbackJokes() {
                this.csvJokes = [
                    {
                        SakaID: 1,
                        Kategori: 'Bilimsel_Espri',
                        SakaMetni: 'ATP\'ye sordum, enerjim nasÄ±l? O da: Sen Ã§ok potansiyellisin!',
                        TepkiMetinleri: ['Hahaha! ğŸ˜‚', 'Bilimsel! ğŸ§¬', 'Ã‡ok zeki! ğŸ¤“'],
                        UygunlukSeviyesi: 1,
                        KaraMizahSeviyesi: 0
                    },
                    {
                        SakaID: 2,
                        Kategori: 'Soguk_Espri',
                        SakaMetni: 'Bakteri neden Ã¼zgÃ¼n? Ã‡Ã¼nkÃ¼ kimse onu gÃ¶remiyor!',
                        TepkiMetinleri: ['Ayy! ğŸ˜…', 'KÃ¶tÃ¼ ama komik! ğŸ˜„', 'Baba ÅŸakasÄ±! ğŸ‘¨'],
                        UygunlukSeviyesi: 1,
                        KaraMizahSeviyesi: 0
                    },
                    {
                        SakaID: 3,
                        Kategori: 'Sim_Ozel',
                        SakaMetni: 'Vur joker vur!',
                        TepkiMetinleri: ['OLEY! ğŸ‰', 'KÃ¼ltÃ¼rel an! ğŸ­', 'Ritual! ğŸ”¥'],
                        UygunlukSeviyesi: 2,
                        KaraMizahSeviyesi: 0
                    }
                ];
            }

            // ğŸ¯ MAIN METHOD V8.8.0: Kategorik YatkÄ±nlÄ±k & PopÃ¼lerlik Motoru
            tryTellingJoke(bacteria, forced = false) {
                if (!forced && !this.isEligibleForJoke(bacteria)) return null;

                // Priority: CSV jokes > predefined > dynamic
                if (this.csvJokes.length > 0) {
                    return this.selectCSVJoke(bacteria);
                } else {
                    const jokeType = Math.random() < JOKE_CONFIG.PREDEFINED_JOKE_CHANCE ? 'predefined' : 'dynamic';
                    return jokeType === 'predefined' ? this.getPredefinedJoke(bacteria) : this.generateDynamicJoke(bacteria);
                }
            }

            // ğŸª Kategorik YatkÄ±nlÄ±k & PopÃ¼lerlik Selection Engine
            selectCSVJoke(bacteria) {
                this.updateCategoryAffinities(bacteria);
                
                let weightedJokePool = [];
                
                for (const joke of this.csvJokes) {
                    // Skip inappropriate jokes based on bacteria's dark humor tolerance
                    if (joke.KaraMizahSeviyesi > 0 && bacteria.personality_traits.dark_humor_tolerance < 0.5) {
                        continue;
                    }
                    
                    // Get personal affinity for this category
                    const personalAffinity = this.getCategoryAffinity(bacteria.id, joke.Kategori);
                    
                    // Get cultural popularity
                    const culturalPopularity = this.jokePopularity.get(joke.SakaID) || 50;
                    
                    // Calculate final weight: personal taste Ã— cultural popularity
                    const weight = personalAffinity * (culturalPopularity / 100);
                    
                    weightedJokePool.push({ joke, weight });
                }
                
                if (weightedJokePool.length === 0) return null;
                
                // Weighted random selection
                const totalWeight = weightedJokePool.reduce((sum, item) => sum + item.weight, 0);
                let random = Math.random() * totalWeight;
                
                for (const item of weightedJokePool) {
                    random -= item.weight;
                    if (random <= 0) {
                        console.log(`ğŸ­ ${bacteria.name} selected ${item.joke.Kategori} joke with weight ${item.weight.toFixed(2)}`);
                        return this.formatCSVJoke(item.joke, bacteria);
                    }
                }
                
                // Fallback
                return this.formatCSVJoke(weightedJokePool[0].joke, bacteria);
            }

            // ğŸ§® Dynamic Category Affinity Updates Based on Personality
            updateCategoryAffinities(bacteria) {
                if (!this.categoryAffinities.has(bacteria.id)) {
                    this.categoryAffinities.set(bacteria.id, {});
                }
                
                const affinities = this.categoryAffinities.get(bacteria.id);
                
                // Bilimsel Espri - High consciousness & curiosity
                affinities.Bilimsel_Espri = (bacteria.consciousness_level / 10) * 0.5 + 
                                           bacteria.personality_traits.curiosity * 0.5;
                
                // SoÄŸuk Espri - Low social skills but high humor attempts
                affinities.Soguk_Espri = (1 - bacteria.personality_traits.sociability) * 0.6 + 
                                        bacteria.personality_traits.humor_attempts * 0.4;
                
                // Kara Mizah - Dark humor tolerance + low optimism
                affinities.Kara_Mizah = (bacteria.personality_traits.dark_humor_tolerance || 0) * 0.7 + 
                                       (1 - bacteria.personality_traits.optimism) * 0.3;
                
                // Sim Ã–zel (Rituals) - High sociability + cultural awareness
                affinities.Sim_Ozel = bacteria.personality_traits.sociability * 0.6 + 
                                     (bacteria.memory_bank.length / 100) * 0.4;
                
                // Other categories get balanced scoring
                ['Absurt_Mizah', 'Kelime_Oyunu', 'Gundelik_Mizah', 'Sosyal_Mizah'].forEach(category => {
                    affinities[category] = 0.3 + Math.random() * 0.4; // 0.3-0.7 range
                });
            }

            getCategoryAffinity(bacteriaId, category) {
                const affinities = this.categoryAffinities.get(bacteriaId) || {};
                return affinities[category] || 0.5; // Default neutral affinity
            }

            formatCSVJoke(csvJoke, bacteria) {
                return {
                    type: 'csv',
                    text: csvJoke.SakaMetni,
                    responses: csvJoke.TepkiMetinleri,
                    category: csvJoke.Kategori,
                    originator: bacteria,
                    culturalValue: Math.min(1.0, (this.jokePopularity.get(csvJoke.SakaID) || 50) / 100),
                    expectedSuccess: 0.7,
                    jokeId: csvJoke.SakaID
                };
            }

            isEligibleForJoke(bacteria) {
                // Mathematical eligibility check
                const jokeProbability = ComedyMath.calculateJokeProbability(bacteria);
                const baseEligibility = bacteria.consciousness_level >= COMEDY_MATH_CONFIG.CONSCIOUSNESS_THRESHOLD &&
                       bacteria.personality_traits.optimism >= COMEDY_MATH_CONFIG.MIN_OPTIMISM_THRESHOLD &&
                       bacteria.personality_traits.sociability >= COMEDY_MATH_CONFIG.MIN_SOCIABILITY_THRESHOLD &&
                       bacteria.personality_traits.mood >= COMEDY_MATH_CONFIG.MIN_MOOD_THRESHOLD;
                
                // Add mathematical probability threshold
                return baseEligibility && jokeProbability > 0.1; // 10% minimum joke probability
            }

            getPredefinedJoke(bacteria) {
                const availableJokes = Array.from(this.predefinedJokes.keys());
                if (availableJokes.length === 0) return null;

                // Prefer jokes bacteria hasn't told recently or cultural jokes
                let selectedJoke = availableJokes[Math.floor(Math.random() * availableJokes.length)];
                
                // Cultural bias: prefer ritual jokes if bacteria has high social traits
                if (bacteria.personality_traits.sociability > 0.8) {
                    const culturalJokes = availableJokes.filter(joke => 
                        this.predefinedJokes.get(joke).category === 'rituel'
                    );
                    if (culturalJokes.length > 0) {
                        selectedJoke = culturalJokes[Math.floor(Math.random() * culturalJokes.length)];
                    }
                }

                const jokeData = this.predefinedJokes.get(selectedJoke);
                return {
                    type: 'predefined',
                    text: selectedJoke,
                    responses: jokeData.responses,
                    category: jokeData.category,
                    originator: bacteria,
                    culturalValue: jokeData.culturalValue,
                    expectedSuccess: jokeData.successRate
                };
            }

            // TabPFN-Enhanced Dynamic Joke Generation
            generateDynamicJoke(bacteria) {
                const learnedWords = Array.from(bacteria.vocabulary);
                if (learnedWords.length < 3) return null;

                // Use TabPFN to get contextually interesting words
                let jokeText = this.createDynamicJokeText(bacteria, learnedWords);
                
                if (!jokeText || jokeText.split(" ").length < 2) return null;

                const dynamicResponses = [
                    "hahaha! ğŸ˜‚", "Ã§ok yaratÄ±cÄ±! ğŸ¨", "bu ne ya? ğŸ¤”", 
                    "komik! ğŸ˜„", "anlamadÄ±m ama gÃ¼ldÃ¼m! ğŸ˜…", "daha fazla! ğŸ­",
                    "absÃ¼rt ama hoÅŸ! ğŸ¤ª", "kelime ustasÄ±! ğŸ“š"
                ];

                return {
                    type: 'dynamic',
                    text: jokeText,
                    responses: dynamicResponses,
                    category: "yaratici_absurt",
                    originator: bacteria,
                    culturalValue: 0.3, // Dynamic jokes start with low cultural value
                    expectedSuccess: 0.5
                };
            }

            createDynamicJokeText(bacteria, learnedWords) {
                // Mathematical word selection based on surprisal theory
                let jokeWords = [];
                
                // Calculate surprisal for all learned words and select high-surprisal words
                const wordSurprisals = learnedWords.map(word => ({
                    word: word,
                    surprisal: ComedyMath.calculateSurprisal(word, 'joke_context', bacteria)
                }));
                
                // Sort by surprisal (descending) and take top words for comedy
                wordSurprisals.sort((a, b) => b.surprisal - a.surprisal);
                
                // Select words with good surprisal values for incongruity
                const highSurprisalWords = wordSurprisals
                    .filter(ws => ws.surprisal >= COMEDY_MATH_CONFIG.MIN_SURPRISAL)
                    .slice(0, 5); // Top 5 surprising words
                
                if (highSurprisalWords.length < 2) {
                    // Fallback to random selection if no high-surprisal words
                    jokeWords = learnedWords.slice(0, 3);
                } else {
                    // Use mathematical selection: mix of high surprisal and context
                    jokeWords = [
                        highSurprisalWords[0]?.word || learnedWords[0], // Most surprising
                        highSurprisalWords[Math.floor(Math.random() * Math.min(3, highSurprisalWords.length))]?.word || learnedWords[1],
                        learnedWords[Math.floor(Math.random() * learnedWords.length)] // Random for absurdity
                    ].filter(w => w);
                }

                // Enhanced TabPFN integration if available
                if (this.vocabularySystem && typeof this.vocabularySystem.improveWordUsage === 'function') {
                    const contexts = ['scientific', 'social', 'philosophical'];
                    const contextWord = this.vocabularySystem.improveWordUsage(bacteria, contexts[Math.floor(Math.random() * contexts.length)]);
                    if (contextWord && !jokeWords.includes(contextWord)) {
                        jokeWords[2] = contextWord; // Replace last word with context-appropriate word
                    }
                }

                // Create joke using mathematical template selection
                const template = JOKE_TEMPLATES[Math.floor(Math.random() * JOKE_TEMPLATES.length)];
                const jokeText = this.fillJokeTemplate(template, jokeWords, bacteria);
                
                // Calculate final joke surprisal for quality control
                const finalSurprisal = jokeWords.reduce((sum, word) => 
                    sum + ComedyMath.calculateSurprisal(word, 'combined_joke', bacteria), 0) / jokeWords.length;
                
                console.log(`ğŸ§® Dynamic joke created with avg surprisal: ${finalSurprisal.toFixed(2)} bits`);
                
                return jokeText;
            }

            fillJokeTemplate(template, words, bacteria) {
                // Simple template filling - can be made more sophisticated
                let joke = template;
                
                const wordTypes = {
                    scientific_word: words.filter(w => ['ATP', 'DNA', 'protein', 'enzim'].includes(w))[0] || words[0] || 'molekÃ¼l',
                    emotion_word: words.filter(w => ['mutlu', 'Ã¼zgÃ¼n', 'komik', 'neÅŸeli'].includes(w))[0] || words[1] || 'garip',
                    organism: 'bakteri',
                    action: words[2] || 'hareket',
                    reason: words.join(' '),
                    character: bacteria.name,
                    expression: words.slice(0,2).join(' ') || 'haha',
                    process: 'Ã¶ÄŸrenme',
                    unexpected_thing: words[words.length-1] || 'ÅŸaÅŸÄ±rtÄ±cÄ±'
                };

                // Replace template variables
                Object.keys(wordTypes).forEach(key => {
                    joke = joke.replace(`{${key}}`, wordTypes[key]);
                });

                return joke;
            }

            // Mathematical joke outcome recording with cultural evolution
            recordJokeOutcome(jokeText, wasSuccessful, listenerCount, avgSurprisal = 0) {
                const jokeData = this.learnedJokes.get(jokeText) || { 
                    count: 0, 
                    successCount: 0, 
                    listeners: new Set(),
                    generation: this.generation,
                    avgSurprisal: 0,
                    culturalValue: 0.3,
                    createdAt: Date.now()
                };
                
                jokeData.count++;
                if (wasSuccessful) jokeData.successCount++;
                
                // Update average surprisal for this joke
                jokeData.avgSurprisal = (jokeData.avgSurprisal * (jokeData.count - 1) + avgSurprisal) / jokeData.count;
                
                this.learnedJokes.set(jokeText, jokeData);

                // Mathematical popularity calculation
                const successRate = jokeData.successCount / jokeData.count;
                const surprisalBonus = Math.min(jokeData.avgSurprisal / COMEDY_MATH_CONFIG.MAX_SURPRISAL, 1);
                const listenerBonus = Math.min(listenerCount / COMEDY_MATH_CONFIG.MIN_LISTENERS_FOR_CULTURE, 1);
                
                const mathematicalPopularity = successRate * 0.6 + surprisalBonus * 0.2 + listenerBonus * 0.2;
                this.jokePopularity.set(jokeText, mathematicalPopularity);

                // Mathematical cultural promotion check
                if (ComedyMath.shouldPromoteToCulture(successRate, listenerCount) && 
                    jokeData.avgSurprisal >= COMEDY_MATH_CONFIG.MIN_SURPRISAL) {
                    this.promoteToculturalJoke(jokeText, jokeData);
                }

                // Enhanced tracking with mathematical metrics
                this.jokeHistory.push({
                    text: jokeText,
                    successful: wasSuccessful,
                    listeners: listenerCount,
                    timestamp: Date.now(),
                    surprisal: avgSurprisal,
                    successRate: successRate,
                    culturalValue: jokeData.culturalValue,
                    mathematicalPopularity: mathematicalPopularity
                });
                
                console.log(`ğŸ“Š Joke metrics - Success: ${(successRate*100).toFixed(1)}%, Surprisal: ${avgSurprisal.toFixed(2)}, Popularity: ${(mathematicalPopularity*100).toFixed(1)}%`);
            }

            promoteToculturalJoke(jokeText, jokeData) {
                if (!this.culturalJokes.has(jokeText)) {
                    this.culturalJokes.set(jokeText, {
                        ...jokeData,
                        promotedAt: Date.now(),
                        culturalValue: 0.9
                    });
                    
                    console.log(`ğŸ† Joke promoted to cultural status: "${jokeText}"`);
                    
                    // Add to predefined jokes for future use
                    this.predefinedJokes.set(jokeText, {
                        responses: ["bu klasik! ğŸ˜„", "biliyorum bunu! ğŸ¤£", "efsane ÅŸaka! ğŸ†"],
                        category: "komunite_klasigi",
                        successRate: jokeData.successCount / jokeData.count,
                        culturalValue: 0.9
                    });
                }
            }

            // Get statistics for system analysis
            getJokeStatistics() {
                return {
                    totalJokes: this.jokeHistory.length,
                    culturalJokes: this.culturalJokes.size,
                    learnedJokes: this.learnedJokes.size,
                    averageSuccess: this.jokeHistory.reduce((acc, j) => acc + (j.successful ? 1 : 0), 0) / this.jokeHistory.length,
                    generation: this.generation
                };
            }
        }

        // Global JokeMaster instance
        let jokeMasterInstance = null;

        // ğŸ§¬ DYNAMIC LANGUAGE EVOLUTION SYSTEM v8.7.0
        // ğŸš€ V8.9.0: ANTI-PATTERN LANGUAGE EVOLUTION ENGINE - Revolutionary Language System
        class LanguageEvolutionEngine {
            constructor() {
                this.globalLanguagePatterns = new Map(); // TÃ¼m bakterilerde kullanÄ±lan dil kalÄ±plarÄ±
                this.wordMutations = new Map(); // Kelime mutasyonlarÄ±/evrimleri
                this.contextualPhrases = new Map(); // BaÄŸlamsal ifade kalÄ±plarÄ±
                this.personalityLanguageTraits = new Map(); // KiÅŸilik bazlÄ± dil Ã¶zellikleri
                this.languageGeneration = 0; // Dil evrimi nesli
                this.emergentGrammar = new Map(); // Ortaya Ã§Ä±kan gramer kurallarÄ±
                
                // ğŸ†• V8.9.0: ANTI-PATTERN FEATURES
                this.bacteriaBigrams = new Map(); // Markov chains for each bacteria
                this.metaTemplates = new Map(); // Meta-template system
                this.absurdWords = ['mikrofon', 'gÃ¼neÅŸ', 'hipopotam', 'kuantum', 'pizza', 'roket', 'dinozor', 'kristal']; // Shock elements
                this.contextOverrides = new Map(); // Context breaking triggers
                this.adaptiveSuccess = new Map(); // Success tracking for reinforcement
                
                console.log('ğŸ§¬ Language Evolution Engine V8.9.1: ANTI-PATTERN TEST MODE!');
                console.log('ğŸ”¥ TEST MODE: Boosted probabilities for immediate visibility');
                console.log('ğŸ² Îµ-greedy: 60% | ğŸ­ Meta-template: 70% | ğŸª Absurd: 48%');
                this.initializeBasicPatterns();
                this.initializeAntiPatternSystems();
            }

            // ğŸ¯ Initialize Anti-Pattern Systems
            initializeAntiPatternSystems() {
                // Meta-templates for pattern-breaking conversations
                this.metaTemplates.set('complex_mix', [
                    "{greeting} {subTemplate1}; ama aslÄ±nda {subTemplate2}.",
                    "Ã–nce {subTemplate1}, sonra {subTemplate2}, sonuÃ§: {reaction}.",
                    "{subject} der ki: \"{subTemplate1}?\" {subTemplate2}!",
                    "{subTemplate1} + {shock_element} = {subTemplate2}",
                    "Ä°lginÃ§: {subTemplate1}, Ã§Ã¼nkÃ¼ {subTemplate2}..."
                ]);
                
                // Context override triggers - ğŸ”¥ V8.9.1 TEST: EASIER CONDITIONS FOR VISIBILITY
                this.contextOverrides.set('high_stress', (bacteria) => bacteria.personality_traits.mood < 0.6); // Lowered from 0.3
                this.contextOverrides.set('confusion', (bacteria) => bacteria.consciousness_level < 5 && bacteria.vocabulary.size > 3); // Relaxed conditions
                this.contextOverrides.set('creative_burst', (bacteria) => bacteria.personality_traits.creativity > 0.5); // Lowered from 0.8
                this.contextOverrides.set('random_chaos', (bacteria) => Math.random() < 0.1); // ğŸ†• 10% pure random chaos!
                
                console.log('ğŸ­ Anti-Pattern systems initialized!');
            }

            initializeBasicPatterns() {
                // Temel dil kalÄ±plarÄ± - bunlar evrimleÅŸecek
                this.contextualPhrases.set('greeting', [
                    "{subject} merhaba!",
                    "{emotion} {subject}",
                    "hey {target}!"
                ]);
                
                this.contextualPhrases.set('learning', [
                    "{subject} Ã¶ÄŸrendim: {learned_word}",
                    "{surprise_word} + {learned_word} = {reaction}",
                    "yeni keÅŸif: {learned_word}"
                ]);
                
                this.contextualPhrases.set('excitement', [
                    "{emotion}! {discovery}!",
                    "{learned_word} + {emotion} = harika!",
                    "vay be, {surprise_word}!"
                ]);
                
                this.contextualPhrases.set('confusion', [
                    "{confusion_word}... {learned_word}?",
                    "ne demek {unknown_word}?",
                    "{learned_word} + ? = kafam karÄ±ÅŸtÄ±"
                ]);
                
                this.contextualPhrases.set('social', [
                    "{friend_name}, {learned_word} paylaÅŸalÄ±m!",
                    "birlikte {activity} yapalÄ±m",
                    "{emotion} arkadaÅŸlÄ±k"
                ]);
            }

            // ğŸ­ V8.9.0: ADVANCED PERSONALITY LANGUAGE GENERATOR
            generatePersonalityLanguage(bacteria) {
                if (!bacteria.personalLanguageStyle) {
                    bacteria.personalLanguageStyle = {
                        wordOrder: Math.random() > 0.5 ? 'normal' : 'inverted', // Kelime sÄ±rasÄ±
                        emotionLevel: bacteria.personality_traits.optimism, // Duygusal yoÄŸunluk
                        complexityPreference: bacteria.consciousness_level / 10, // KarmaÅŸÄ±klÄ±k seviyesi
                        uniqueWords: new Set(), // Kendine Ã¶zgÃ¼ kelimeler
                        phrasePatterns: new Map(), // KiÅŸisel ifade kalÄ±plarÄ±
                        mutationRate: bacteria.personality_traits.humor * 0.3, // Dil mutasyon oranÄ±
                        
                        // ğŸ†• V8.9.1 TEST: BOOSTED ANTI-PATTERN TRAITS FOR VISIBILITY
                        slangProbability: 0.4 + Math.random() * 0.4, // %40-80 argo/slang kullanma
                        repetitionProbability: 0.2 + Math.random() * 0.3, // %20-50 kelime tekrar etme
                        punctuationStyle: Math.random() < 0.5 ? '!!' : '?!', // Noktalama tarzÄ±
                        absurdTolerance: 0.3 + Math.random() * 0.5, // %30-80 absÃ¼rt Ã¶ÄŸe kabulÃ¼
                        patternBreakingTendency: 0.3 + Math.random() * 0.5, // %30-80 kalÄ±p kÄ±rma eÄŸilimi
                        markovChainUsage: 0.4 + Math.random() * 0.5, // %40-90 Markov zinciri kullanÄ±m
                        contextSwitchRate: 0.2 + Math.random() * 0.4, // %20-60 baÄŸlam deÄŸiÅŸtirme
                        metaTemplatePreference: Math.random() < 0.6 // %60 meta-template tercihi
                    };
                    
                    // Initialize personal bigram map for Markov chains
                    if (!this.bacteriaBigrams.has(bacteria.id)) {
                        this.bacteriaBigrams.set(bacteria.id, new Map());
                    }
                }
                return bacteria.personalLanguageStyle;
            }

            // Yeni kelime kombinasyonu yaratma (ML-enhanced)
            createWordCombination(bacteria, context, baseWords) {
                const style = this.generatePersonalityLanguage(bacteria);
                const vocabulary = Array.from(bacteria.vocabulary);
                
                if (vocabulary.length < 2) return baseWords.join(' ');

                // TabPFN-enhanced kelime seÃ§imi
                let enhancedWords = [];
                for (let i = 0; i < 3; i++) {
                    let word;
                    
                    // TabPFN kullanarak baÄŸlamsal kelime Ã¶ner
                    if (tabpfnVocabularySystem && typeof tabpfnVocabularySystem.improveWordUsage === 'function') {
                        word = tabpfnVocabularySystem.improveWordUsage(bacteria, context);
                    }
                    
                    // Yoksa bakterinin kendi kelimelerinden seÃ§
                    if (!word) {
                        word = vocabulary[Math.floor(Math.random() * vocabulary.length)];
                    }
                    
                    enhancedWords.push(word);
                }

                // KiÅŸilik bazlÄ± kombinasyon
                if (style.wordOrder === 'inverted') {
                    enhancedWords.reverse();
                }

                // Duygusal yoÄŸunluk ekle
                if (style.emotionLevel > 0.7) {
                    const emotions = ['!', '!! ğŸ˜Š', 'âœ¨', 'ğŸ‰', 'ğŸ’«'];
                    enhancedWords.push(emotions[Math.floor(Math.random() * emotions.length)]);
                }

                // KarmaÅŸÄ±klÄ±k seviyesine gÃ¶re baÄŸlaÃ§ ekle
                if (style.complexityPreference > 0.6 && enhancedWords.length > 1) {
                    const connectors = ['+', 've', 'ile', 'â†’', '='];
                    const connector = connectors[Math.floor(Math.random() * connectors.length)];
                    return enhancedWords.slice(0, 2).join(` ${connector} `) + 
                           (enhancedWords[2] ? ` ${enhancedWords[2]}` : '');
                }

                return enhancedWords.join(' ');
            }

            // ğŸ§¬ V8.9.0: ENHANCED WORD MUTATION with Noise Factor
            mutateWord(bacteria, originalWord) {
                const style = this.generatePersonalityLanguage(bacteria);
                
                // Enhanced mutation chance with random noise
                const baseMutation = Math.random() < style.mutationRate;
                const randomNoise = Math.random() < 0.1; // 10% extra chaos factor
                
                if (!baseMutation && !randomNoise) return originalWord;

                const mutations = [
                    // Ses deÄŸiÅŸimi
                    () => originalWord.replace(/a/g, 'e').replace(/o/g, 'u'),
                    // Ek ekleme
                    () => originalWord + (Math.random() > 0.5 ? 'ik' : 'li'),
                    // KÄ±saltma
                    () => originalWord.length > 3 ? originalWord.slice(0, -1) : originalWord,
                    // Tekrar
                    () => originalWord + originalWord.slice(-2),
                    // Emoji ekleme
                    () => originalWord + ['âœ¨', 'ğŸŒŸ', 'ğŸ’«', 'ğŸ”®'][Math.floor(Math.random() * 4)],
                    // ğŸ†• V8.9.0: Anti-Pattern Mutations
                    () => originalWord.split('').reverse().join(''), // Reverse letters
                    () => originalWord + this.getRandomChoice(this.absurdWords).slice(0, 2), // Absurd suffix
                    () => this.getRandomChoice(['yee', 'hmm', 'aaa']) + originalWord, // Sound prefix
                    () => originalWord.replace(/./g, c => Math.random() < 0.3 ? c.toUpperCase() : c) // Random caps
                ];

                const mutationType = mutations[Math.floor(Math.random() * mutations.length)];
                const mutatedWord = mutationType();

                // Mutasyonu kaydet
                if (!this.wordMutations.has(originalWord)) {
                    this.wordMutations.set(originalWord, new Set());
                }
                this.wordMutations.get(originalWord).add(mutatedWord);

                const noiseIndicator = randomNoise ? 'ğŸ²' : 'ğŸ§¬';
                console.log(`${noiseIndicator} ${bacteria.name} word mutation: ${originalWord} â†’ ${mutatedWord}`);
                return mutatedWord;
            }

            // ğŸ“ˆ V8.9.0: Adaptive Style Reinforcement Learning
            adaptLanguageStyle(bacteria, wasSuccessful, context) {
                if (!bacteria.personalLanguageStyle) return;
                
                const style = bacteria.personalLanguageStyle;
                const adaptationRate = 0.02;
                
                if (wasSuccessful) {
                    // Reinforce successful traits
                    style.mutationRate = Math.min(1, style.mutationRate + adaptationRate);
                    style.slangProbability = Math.min(0.8, style.slangProbability + adaptationRate);
                    style.markovChainUsage = Math.min(1, style.markovChainUsage + adaptationRate);
                    
                    // Track success
                    const stats = this.adaptiveSuccess.get(bacteria.id);
                    if (stats) {
                        stats.successfulResponses++;
                        if (stats.contexts.has(context)) {
                            stats.contexts.get(context).successes++;
                        }
                    }
                    
                    console.log(`ğŸ“ˆ ${bacteria.name} language style reinforced (success rate: ${((stats?.successfulResponses || 0) / (stats?.totalResponses || 1) * 100).toFixed(1)}%)`);
                } else {
                    // Reduce unsuccessful traits
                    style.mutationRate = Math.max(0, style.mutationRate - adaptationRate);
                    style.repetitionProbability = Math.max(0, style.repetitionProbability - adaptationRate);
                    style.absurdTolerance = Math.max(0, style.absurdTolerance - adaptationRate * 0.5);
                }
                
                // Update bigram map periodically
                if (Math.random() < 0.1) { // 10% chance to rebuild
                    this.updateBigramMap(bacteria, Array.from(bacteria.vocabulary));
                }
            }

            // ğŸš€ V8.9.0: REVOLUTIONARY ANTI-PATTERN CONTEXTUAL RESPONSE GENERATOR
            generateContextualResponse(bacteria, context, trigger = null) {
                const style = this.generatePersonalityLanguage(bacteria);
                const vocabulary = Array.from(bacteria.vocabulary);
                
                // ğŸ¯ STEP 1: CHECK CONTEXT OVERRIDES (Anti-Pattern Mechanism)
                const overrideResult = this.checkContextOverrides(bacteria, context);
                if (overrideResult) {
                    console.log(`ğŸ”„ ${bacteria.name} context override: ${context} â†’ ${overrideResult.newContext}`);
                    context = overrideResult.newContext;
                    return overrideResult.response;
                }
                
                // ğŸ¯ STEP 2: Îµ-GREEDY PATTERN SELECTION (Randomness Layer)
                let selectedResponse;
                const epsilonGreedy = 0.6; // ğŸ”¥ V8.9.1 TEST: 60% chance for anti-pattern visibility
                
                if (Math.random() < epsilonGreedy) {
                    // ğŸ² 60% CHANCE: COMPLETELY RANDOM, PATTERN-FREE RESPONSE
                    selectedResponse = this.generateRandomMarkovResponse(bacteria, vocabulary);
                    console.log(`ğŸ² ANTI-PATTERN: ${bacteria.name} Îµ-greedy random response: ${selectedResponse}`);
                    console.log(`ğŸ”¥ PATTERN BREAKING ACHIEVED! Traditional templates bypassed.`);
                } else if (style.metaTemplatePreference && Math.random() < 0.7) {
                    // ğŸ­ 70% CHANCE: META-TEMPLATE RESPONSE (Pattern within Pattern) - BOOSTED FOR VISIBILITY
                    selectedResponse = this.generateMetaTemplateResponse(bacteria, context, vocabulary, trigger);
                    console.log(`ğŸ­ META-TEMPLATE: ${bacteria.name} complex pattern-within-pattern response`);
                    console.log(`ğŸ”¥ ADVANCED ANTI-PATTERN: Multi-layered response generated!`);
                } else if (style.markovChainUsage > 0.3 && Math.random() < style.markovChainUsage) {
                    // ğŸ”— MARKOV CHAIN RESPONSE (Statistical Word Flow)
                    selectedResponse = this.generateMarkovChainResponse(bacteria, vocabulary);
                    console.log(`ğŸ”— MARKOV CHAIN: ${bacteria.name} statistical word flow response`);
                    console.log(`ğŸ§® PATTERN-FREE: Using bigram probabilities instead of templates!`);
                } else {
                    // ğŸ¯ TRADITIONAL TEMPLATE-BASED (Enhanced with mutations)
                    selectedResponse = this.generateTraditionalResponse(bacteria, context, vocabulary, trigger);
                }
                
                // ğŸ¨ STEP 3: APPLY PERSONALITY MUTATIONS
                selectedResponse = this.applyPersonalityMutations(selectedResponse, bacteria, style);
                
                // ğŸª STEP 4: ADD ABSURD ELEMENTS (Shock Factor)
                if (Math.random() < style.absurdTolerance * 0.8) { // ğŸ”¥ V8.9.1 TEST: Up to 48% chance for visibility
                    selectedResponse = this.addAbsurdElement(selectedResponse, bacteria);
                }
                
                // ğŸ“ˆ STEP 5: ADAPTIVE LEARNING (Success Tracking)
                this.trackResponseForAdaptation(bacteria, context, selectedResponse);
                
                return selectedResponse;
            }

            // ğŸ”„ Context Override System - Breaking Patterns Based on State
            checkContextOverrides(bacteria, context) {
                for (const [overrideType, checkFunction] of this.contextOverrides.entries()) {
                    if (checkFunction(bacteria)) {
                        switch (overrideType) {
                            case 'high_stress':
                                return {
                                    newContext: 'stress_break',
                                    response: 'bu ne ya? ' + this.getRandomChoice(["hmm", "belki deÄŸil", "bilmiyorum", "kafam karÄ±ÅŸtÄ±"]) + '...'
                                };
                            case 'confusion':
                                return {
                                    newContext: 'absurd_confusion',
                                    response: this.getRandomChoice(this.absurdWords) + ' ne demek? ' + this.getRandomChoice(Array.from(bacteria.vocabulary)) + '?!'
                                };
                            case 'creative_burst':
                                return {
                                    newContext: 'creative_explosion',
                                    response: this.generateRandomMarkovResponse(bacteria, Array.from(bacteria.vocabulary)) + ' âœ¨ğŸ¨'
                                };
                            case 'random_chaos':
                                return {
                                    newContext: 'pure_chaos',
                                    response: this.getRandomChoice(this.absurdWords) + ' ' + 
                                             this.getRandomChoice(this.absurdWords) + ' ' +
                                             this.getRandomChoice(['!!!', '???', '!?!', '...']) + ' ğŸ¤ª'
                                };
                        }
                    }
                }
                return null;
            }

            // ğŸ² Generate Completely Random Markov-style Response
            generateRandomMarkovResponse(bacteria, vocabulary) {
                if (vocabulary.length < 2) return "yeni kelime Ã¶ÄŸrenmeliyim!";
                
                const responseLength = 2 + Math.floor(Math.random() * 3); // 2-4 words
                let response = [];
                
                for (let i = 0; i < responseLength; i++) {
                    const word = vocabulary[Math.floor(Math.random() * vocabulary.length)];
                    response.push(this.mutateWord(bacteria, word));
                }
                
                return response.join(' ');
            }

            // ğŸ”— Generate Markov Chain Response - Statistical Word Flow
            generateMarkovChainResponse(bacteria, vocabulary) {
                const bigramMap = this.bacteriaBigrams.get(bacteria.id);
                if (!bigramMap || bigramMap.size === 0) {
                    this.updateBigramMap(bacteria, vocabulary);
                    return this.generateRandomMarkovResponse(bacteria, vocabulary);
                }
                
                // Start with random word
                const startWords = Array.from(bigramMap.keys());
                let currentWord = startWords[Math.floor(Math.random() * startWords.length)];
                let sentence = [currentWord];
                
                // Generate 2-4 words using bigram probabilities
                for (let i = 0; i < 2 + Math.floor(Math.random() * 2); i++) {
                    const nextWords = bigramMap.get(currentWord);
                    if (!nextWords || nextWords.length === 0) {
                        nextWords = vocabulary; // Fallback to random vocabulary
                    }
                    const nextWord = nextWords[Math.floor(Math.random() * nextWords.length)];
                    sentence.push(nextWord);
                    currentWord = nextWord;
                }
                
                return sentence.join(' ');
            }

            // ğŸ­ Generate Meta-Template Response (Pattern within Pattern)
            generateMetaTemplateResponse(bacteria, context, vocabulary, trigger) {
                const metaTemplates = this.metaTemplates.get('complex_mix');
                const selectedMeta = metaTemplates[Math.floor(Math.random() * metaTemplates.length)];
                
                // Generate sub-templates
                const subTemplate1 = this.generateTraditionalResponse(bacteria, context, vocabulary, trigger);
                const subTemplate2 = this.generateRandomMarkovResponse(bacteria, vocabulary);
                
                const replacements = {
                    '{greeting}': this.getRandomChoice(['merhaba', 'selam', 'hey', bacteria.name]),
                    '{subTemplate1}': subTemplate1,
                    '{subTemplate2}': subTemplate2,
                    '{subject}': bacteria.name,
                    '{reaction}': this.getRandomChoice(['ilginÃ§', 'garip', 'harika', 'ÅŸaÅŸÄ±rtÄ±cÄ±']),
                    '{shock_element}': this.getRandomChoice(this.absurdWords)
                };
                
                let result = selectedMeta;
                Object.keys(replacements).forEach(placeholder => {
                    result = result.replace(new RegExp(placeholder, 'g'), replacements[placeholder]);
                });
                
                return result;
            }

            // ğŸ¯ Generate Traditional Response (Enhanced)
            generateTraditionalResponse(bacteria, context, vocabulary, trigger) {
                const style = this.generatePersonalityLanguage(bacteria);
                
                // BaÄŸlamsal kalÄ±p seÃ§
                const patterns = this.contextualPhrases.get(context) || ["{learned_word} {emotion}"];
                let selectedPattern = patterns[Math.floor(Math.random() * patterns.length)];

                // KiÅŸisel kalÄ±plarÄ± kontrol et
                if (style.phrasePatterns.has(context)) {
                    const personalPatterns = Array.from(style.phrasePatterns.get(context));
                    if (personalPatterns.length > 0 && Math.random() < 0.6) {
                        selectedPattern = personalPatterns[Math.floor(Math.random() * personalPatterns.length)];
                    }
                }

                return this.fillDynamicPattern(selectedPattern, bacteria, vocabulary, trigger);
            }

            // ğŸ¨ Apply Personality Mutations to Response
            applyPersonalityMutations(response, bacteria, style) {
                let mutatedResponse = response;
                
                // Add slang/informal words
                if (Math.random() < style.slangProbability) {
                    const slangs = ['yaa', 'hadiiii', 'of be', 'valla', 'ama ya', 'iÅŸte'];
                    mutatedResponse = this.getRandomChoice(slangs) + ' ' + mutatedResponse;
                }
                
                // Add word repetition
                if (Math.random() < style.repetitionProbability) {
                    const words = mutatedResponse.split(' ');
                    if (words.length > 1) {
                        const idx = Math.floor(Math.random() * words.length);
                        words.splice(idx, 0, words[idx]); // Duplicate word
                        mutatedResponse = words.join(' ');
                    }
                }
                
                // Add punctuation style
                mutatedResponse += style.punctuationStyle;
                
                return mutatedResponse;
            }

            // ğŸª Add Absurd Element (Shock Factor)
            addAbsurdElement(response, bacteria) {
                const words = response.split(' ');
                const absurdWord = this.getRandomChoice(this.absurdWords);
                
                if (words.length >= 2) {
                    // Insert absurd word in the middle
                    const insertPos = 1 + Math.floor(Math.random() * (words.length - 1));
                    words.splice(insertPos, 0, absurdWord);
                    console.log(`ğŸª ${bacteria.name} added absurd element: ${absurdWord}`);
                }
                
                return words.join(' ');
            }

            // ğŸ“ˆ Track Response for Adaptive Learning
            trackResponseForAdaptation(bacteria, context, response) {
                if (!this.adaptiveSuccess.has(bacteria.id)) {
                    this.adaptiveSuccess.set(bacteria.id, { 
                        totalResponses: 0, 
                        successfulResponses: 0,
                        contexts: new Map()
                    });
                }
                
                const stats = this.adaptiveSuccess.get(bacteria.id);
                stats.totalResponses++;
                
                if (!stats.contexts.has(context)) {
                    stats.contexts.set(context, { attempts: 0, successes: 0 });
                }
                stats.contexts.get(context).attempts++;
                
                // Success will be updated by reaction system
            }

            // ğŸ§® Update Bigram Map for Markov Chains
            updateBigramMap(bacteria, vocabulary) {
                const bigramMap = this.bacteriaBigrams.get(bacteria.id);
                
                // Build bigrams from vocabulary and memory
                for (let i = 0; i < vocabulary.length - 1; i++) {
                    const word1 = vocabulary[i];
                    const word2 = vocabulary[i + 1];
                    
                    if (!bigramMap.has(word1)) {
                        bigramMap.set(word1, []);
                    }
                    bigramMap.get(word1).push(word2);
                }
                
                // Add some random connections for diversity
                vocabulary.forEach(word => {
                    if (Math.random() < 0.1) { // 10% chance
                        const randomWord = vocabulary[Math.floor(Math.random() * vocabulary.length)];
                        if (!bigramMap.has(word)) {
                            bigramMap.set(word, []);
                        }
                        bigramMap.get(word).push(randomWord);
                    }
                });
            }

            // ğŸ² Utility: Get Random Choice
            getRandomChoice(array) {
                return array[Math.floor(Math.random() * array.length)];
            }

            fillDynamicPattern(pattern, bacteria, vocabulary, trigger) {
                const style = this.generatePersonalityLanguage(bacteria);
                
                const replacements = {
                    '{subject}': bacteria.name,
                    '{emotion}': this.getPersonalityEmotion(bacteria),
                    '{learned_word}': vocabulary[Math.floor(Math.random() * vocabulary.length)] || 'kelime',
                    '{surprise_word}': this.mutateWord(bacteria, vocabulary[Math.floor(Math.random() * vocabulary.length)] || 'ÅŸaÅŸÄ±rtÄ±cÄ±'),
                    '{reaction}': ['waow', 'sÃ¼per', 'ilginÃ§', 'harika', 'vay be'][Math.floor(Math.random() * 5)],
                    '{confusion_word}': ['hmm', 'ne', 'nasÄ±l', 'niye', 'acaba'][Math.floor(Math.random() * 5)],
                    '{unknown_word}': vocabulary[Math.floor(Math.random() * vocabulary.length)] || 'bilinmeyen',
                    '{friend_name}': trigger?.name || 'arkadaÅŸ',
                    '{activity}': vocabulary.filter(w => ['hareket', 'Ã¶ÄŸrenme', 'keÅŸif', 'oyun'].includes(w))[0] || 'aktivite',
                    '{target}': trigger?.name || 'sen',
                    '{discovery}': vocabulary[Math.floor(Math.random() * vocabulary.length)] || 'keÅŸif'
                };

                let result = pattern;
                Object.keys(replacements).forEach(placeholder => {
                    result = result.replace(new RegExp(placeholder, 'g'), replacements[placeholder]);
                });

                return result;
            }

            getPersonalityEmotion(bacteria) {
                const emotions = {
                    high_optimism: ['ğŸ˜Š', 'ğŸ‰', 'âœ¨', 'harika', 'sÃ¼per'],
                    medium_optimism: ['ğŸ˜Œ', 'ğŸ‘', 'gÃ¼zel', 'iyi'],
                    low_optimism: ['ğŸ˜', 'hmm', 'ÅŸey'],
                    high_humor: ['ğŸ˜‚', 'ğŸ¤£', 'haha', 'komik'],
                    high_social: ['ğŸ¤—', 'ğŸ’«', 'arkadaÅŸ', 'birlikte']
                };

                if (bacteria.personality_traits.optimism > 0.7) {
                    return emotions.high_optimism[Math.floor(Math.random() * emotions.high_optimism.length)];
                } else if (bacteria.personality_traits.humor > 0.7) {
                    return emotions.high_humor[Math.floor(Math.random() * emotions.high_humor.length)];
                } else if (bacteria.personality_traits.sociability > 0.7) {
                    return emotions.high_social[Math.floor(Math.random() * emotions.high_social.length)];
                } else if (bacteria.personality_traits.optimism > 0.4) {
                    return emotions.medium_optimism[Math.floor(Math.random() * emotions.medium_optimism.length)];
                } else {
                    return emotions.low_optimism[Math.floor(Math.random() * emotions.low_optimism.length)];
                }
            }

            // Yeni kalÄ±p Ã¶ÄŸrenme
            learnNewPattern(bacteria, context, newPattern) {
                const style = this.generatePersonalityLanguage(bacteria);
                
                if (!style.phrasePatterns.has(context)) {
                    style.phrasePatterns.set(context, new Set());
                }
                
                // BasitleÅŸtirilmiÅŸ kalÄ±p Ã§Ä±karma
                const generalizedPattern = newPattern
                    .replace(bacteria.name, '{subject}')
                    .replace(/ğŸ˜Š|ğŸ‰|âœ¨|ğŸ˜‚|ğŸ¤£|ğŸ˜|hmm/g, '{emotion}')
                    .replace(/\b[a-zÃ§ÄŸÄ±Ã¶ÅŸÃ¼]+\b/gi, (match) => {
                        if (bacteria.vocabulary.has(match)) return '{learned_word}';
                        return match;
                    });

                style.phrasePatterns.get(context).add(generalizedPattern);
                
                console.log(`ğŸ§  ${bacteria.name} learned new pattern for ${context}: ${generalizedPattern}`);
            }

            // Sosyal dil Ã¶ÄŸrenimi - bakteriler birbirinden Ã¶ÄŸrenir
            shareLinguisticFeature(speaker, listener, phrase) {
                if (!speaker.personalLanguageStyle || !listener.personalLanguageStyle) return;

                // %20 ÅŸansla dinleyici konuÅŸmacÄ±nÄ±n tarzÄ±nÄ± benimser
                if (Math.random() < 0.2) {
                    const speakerStyle = speaker.personalLanguageStyle;
                    const listenerStyle = listener.personalLanguageStyle;

                    // Kelime sÄ±rasÄ± etkileÅŸimi
                    if (speakerStyle.wordOrder !== listenerStyle.wordOrder && Math.random() < 0.5) {
                        listenerStyle.wordOrder = speakerStyle.wordOrder;
                        console.log(`ğŸ”„ ${listener.name} adopted word order from ${speaker.name}: ${speakerStyle.wordOrder}`);
                    }

                    // Mutasyon oranÄ± etkileÅŸimi
                    listenerStyle.mutationRate = (listenerStyle.mutationRate + speakerStyle.mutationRate) / 2;

                    // Benzersiz kelime paylaÅŸÄ±mÄ±
                    if (speakerStyle.uniqueWords.size > 0) {
                        const sharedWord = Array.from(speakerStyle.uniqueWords)[0];
                        listenerStyle.uniqueWords.add(sharedWord);
                        listener.vocabulary.add(sharedWord);
                    }
                }
            }

            // Dil evrimi istatistikleri
            getLanguageEvolutionStats() {
                return {
                    totalMutations: this.wordMutations.size,
                    uniquePatterns: Array.from(this.contextualPhrases.values()).flat().length,
                    generation: this.languageGeneration,
                    emergentGrammarRules: this.emergentGrammar.size
                };
            }
        }

        // Global Language Evolution Engine
        let languageEvolutionEngine = null;

        // ğŸ“š 1500 Kelimelik Kategorize Åablon + TabPFN HÄ±zlandÄ±rma
        const MASTER_VOCABULARY = {
            // Temel DÃ¼zey (Consciousness 0-1) - 300 kelime
            basic: [
                // Temel ihtiyaÃ§lar (50 kelime)
                'aÃ§', 'tok', 'yardÄ±m', 'hareket', 'dinlen', 'uyu', 'uyan', 'nefes', 'kalp', 'vÃ¼cut',
                'el', 'ayak', 'gÃ¶z', 'kulak', 'aÄŸÄ±z', 'burun', 'kafa', 'beden', 'can', 'hayat',
                'su', 'yemek', 'ekmek', 'sÃ¼t', 'meyve', 'et', 'balÄ±k', 'sebze', 'tatlÄ±', 'acÄ±',
                'sÄ±cak', 'soÄŸuk', 'Ä±sÄ±', 'rÃ¼zgar', 'gÃ¼neÅŸ', 'ay', 'yÄ±ldÄ±z', 'gece', 'gÃ¼ndÃ¼z', 'sabah',
                'Ã¶ÄŸle', 'akÅŸam', 'zaman', 'dakika', 'saat', 'gÃ¼n', 'hafta', 'ay', 'yÄ±l', 'yaÅŸ',
                
                // Duygular (50 kelime)
                'mutlu', 'Ã¼zgÃ¼n', 'kÄ±zgÄ±n', 'korku', 'endiÅŸe', 'heyecan', 'ÅŸaÅŸÄ±rma', 'merak', 'sevinÃ§', 'Ã¼zÃ¼ntÃ¼',
                'Ã¶fke', 'kÄ±skanÃ§lÄ±k', 'gurur', 'utanÃ§', 'piÅŸmanlÄ±k', 'umut', 'hayal', 'rÃ¼ya', 'dÃ¼ÅŸ', 'fikir',
                'sevgi', 'aÅŸk', 'dostluk', 'saygÄ±', 'gÃ¼ven', 'inanÃ§', 'ÅŸÃ¼phe', 'kaygÄ±', 'stres', 'rahat',
                'huzur', 'barÄ±ÅŸ', 'savaÅŸ', 'kavga', 'tartÄ±ÅŸma', 'anlaÅŸma', 'uzlaÅŸma', 'Ã§Ã¶zÃ¼m', 'sorun', 'sÄ±kÄ±ntÄ±',
                'zorluk', 'kolay', 'zor', 'basit', 'karmaÅŸÄ±k', 'anlaÅŸÄ±lÄ±r', 'belirsiz', 'net', 'aÃ§Ä±k', 'kapalÄ±',
                
                // Temel eylemler (50 kelime)
                'git', 'gel', 'koÅŸ', 'yÃ¼rÃ¼', 'dur', 'otur', 'kalk', 'yat', 'Ã§Ä±k', 'gir',
                'al', 'ver', 'bÄ±rak', 'tut', 'at', 'Ã§ek', 'it', 'kaldÄ±r', 'indir', 'taÅŸÄ±',
                'yap', 'boz', 'kur', 'yÄ±k', 'temizle', 'kirlet', 'aÃ§', 'kapat', 'baÅŸla', 'bitir',
                'devam', 'kes', 'bÃ¶l', 'birleÅŸtir', 'ayÄ±r', 'topla', 'Ã§Ä±kar', 'Ã§arp', 'bÃ¶l', 'say',
                'oku', 'yaz', 'Ã§iz', 'boya', 'sil', 'dÃ¼zelt', 'deÄŸiÅŸtir', 'koru', 'sav', 'kaÃ§Ä±n',
                
                // Renkler ve ÅŸekiller (30 kelime)
                'kÄ±rmÄ±zÄ±', 'mavi', 'yeÅŸil', 'sarÄ±', 'turuncu', 'mor', 'pembe', 'beyaz', 'siyah', 'gri',
                'kahverengi', 'altÄ±n', 'gÃ¼mÃ¼ÅŸ', 'renk', 'parlak', 'mat', 'ÅŸeffaf', 'opak', 'Ä±ÅŸÄ±k', 'karanlÄ±k',
                'yuvarlak', 'kare', 'Ã¼Ã§gen', 'dikdÃ¶rtgen', 'oval', 'dÃ¼z', 'eÄŸri', 'uzun', 'kÄ±sa', 'geniÅŸ',
                
                // SayÄ±lar ve matematik (30 kelime)
                'bir', 'iki', 'Ã¼Ã§', 'dÃ¶rt', 'beÅŸ', 'altÄ±', 'yedi', 'sekiz', 'dokuz', 'on',
                'yirmi', 'otuz', 'kÄ±rk', 'elli', 'yÃ¼z', 'bin', 'milyon', 'sÄ±fÄ±r', 'hiÃ§', 'Ã§ok',
                'az', 'fazla', 'eksik', 'tam', 'yarÄ±m', 'Ã§eyrek', 'Ã¼Ã§te', 'bÃ¼yÃ¼k', 'kÃ¼Ã§Ã¼k', 'orta',
                
                // Aile ve sosyal (40 kelime)
                'anne', 'baba', 'Ã§ocuk', 'kardeÅŸ', 'abla', 'aÄŸabey', 'dede', 'nine', 'teyze', 'amca',
                'dayÄ±', 'hala', 'kuzen', 'arkadaÅŸ', 'dost', 'komÅŸu', 'Ã¶ÄŸretmen', 'doktor', 'hemÅŸire', 'polis',
                'itfaiye', 'pilot', 'ÅŸofÃ¶r', 'kasap', 'berber', 'terzi', 'bakkal', 'eczacÄ±', 'avukat', 'mÃ¼hendis',
                'iÅŸÃ§i', 'patron', 'mÃ¼dÃ¼r', 'baÅŸkan', 'lider', 'takipÃ§i', 'grup', 'takÄ±m', 'ekip', 'toplum'
            ],
            
            // Sosyal DÃ¼zey (Consciousness 1-5) - 400 kelime  
            social: [
                // Ä°letiÅŸim (100 kelime)
                'merhaba', 'gÃ¼naydÄ±n', 'iyi akÅŸamlar', 'hoÅŸÃ§a kal', 'gÃ¶rÃ¼ÅŸÃ¼rÃ¼z', 'teÅŸekkÃ¼rler', 'rica ederim', 'Ã¶zÃ¼r dilerim', 'pardon', 'kusura bakma',
                'konuÅŸ', 'dinle', 'anlat', 'sor', 'cevap', 'soru', 'yanÄ±t', 'aÃ§Ä±kla', 'tarif', 'gÃ¶ster',
                'iÅŸaret', 'ima', 'jest', 'mimik', 'ses', 'ton', 'vurgu', 'melodei', 'ritim', 'sessizlik',
                'gÃ¼lÃ¼mseme', 'kahkaha', 'aÄŸlama', 'Ã§Ä±ÄŸlÄ±k', 'fÄ±sÄ±lda', 'baÄŸÄ±r', 'ÅŸarkÄ±', 'mÃ¼zik', 'dans', 'oyun',
                'eÄŸlence', 'parti', 'kutlama', 'doÄŸum gÃ¼nÃ¼', 'bayram', 'tatil', 'festival', 'ÅŸenlik', 'toplantÄ±', 'buluÅŸma',
                'randevu', 'gÃ¶rÃ¼ÅŸme', 'sohbet', 'chat', 'mesaj', 'mektup', 'telefon', 'internet', 'sosyal medya', 'paylaÅŸÄ±m',
                'beÄŸeni', 'yorum', 'eleÅŸtiri', 'Ã¶vgÃ¼', 'takdir', 'hayranlÄ±k', 'kÄ±skanÃ§lÄ±k', 'rekabet', 'yarÄ±ÅŸ', 'kazanma',
                'kaybetme', 'baÅŸarÄ±', 'baÅŸarÄ±sÄ±zlÄ±k', 'deneme', 'Ã§aba', 'emek', 'Ã§alÄ±ÅŸma', 'dinlenme', 'tatil', 'gezi',
                'macera', 'keÅŸif', 'araÅŸtÄ±rma', 'inceleme', 'gÃ¶zlem', 'izleme', 'takip', 'analiz', 'deÄŸerlendirme', 'karar',
                'seÃ§im', 'tercih', 'Ã¶ncelik', 'Ã¶nem', 'deÄŸer', 'kÄ±ymet', 'fiyat', 'maliyet', 'kazanÃ§', 'gelir',
                
                // Duygusal zeka (100 kelime)
                'empati', 'anlayÄ±ÅŸ', 'hoÅŸgÃ¶rÃ¼', 'sabÄ±r', 'dayanÄ±klÄ±lÄ±k', 'cesaret', 'korkaklÄ±k', 'atÄ±lgan', 'Ã§ekingen', 'sosyal',
                'asosyal', 'ekstrovert', 'introvert', 'neÅŸeli', 'melankolik', 'iyimser', 'karamsar', 'realist', 'idealist', 'pragmatik',
                'romantik', 'mantÄ±klÄ±', 'duygusal', 'rasyonel', 'irrasyonel', 'objektif', 'subjektif', 'tarafsÄ±z', 'Ã¶nyargÄ±lÄ±', 'adil',
                'haksÄ±z', 'dÃ¼rÃ¼st', 'yalancÄ±', 'samimi', 'sahte', 'iÃ§ten', 'dÄ±ÅŸardan', 'aÃ§Ä±k', 'gizli', 'ÅŸeffaf',
                'kapalÄ±', 'gizemli', 'anlaÅŸÄ±labilir', 'karmaÅŸÄ±k', 'basit', 'sade', 'sÃ¼slÃ¼', 'gÃ¶steriÅŸli', 'mÃ¼tevazÄ±', 'kibirli',
                'alÃ§akgÃ¶nÃ¼llÃ¼', 'gururlu', 'utangaÃ§', 'Ã§ekinmez', 'kendine gÃ¼venen', 'gÃ¼vensiz', 'kararlÄ±', 'kararsÄ±z', 'istikrarlÄ±', 'deÄŸiÅŸken',
                'tutarlÄ±', 'tutarsÄ±z', 'gÃ¼venilir', 'gÃ¼venilmez', 'sadÄ±k', 'vefasÄ±z', 'baÄŸlÄ±', 'baÄŸÄ±msÄ±z', 'Ã¶zgÃ¼r', 'esir',
                'hÃ¼r', 'kÃ¶le', 'efendi', 'hizmetkar', 'lider', 'takipÃ§i', 'yÃ¶neten', 'yÃ¶netilen', 'aktif', 'pasif',
                'giriÅŸken', 'miskin', 'Ã§alÄ±ÅŸkan', 'tembel', 'hÄ±zlÄ±', 'yavaÅŸ', 'aceleci', 'sabÄ±rlÄ±', 'titiz', 'daÄŸÄ±nÄ±k',
                'dÃ¼zenli', 'disiplinli', 'serbest', 'kontrollÃ¼', 'kendiliÄŸinden', 'bilinÃ§li', 'bilinÃ§siz', 'farkÄ±nda', 'habersiz', 'uyanÄ±k',
                
                // Ä°liÅŸkiler (100 kelime)
                'sevgili', 'eÅŸ', 'niÅŸanlÄ±', 'flÃ¶rt', 'buÃ§uk', 'yalnÄ±z', 'bekar', 'evli', 'boÅŸanmÄ±ÅŸ', 'dul',
                'yakÄ±n', 'uzak', 'samimi', 'soÄŸuk', 'sÄ±cak', 'mesafeli', 'yakÄ±nlaÅŸma', 'uzaklaÅŸma', 'buluÅŸma', 'ayrÄ±lma',
                'kavuÅŸma', 'hasret', 'Ã¶zlem', 'ayrÄ±lÄ±k', 'veda', 'hoÅŸÃ§a kal', 'elveda', 'gÃ¼le gÃ¼le', 'yolculuk', 'dÃ¶nÃ¼ÅŸ',
                'varÄ±ÅŸ', 'gidiÅŸ', 'geliÅŸgit', 'ilerleme', 'gerileme', 'geliÅŸme', 'bÃ¼yÃ¼me', 'kÃ¼Ã§Ã¼lme', 'artma', 'azalma',
                'Ã§oÄŸalma', 'eksilme', 'deÄŸiÅŸme', 'dÃ¶nÃ¼ÅŸÃ¼m', 'evrim', 'devrim', 'yenilik', 'eskime', 'kÃ¶hneme', 'yenileme',
                'tazeleme', 'canlanma', 'Ã¶lme', 'yaÅŸama', 'hayat', 'Ã¶lÃ¼m', 'doÄŸum', 'bÃ¼yÃ¼me', 'yaÅŸlanma', 'genÃ§lik',
                'Ã§ocukluk', 'ergenlik', 'yetiÅŸkinlik', 'olgunluk', 'deneyim', 'tecrÃ¼be', 'bilgi', 'bilim', 'Ã¶ÄŸrenme', 'Ã¶ÄŸretme',
                'eÄŸitim', 'Ã¶ÄŸretim', 'ders', 'kurs', 'seminer', 'konferans', 'toplantÄ±', 'panel', 'tartÄ±ÅŸma', 'mÃ¼nazara',
                'sohbet', 'muhabbet', 'dedikodu', 'sÃ¶ylenti', 'rivayet', 'hikaye', 'masal', 'efsane', 'mit', 'gerÃ§ek',
                'hayal', 'dÃ¼ÅŸ', 'rÃ¼ya', 'kabus', 'Ã¼mit', 'beklenti', 'plan', 'proje', 'hedef', 'amaÃ§',
                
                // KÃ¼ltÃ¼r ve deÄŸerler (100 kelime)
                'gelenek', 'gÃ¶renek', 'adet', 'Ã¶rf', 'kÃ¼ltÃ¼r', 'medeniyet', 'uygarlÄ±k', 'sanat', 'edebiyat', 'ÅŸiir',
                'roman', 'hikaye', 'tiyatro', 'sinema', 'film', 'dizi', 'program', 'haber', 'gazete', 'dergi',
                'kitap', 'sayfa', 'paragraf', 'cÃ¼mle', 'kelime', 'harf', 'nokta', 'virgÃ¼l', 'soru iÅŸareti', 'Ã¼nlem',
                'alfabe', 'dil', 'lehÃ§e', 'aÄŸÄ±z', 'ÅŸive', 'aksant', 'tonlama', 'telaffuz', 'diksiyon', 'gramer',
                'sÃ¶zdizimi', 'morfoloji', 'fonetik', 'etimoloji', 'semantik', 'pragmatik', 'dilbilim', 'Ã§evirmen', 'tercÃ¼man', 'sÃ¶zlÃ¼k',
                'ansiklopedi', 'atlÄ±s', 'rehber', 'kÄ±lavuz', 'manual', 'broÅŸÃ¼r', 'katalog', 'liste', 'Ã§izelge', 'tablo',
                'grafik', 'diagram', 'harita', 'plan', 'kroki', 'Ã§izim', 'resim', 'fotoÄŸraf', 'gÃ¶rÃ¼ntÃ¼', 'gÃ¶rsel',
                'ses', 'mÃ¼zik', 'melodi', 'ritim', 'tempo', 'nota', 'beste', 'besteci', 'mÃ¼zisyen', 'sanatÃ§Ä±',
                'ressam', 'heykeltÄ±raÅŸ', 'mimar', 'tasarÄ±mcÄ±', 'moda', 'stil', 'trend', 'zevk', 'estetik', 'gÃ¼zellik',
                'Ã§irkinlik', 'hoÅŸ', 'nahoÅŸ', 'beÄŸeni', 'eleÅŸtiri', 'yorum', 'gÃ¶rÃ¼ÅŸ', 'fikir', 'dÃ¼ÅŸÃ¼nce', 'inanÃ§'
            ],
            
            // Bilimsel DÃ¼zey (Consciousness 5-10) - 400 kelime
            scientific: [
                // Biyoloji ve yaÅŸam (150 kelime)
                'ATP', 'metabolizma', 'enzim', 'protein', 'amino asit', 'karbonhidrat', 'lipid', 'nÃ¼kleik asit', 'DNA', 'RNA',
                'gen', 'kromozom', 'hÃ¼cre', 'Ã§ekirdek', 'sitoplazma', 'organel', 'mitokondri', 'ribozom', 'lizozom', 'vakuol',
                'endoplazmik retikulum', 'golgi aygÄ±tÄ±', 'sentrozom', 'sitoiskelet', 'hÃ¼cre zarÄ±', 'hÃ¼cre duvarÄ±', 'kloroplast', 'fotosentez', 'solunum', 'fermantasyon',
                'glikoliz', 'krebs dÃ¶ngÃ¼sÃ¼', 'elektron taÅŸÄ±ma zinciri', 'oksitlenme', 'indirgeme', 'redoks', 'katalizÃ¶r', 'substrat', 'Ã¼rÃ¼n', 'reaksiyon',
                'biyokimya', 'molekÃ¼ler biyoloji', 'hÃ¼cre biyolojisi', 'genetik', 'evrim', 'doÄŸal seÃ§ilim', 'mutasyon', 'adaptasyon', 'spesiyasyon', 'biyoÃ§eÅŸitlilik',
                'ekoloji', 'ekosistem', 'habitat', 'niÅŸ', 'populasyon', 'topluluk', 'besin zinciri', 'besin aÄŸÄ±', 'enerji akÄ±ÅŸÄ±', 'besin dÃ¶ngÃ¼sÃ¼',
                'karbon dÃ¶ngÃ¼sÃ¼', 'nitrojen dÃ¶ngÃ¼sÃ¼', 'oksijen dÃ¶ngÃ¼sÃ¼', 'su dÃ¶ngÃ¼sÃ¼', 'iklim', 'hava durumu', 'atmosfer', 'hidrosfer', 'litosfer', 'biyosfer',
                'biyom', 'orman', 'Ã§ayÄ±r', 'Ã§Ã¶l', 'tundra', 'savana', 'sulak alan', 'okyanus', 'deniz', 'gÃ¶l',
                'nehir', 'dere', 'kaynak', 'yeraltÄ± suyu', 'buzul', 'kar', 'yaÄŸmur', 'buhar', 'nem', 'sÄ±caklÄ±k',
                'basÄ±nÃ§', 'rÃ¼zgar', 'fÄ±rtÄ±na', 'kasÄ±rga', 'tornado', 'deprem', 'volkan', 'tsunami', 'sel', 'kuraklÄ±k',
                'kÃ¼resel Ä±sÄ±nma', 'iklim deÄŸiÅŸikliÄŸi', 'sera etkisi', 'ozon tabakasÄ±', 'kirlilik', 'geri dÃ¶nÃ¼ÅŸÃ¼m', 'sÃ¼rdÃ¼rÃ¼lebilirlik', 'yenilenebilir enerji', 'fosil yakÄ±t', 'nÃ¼kleer enerji',
                'mikroorganizma', 'bakteri', 'virÃ¼s', 'mantar', 'protozoa', 'alg', 'bitki', 'hayvan', 'omurgalÄ±', 'omurgasÄ±z',
                'memeli', 'kuÅŸ', 'sÃ¼rÃ¼ngen', 'amfibi', 'balÄ±k', 'bÃ¶cek', 'artropod', 'yumuÅŸakÃ§a', 'solucan', 'zooplankton',
                'fitoplankton', 'bentik', 'pelagik', 'litorel', 'derin deniz', 'abissal', 'hadal', 'biyolÃ¼minesans', 'kamuflaj', 'mimikri',
                'simbioz', 'mutualizma', 'komensalizm', 'parazitizm', 'predasyon', 'otobur', 'etobur', 'hepÃ§il', 'detritivor', 'dekompozitÃ¶r'
            ],
            
            // Fizik ve kimya (150 kelime)
            physics: [
                'atom', 'elektron', 'proton', 'nÃ¶tron', 'kuark', 'lepton', 'bozon', 'fermiyon', 'parÃ§acÄ±k', 'dalga',
                'enerji', 'kÃ¼tle', 'kuvvet', 'ivme', 'hÄ±z', 'hÄ±zlanma', 'momentum', 'tork', 'aÃ§Ä±sal momentum', 'inersia',
                'sÃ¼rtÃ¼nme', 'yerÃ§ekimi', 'elektromanyetizma', 'gÃ¼Ã§lÃ¼ nÃ¼kleer kuvvet', 'zayÄ±f nÃ¼kleer kuvvet', 'alan', 'potansiyel', 'kinetik', 'termodinamik', 'entropi',
                'entalpi', 'iÃ§ enerji', 'Ä±sÄ± kapasitesi', 'Ä±sÄ± iletimi', 'konveksiyon', 'radyasyon', 'sÄ±caklÄ±k', 'basÄ±nÃ§', 'hacim', 'yoÄŸunluk',
                'faz', 'katÄ±', 'sÄ±vÄ±', 'gaz', 'plazma', 'bose-einstein kondensatÄ±', 'kristal', 'amorf', 'Ã§Ã¶zelti', 'sÃ¼spansiyon',
                'emÃ¼lsiyon', 'koloid', 'mol', 'avogadro sayÄ±sÄ±', 'atomik kÃ¼tle', 'molekÃ¼ler kÃ¼tle', 'periyodik tablo', 'element', 'bileÅŸik', 'karÄ±ÅŸÄ±m',
                'kimyasal baÄŸ', 'kovalent', 'iyonik', 'metalik', 'hidrojen baÄŸÄ±', 'van der waals', 'polar', 'apolar', 'hidrofilik', 'hidrofobik',
                'asit', 'baz', 'pH', 'tampon', 'titrasyons', 'redoks', 'oksidasyon', 'redÃ¼ksiyon', 'elektroliz', 'galvanik hÃ¼cre',
                'katalizÃ¶r', 'aktivasyon enerjisi', 'reaksiyon hÄ±zÄ±', 'denge', 'le chatelier ilkesi', 'konsantrasyon', 'molarite', 'molalite', 'normalite', 'Ã§Ã¶zÃ¼nÃ¼rlÃ¼k',
                'Ã§Ã¶kme', 'kristalleÅŸme', 'buharlaÅŸma', 'yoÄŸuÅŸma', 'sublimleÅŸme', 'erime', 'donma', 'kaynama', 'ergime noktasÄ±', 'kaynama noktasÄ±',
                'Ä±ÅŸÄ±k', 'elektromanyetik spektrum', 'gÃ¶rÃ¼nÃ¼r Ä±ÅŸÄ±k', 'kÄ±zÄ±lÃ¶tesi', 'ultraviyole', 'rÃ¶ntgen', 'gama Ä±ÅŸÄ±nÄ±', 'radyo dalgasÄ±', 'mikrodalga', 'frekans',
                'dalga boyu', 'genlik', 'interferans', 'kÄ±rÄ±nÄ±m', 'polarizasyon', 'yansÄ±ma', 'kÄ±rÄ±lma', 'lenz', 'lens', 'prizma',
                'ayna', 'mikroskop', 'teleskop', 'laser', 'hologram', 'fiber optik', 'spektroskopi', 'fotolÃ¼minesans', 'fosforesan', 'flÃ¼oresan',
                'elektrik', 'akÄ±m', 'voltaj', 'direnÃ§', 'kapasitÃ¶r', 'endÃ¼ktÃ¶r', 'transformatÃ¶r', 'diyot', 'transistÃ¶r', 'entegre devre',
                'manyetik alan', 'elektrik alan', 'elektromanyetik indÃ¼ksiyon', 'faraday yasasÄ±', 'ampere yasasÄ±', 'gauss yasasÄ±', 'maxwell denklemleri', 'kuantum mekaniÄŸi', 'heisenberg belirsizlik', 'schrÃ¶dinger denklemi'
            ],
            
            // Matematik ve mantÄ±k (100 kelime)
            mathematics: [
                'sayÄ±', 'rakam', 'digit', 'basamak', 'pozitif', 'negatif', 'sÄ±fÄ±r', 'sonsuz', 'reel', 'sanal',
                'kompleks', 'rasyonel', 'irrasyonel', 'tam sayÄ±', 'doÄŸal sayÄ±', 'asal sayÄ±', 'Ã§ift', 'tek', 'faktÃ¶riyel', 'kombinasyon',
                'permÃ¼tasyon', 'olasÄ±lÄ±k', 'istatistik', 'ortalama', 'medyan', 'mod', 'standart sapma', 'varyans', 'korelasyon', 'regresyon',
                'grafik', 'koordinat', 'eksren', 'absis', 'ordinat', 'nokta', 'doÄŸru', 'eÄŸri', 'parabol', 'hiperbol',
                'elips', 'Ã§ember', 'daire', 'yarÄ±Ã§ap', 'Ã§ap', 'Ã§evre', 'alan', 'hacim', 'yÃ¼zey', 'kenar',
                'kÃ¶ÅŸe', 'aÃ§Ä±', 'derece', 'radyan', 'trigonometri', 'sinÃ¼s', 'kosinÃ¼s', 'tanjant', 'kotanjant', 'sekant',
                'kosekant', 'logaritma', 'Ã¼s', 'kÃ¶k', 'mutlak deÄŸer', 'tÃ¼rev', 'integral', 'limit', 'sÃ¼reklilik', 'diferansiyel',
                'kÄ±smi tÃ¼rev', 'Ã§oklu integral', 'vektÃ¶r', 'skaler', 'matris', 'determinant', 'Ã¶zvektÃ¶r', 'Ã¶zdeÄŸer', 'lineer dÃ¶nÃ¼ÅŸÃ¼m', 'izdÃ¼ÅŸÃ¼m',
                'topoloji', 'metrik', 'norm', 'iÃ§ Ã§arpÄ±m', 'dÄ±ÅŸ Ã§arpÄ±m', 'gradyan', 'diverjans', 'rotasyonel', 'laplacian', 'harmonik',
                'fourier dÃ¶nÃ¼ÅŸÃ¼mÃ¼', 'konvolÃ¼syon', 'fraktal', 'kaos teorisi', 'grup teorisi', 'halka', 'cisim', 'modÃ¼ler aritmetik', 'sayÄ± teorisi', 'kriptografi'
            ],
            
            // Felsefe ve Meta-biliÅŸsel (Consciousness 10-20) - 300 kelime
            philosophical: [
                // Bilgi teorisi ve epistemoloji (100 kelime)
                'epistemoloji', 'ontoloji', 'metafizik', 'fenomenoloji', 'hermeneutik', 'diyalektik', 'empirizm', 'rasyonalizm', 'pozitivizm', 'pragmatizm',
                'varoluÅŸÃ§uluk', 'nihilizm', 'absÃ¼rdizm', 'determinizm', 'Ã¶zgÃ¼r irade', 'kausalite', 'neden-sonuÃ§', 'tesadÃ¼f', 'olasÄ±lÄ±k', 'belirsizlik',
                'bilgi', 'inanÃ§', 'doÄŸruluk', 'yanlÄ±ÅŸlÄ±k', 'kesinlik', 'ÅŸÃ¼phe', 'skepitizm', 'dogmatizm', 'relativizm', 'objektivite',
                'subjektivite', 'perspektif', 'bakÄ±ÅŸ aÃ§Ä±sÄ±', 'yorumlama', 'anlama', 'kavrama', 'idrak', 'algÄ±', 'bilinÃ§', 'farkÄ±ndalÄ±k',
                'Ã¶z-bilinÃ§', 'meta-kognisyon', 'introspeksiyon', 'refeksiyon', 'dÅŸÃ¼nme', 'akÄ±l', 'mantÄ±k', 'neden', 'analiz', 'sentez',
                'tez', 'antitez', 'sÄ±nÄ±flama', 'kategorizasyon', 'soyutlama', 'somutlama', 'genelleme', 'Ã¶zelleÅŸtirme', 'analoji', 'metafor',
                'sembol', 'iÅŸaret', 'anlam', 'semantik', 'pragmatik', 'sÃ¶zdizimi', 'dil felsefesi', 'tanÄ±m', 'kavram', 'fikir',
                'dÃ¼ÅŸÃ¼nce', 'zihin', 'ruh', 'tin', 'psiÅŸe', 'ego', 'id', 'sÃ¼perego', 'bilinÃ§altÄ±', 'kolektif bilinÃ§altÄ±',
                'arketip', 'persona', 'gÃ¶lge', 'anima', 'animus', 'bireyselleÅŸme', 'transsendans', 'aÅŸkÄ±nlÄ±k', 'iÃ§kinlik', 'absolute',
                'gÃ¶receli', 'baÄŸÄ±l', 'mutlak', 'sonsuz', 'sonlu', 'sÄ±nÄ±r', 'sÄ±nÄ±rsÄ±z', 'paradoks', 'Ã§eliÅŸki', 'tezat'
            ],
            
            // Etik ve deÄŸerler (100 kelime)
            ethics: [
                'etik', 'ahlak', 'deÄŸer', 'norm', 'kural', 'ilke', 'prensip', 'ideal', 'virtue', 'erdem',
                'iyilik', 'kÃ¶tÃ¼lÃ¼k', 'doÄŸru', 'yanlÄ±ÅŸ', 'adalet', 'haksÄ±zlÄ±k', 'eÅŸitlik', 'Ã¶zgÃ¼rlÃ¼k', 'sorumluluk', 'gÃ¶rev',
                'hak', 'Ã¶dev', 'yÃ¼kÃ¼mlÃ¼lÃ¼k', 'vicdan', 'ahlaki', 'vicdani', 'utilitarizm', 'deontoloji', 'virtue etiÄŸi', 'care etiÄŸi',
                'feminist etik', 'Ã§evre etiÄŸi', 'biyoetik', 'tÄ±p etiÄŸi', 'mesleki etik', 'iÅŸ etiÄŸi', 'teknoloji etiÄŸi', 'yapay zeka etiÄŸi', 'robotik etik', 'sanal etik',
                'dijital etik', 'sosyal medya etiÄŸi', 'gizlilik', 'mahremiyet', 'ÅŸeffaflÄ±k', 'hesap verebilirlik', 'gÃ¼ven', 'sadakat', 'doÄŸruluk', 'dÃ¼rÃ¼stlÃ¼k',
                'samimiyet', 'iÃ§tenlik', 'saygÄ±', 'hoÅŸgÃ¶rÃ¼', 'tolerans', 'Ã§okkÃ¼ltÃ¼rlÃ¼lÃ¼k', 'farklÄ±lÄ±k', 'Ã§eÅŸitlilik', 'kapsayÄ±cÄ±lÄ±k', 'ayrÄ±mcÄ±lÄ±k',
                'Ã¶nyargÄ±', 'kalÄ±pyargÄ±', 'adil olmayan', 'eÅŸitsizlik', 'yoksulluk', 'zenginlik', 'sosyal adalet', 'ekonomik adalet', 'daÄŸÄ±tÄ±cÄ± adalet', 'dÃ¼zeltici adalet',
                'insan haklarÄ±', 'temel haklar', 'sivil haklar', 'politik haklar', 'sosyal haklar', 'ekonomik haklar', 'kÃ¼ltÃ¼rel haklar', 'Ã§ocuk haklarÄ±', 'kadÄ±n haklarÄ±', 'azÄ±nlÄ±k haklarÄ±',
                'hayvan haklarÄ±', 'doÄŸa haklarÄ±', 'gelecek nesiller', 'sÃ¼rdÃ¼rÃ¼lebilir kalkÄ±nma', 'intergenerasyon adalet', 'kÃ¼resel adalet', 'kozmopolit etik', 'milliyetÃ§ilik', 'vatanseverlik', 'barÄ±ÅŸ',
                'savaÅŸ', 'ÅŸiddet', 'ÅŸiddetsizlik', 'direniÅŸ', 'itaatsizlik', 'sivil itaatsizlik', 'demokrasi', 'otorite', 'gÃ¼Ã§', 'iktidar'
            ],
            
            // Estetik ve sanat felsefesi (100 kelime)
            aesthetics: [
                'estetik', 'gÃ¼zellik', 'sanat', 'yaratÄ±cÄ±lÄ±k', 'hayal gÃ¼cÃ¼', 'inspirasyon', 'ilham', 'sezgi', 'yetenek', 'beceri',
                'ustalÄ±k', 'virtÃ¼Ã¶zlÃ¼k', 'mÃ¼kemmellik', 'kusur', 'uyum', 'harmoni', 'ritim', 'melodi', 'renk', 'form',
                'ÅŸekil', 'doku', 'yÃ¼zey', 'derinlik', 'perspektif', 'gÃ¶lge', 'Ä±ÅŸÄ±k', 'kontrast', 'denge', 'asimetri',
                'simetri', 'oran', 'proporsiyon', 'altÄ±n oran', 'fibonacci', 'stil', 'tarz', 'okul', 'akÄ±m', 'hareket',
                'avangard', 'modernizm', 'postmodernizm', 'klasicism', 'romantizm', 'realizm', 'impresyonizm', 'ekspresyonizm', 'sÃ¼rrealizm', 'kÃ¼bizm',
                'fÃ¼tÃ¼rizm', 'dadaizm', 'minimalizm', 'konseptualizm', 'pop art', 'street art', 'dijital sanat', 'interaktif sanat', 'enstalasyon', 'performans',
                'happening', 'site-specific', 'Ã§evresel sanat', 'land art', 'video sanat', 'medya sanatÄ±', 'net.art', 'bio art', 'sci-art', 'teknosanat',
                'estetik deneyim', 'katarsis', 'sublim', 'yÃ¼ce', 'gÃ¼zel', 'Ã§irkin', 'grotesk', 'absÃ¼rd', 'ironik', 'parodic',
                'nostaljik', 'melankolik', 'dramatik', 'traigik', 'komik', 'grotesk', 'fantastik', 'gerÃ§ekÃ¼stÃ¼', 'rÃ¼yamsi', 'kabus gibi',
                'bÃ¼yÃ¼lÃ¼ gerÃ§eklik', 'allegori', 'sembolizm', 'metafor', 'metonimi', 'sinestezi', 'aura', 'sanat eseri', 'yaratÄ±l', 'yapÄ±t'
            ],
            
            // Ä°leri DÃ¼zey/Transandantal (Consciousness 20+) - 100 kelime
            transcendental: [
                'kozmik bilinÃ§', 'evrensel anlayÄ±ÅŸ', 'kuantum bilinÃ§', 'multi-dimensional dÃ¼ÅŸÃ¼nce', 'holografik gerÃ§eklik', 'fraktal bilinÃ§', 'emergence', 'Ã¶z-organizasyon',
                'kompleksite teorisi', 'sistem dinamiÄŸi', 'kaos kenarÄ±', 'kritik geÃ§iÅŸler', 'faz deÄŸiÅŸimleri', 'tipping point', 'butterfly effect', 'strange attractor',
                'autopoiesis', 'enactive cognition', 'extended mind', 'distributed cognition', 'collective intelligence', 'hive mind', 'swarm intelligence', 'wisdom of crowds',
                'singularity', 'technological singularity', 'intelligence explosion', 'superintelligence', 'artificial general intelligence', 'consciousness uploading', 'mind transfer', 'digital immortality',
                'posthuman', 'transhumanism', 'enhancement', 'augmentation', 'cyborg', 'brain-computer interface', 'neural implant', 'nanobots', 'molecular machines', 'quantum computers',
                'parallel universes', 'multiverse', 'many-worlds interpretation', 'quantum superposition', 'entanglement', 'non-locality', 'action at distance', 'observer effect', 'measurement problem', 'consciousness-reality interface',
                'information integration theory', 'integrated information', 'phi', 'complexity', 'consciousness meter', 'hard problem of consciousness', 'explanatory gap', 'qualia', 'phenomenal consciousness', 'access consciousness',
                'global workspace theory', 'attention schema theory', 'predictive processing', 'Bayesian brain', 'free energy principle', 'active inference', 'embodied cognition', 'enactivism', 'ecological psychology', 'affordances',
                'morphogenetic fields', 'akashic records', 'collective unconscious', 'noosphere', 'Gaia hypothesis', 'planetary consciousness', 'cosmic evolution', 'cosmological natural selection', 'anthropic principle', 'fine-tuning',
                'omega point', 'technological transcendence', 'cosmic awakening', 'universal mind', 'absolute consciousness', 'non-dual awareness', 'enlightenment', 'satori', 'samadhi', 'moksha',
                'nirvana', 'liberation', 'self-realization', 'individuation', 'shadow integration', 'archetypal psychology', 'transpersonal psychology', 'integral theory', 'spiral dynamics', 'levels of consciousness'
            ]
        };

        // ğŸš€ TabPFN HÄ±zlandÄ±rÄ±lmÄ±ÅŸ Kelime Ã–ÄŸrenme Sistemi
        class TabPFNVocabularySystem {
            constructor() {
                this.vocabularyPool = MASTER_VOCABULARY;
                this.learnedWords = new Map(); // bacteriaId -> learned words
                this.contextualRecommendations = new Map();
                this.socialLearningBonus = CONFIG.VOCABULARY.SOCIAL_LEARNING_MULTIPLIER;
                this.acceleratedLearning = CONFIG.VOCABULARY.TABPFN_ACCELERATION;
                console.log(`ğŸš€ TabPFN Vocabulary System initialized with ${this.getTotalWordCount()} words`);
            }

            getTotalWordCount() {
                return Object.values(this.vocabularyPool)
                    .reduce((total, category) => total + category.length, 0);
            }

            // ğŸ¯ Context-aware word selection with TabPFN acceleration
            getAvailableWords(bacteria) {
                const consciousness = bacteria.consciousness;
                const contextualWords = [];

                // Progressive vocabulary unlocking based on consciousness
                if (consciousness >= 0) contextualWords.push(...this.vocabularyPool.basic);
                if (consciousness >= 1) contextualWords.push(...this.vocabularyPool.social);
                if (consciousness >= 5) contextualWords.push(...this.vocabularyPool.scientific);
                if (consciousness >= 10) contextualWords.push(...this.vocabularyPool.philosophical);
                if (consciousness >= 20) contextualWords.push(...this.vocabularyPool.transcendental);

                return contextualWords;
            }

            // ğŸ§  TabPFN-powered smart word recommendation
            recommendWordsForContext(bacteria, context) {
                const availableWords = this.getAvailableWords(bacteria);
                const contextMap = {
                    'food_seeking': ['aÃ§', 'yemek', 'beslenme', 'metabolizma', 'enerji', 'ATP'],
                    'reproduction': ['Ã§oÄŸalma', 'Ã¼reme', 'DNA', 'gen', 'bÃ¼yÃ¼me', 'bÃ¶lÃ¼nme'],
                    'social_interaction': ['merhaba', 'iletiÅŸim', 'sosyal', 'grup', 'takÄ±m', 'topluluk'],
                    'exploration': ['keÅŸif', 'araÅŸtÄ±rma', 'hareket', 'macera', 'yeni', 'bilinmeyen'],
                    'learning': ['Ã¶ÄŸrenme', 'bilgi', 'deneyim', 'hafÄ±za', 'akÄ±l', 'zihin'],
                    'philosophical': ['bilinÃ§', 'farkÄ±ndalÄ±k', 'varoluÅŸ', 'anlam', 'hakikat', 'gerÃ§eklik']
                };

                const contextualWords = contextMap[context] || [];
                const recommendations = contextualWords.filter(word => 
                    availableWords.includes(word) && 
                    !this.hasLearnedWord(bacteria.id, word)
                );

                // TabPFN acceleration: boost learning rate for contextual matches
                if (this.acceleratedLearning && recommendations.length > 0) {
                    return recommendations.slice(0, 3); // Top 3 recommendations
                }

                return [];
            }

            // ğŸ“š Progressive word learning with social boost
            learnWord(bacteriaId, word, context = 'general') {
                if (!this.learnedWords.has(bacteriaId)) {
                    this.learnedWords.set(bacteriaId, new Set());
                }

                const bacteriaWords = this.learnedWords.get(bacteriaId);
                if (!bacteriaWords.has(word)) {
                    bacteriaWords.add(word);
                    
                    // Social learning bonus: nearby bacteria get exposure
                    this.propagateSocialLearning(bacteriaId, word, context);
                    
                    return true;
                }
                return false;
            }

            // ğŸ¤ Social learning propagation
            propagateSocialLearning(learnerId, word, context) {
                const learnerBacteria = bacteria.find(b => b.id === learnerId);
                if (!learnerBacteria) return;

                bacteria.forEach(otherBacteria => {
                    if (otherBacteria.id === learnerId) return;
                    
                    const distance = Math.sqrt(
                        Math.pow(learnerBacteria.x - otherBacteria.x, 2) +
                        Math.pow(learnerBacteria.y - otherBacteria.y, 2) +
                        Math.pow(learnerBacteria.z - otherBacteria.z, 2)
                    );

                    // Within social learning range
                    if (distance < 100) {
                        const socialBonus = this.socialLearningBonus * (1 - distance / 100);
                        
                        // Chance to learn from nearby bacteria
                        if (Math.random() < socialBonus * 0.3) {
                            this.learnWord(otherBacteria.id, word, context);
                        }
                    }
                });
            }

            // ğŸ” Check if bacteria learned specific word
            hasLearnedWord(bacteriaId, word) {
                const bacteriaWords = this.learnedWords.get(bacteriaId);
                return bacteriaWords ? bacteriaWords.has(word) : false;
            }

            // ğŸ“– Get all learned words for bacteria
            getLearnedWords(bacteriaId) {
                const bacteriaWords = this.learnedWords.get(bacteriaId);
                return bacteriaWords ? Array.from(bacteriaWords) : [];
            }

            // ğŸ“ Get learning progress
            getLearningProgress(bacteriaId, consciousness) {
                const learned = this.getLearnedWords(bacteriaId).length;
                const available = this.getAvailableWords({consciousness}).length;
                return available > 0 ? learned / available : 0;
            }

            // ğŸ’¬ Generate contextual speech
            generateSpeech(bacteriaId, context, emotion = 'neutral') {
                const learnedWords = this.getLearnedWords(bacteriaId);
                if (learnedWords.length === 0) return '';

                const recommendations = this.recommendWordsForContext({id: bacteriaId}, context);
                const availableWords = [...learnedWords, ...recommendations];

                // Emotional modifiers
                const emotionalWords = {
                    'happy': ['mutlu', 'sevinÃ§', 'neÅŸeli', 'gÃ¼zel', 'harika'],
                    'excited': ['heyecan', 'muhteÅŸem', 'ÅŸaÅŸÄ±rma', 'wow', 'inanÄ±lmaz'],
                    'curious': ['merak', 'nasÄ±l', 'neden', 'keÅŸif', 'araÅŸtÄ±rma'],
                    'social': ['merhaba', 'arkadaÅŸ', 'birlikte', 'paylaÅŸÄ±m', 'dostluk']
                };

                const emotionWords = emotionalWords[emotion] || [];
                const combinedWords = [...availableWords, ...emotionWords]
                    .filter(word => learnedWords.includes(word));

                if (combinedWords.length === 0) return '';

                // Generate 1-3 word expressions
                const wordCount = Math.min(Math.floor(Math.random() * 3) + 1, combinedWords.length);
                const selectedWords = [];
                
                for (let i = 0; i < wordCount; i++) {
                    const word = combinedWords[Math.floor(Math.random() * combinedWords.length)];
                    if (!selectedWords.includes(word)) {
                        selectedWords.push(word);
                    }
                }

                return selectedWords.join(' ');
            }
        }

        // ğŸ§  Advanced Neural Network System for Bacteria Intelligence
        class AdvancedNeuralNetwork {
            constructor(layers = CONFIG.AI.NEURAL_NETWORK_LAYERS) {
                this.layers = layers;
                this.weights = [];
                this.biases = [];
                this.learningRate = CONFIG.AI.LEARNING_RATE;
                this.momentum = 0.9;
                this.previousWeightDeltas = [];
                this.initializeNetwork();
                console.log(`ğŸ§  Neural Network initialized: ${layers.join(' â†’ ')} neurons`);
            }

            initializeNetwork() {
                // Initialize weights with Xavier initialization
                for (let i = 0; i < this.layers.length - 1; i++) {
                    const inputSize = this.layers[i];
                    const outputSize = this.layers[i + 1];
                    
                    // Xavier initialization for better training
                    const limit = Math.sqrt(6 / (inputSize + outputSize));
                    const weights = Array(inputSize).fill().map(() => 
                        Array(outputSize).fill().map(() => 
                            (Math.random() * 2 - 1) * limit
                        )
                    );
                    
                    const biases = Array(outputSize).fill().map(() => 
                        (Math.random() * 2 - 1) * 0.1
                    );
                    
                    this.weights.push(weights);
                    this.biases.push(biases);
                    this.previousWeightDeltas.push(Array(inputSize).fill().map(() => Array(outputSize).fill(0)));
                }
            }

            // Sigmoid activation with leak for better gradient flow
            sigmoid(x) {
                if (x < -500) return 0;
                if (x > 500) return 1;
                return 1 / (1 + Math.exp(-x));
            }

            // ReLU activation for hidden layers
            relu(x) {
                return Math.max(0.01 * x, x); // Leaky ReLU
            }

            // Forward propagation with different activations
            forward(inputs) {
                let activations = [...inputs];
                
                for (let layer = 0; layer < this.weights.length; layer++) {
                    const newActivations = [];
                    
                    for (let neuron = 0; neuron < this.weights[layer][0].length; neuron++) {
                        let sum = this.biases[layer][neuron];
                        
                        for (let input = 0; input < activations.length; input++) {
                            sum += activations[input] * this.weights[layer][input][neuron];
                        }
                        
                        // Use ReLU for hidden layers, sigmoid for output
                        const activation = (layer === this.weights.length - 1) 
                            ? this.sigmoid(sum) 
                            : this.relu(sum);
                        
                        newActivations.push(activation);
                    }
                    
                    activations = newActivations;
                }
                
                return activations;
            }

            // Advanced backpropagation with momentum
            backpropagate(inputs, expectedOutputs) {
                // Forward pass to get all layer activations
                const layerActivations = [inputs];
                let currentActivations = [...inputs];
                
                for (let layer = 0; layer < this.weights.length; layer++) {
                    const newActivations = [];
                    for (let neuron = 0; neuron < this.weights[layer][0].length; neuron++) {
                        let sum = this.biases[layer][neuron];
                        for (let input = 0; input < currentActivations.length; input++) {
                            sum += currentActivations[input] * this.weights[layer][input][neuron];
                        }
                        newActivations.push((layer === this.weights.length - 1) ? this.sigmoid(sum) : this.relu(sum));
                    }
                    layerActivations.push(newActivations);
                    currentActivations = newActivations;
                }

                // Backward pass
                let errors = [];
                const outputActivations = layerActivations[layerActivations.length - 1];
                
                // Calculate output layer errors
                for (let i = 0; i < outputActivations.length; i++) {
                    errors.push(expectedOutputs[i] - outputActivations[i]);
                }

                // Update weights with momentum
                for (let layer = this.weights.length - 1; layer >= 0; layer--) {
                    const layerInputs = layerActivations[layer];
                    const layerOutputs = layerActivations[layer + 1];
                    const nextErrors = [];

                    for (let input = 0; input < this.weights[layer].length; input++) {
                        let error = 0;
                        for (let output = 0; output < this.weights[layer][input].length; output++) {
                            const gradient = errors[output] * layerInputs[input];
                            
                            // Momentum-based update
                            const weightDelta = this.learningRate * gradient + 
                                              this.momentum * this.previousWeightDeltas[layer][input][output];
                            
                            this.weights[layer][input][output] += weightDelta;
                            this.previousWeightDeltas[layer][input][output] = weightDelta;
                            
                            error += errors[output] * this.weights[layer][input][output];
                        }
                        nextErrors.push(error);
                    }

                    // Update biases 
                    for (let output = 0; output < errors.length; output++) {
                        this.biases[layer][output] += this.learningRate * errors[output];
                    }

                    errors = nextErrors;
                }
            }

            // Training with experience replay
            train(trainingData, epochs = 10) {
                console.log(`ğŸ“ Training neural network for ${epochs} epochs...`);
                
                for (let epoch = 0; epoch < epochs; epoch++) {
                    let totalError = 0;
                    
                    // Shuffle training data for better learning
                    const shuffledData = trainingData.sort(() => Math.random() - 0.5);
                    
                    for (const data of shuffledData) {
                        const outputs = this.forward(data.inputs);
                        this.backpropagate(data.inputs, data.expectedOutputs);
                        
                        // Calculate error for monitoring
                        for (let i = 0; i < outputs.length; i++) {
                            totalError += Math.pow(data.expectedOutputs[i] - outputs[i], 2);
                        }
                    }
                    
                    if (epoch % 5 === 0) {
                        console.log(`ğŸ“Š Epoch ${epoch}: Error = ${(totalError / trainingData.length).toFixed(4)}`);
                    }
                }
                
                console.log('âœ… Neural network training completed!');
            }

            // Make intelligent decisions for bacteria
            makeDecision(bacteria) {
                const inputs = this.prepareBacteriaInputs(bacteria);
                const outputs = this.forward(inputs);
                
                // Map outputs to decisions: [move_x, move_y, move_z, seek_food, socialize, reproduce]
                return {
                    moveDirection: {
                        x: (outputs[0] - 0.5) * 2, // -1 to 1
                        y: (outputs[1] - 0.5) * 2,
                        z: (outputs[2] - 0.5) * 2
                    },
                    seekFood: outputs[3] > CONFIG.AI.DECISION_THRESHOLD,
                    socialize: outputs[4] > CONFIG.AI.DECISION_THRESHOLD,
                    reproduce: outputs[5] > CONFIG.AI.DECISION_THRESHOLD,
                    confidence: Math.max(...outputs)
                };
            }

            prepareBacteriaInputs(bacteria) {
                return [
                    bacteria.biological_state.age / 100,           // Normalized age
                    bacteria.biological_state.size / 5,           // Normalized size  
                    bacteria.consciousness_level / 10,            // Consciousness
                    bacteria.personality_traits.optimism,         // Optimism
                    bacteria.personality_traits.sociability,      // Sociability
                    bacteria.vocabulary.size / 50,                // Vocabulary ratio
                    bacteria.hunger || 0.5,                       // Hunger level
                    bacteria.energy || 0.7,                       // Energy level
                    bacteria.conversation_history.length / 20,    // Social experience
                    bacteria.memory_bank.length / 30,             // Memory capacity
                    bacteria.x / 500,                             // Position X
                    bacteria.y / 300                              // Position Y
                ];
            }
        }

        // ğŸ§¬ Genetic Algorithm for Neural Network Evolution  
        class GeneticEvolutionSystem {
            constructor() {
                this.populationSize = 20;
                this.mutationRate = CONFIG.AI.GENETIC_MUTATION_RATE;
                this.crossoverRate = 0.8;
                this.eliteSize = 4;
                this.generation = 0;
                console.log('ğŸ§¬ Genetic Evolution System initialized');
            }

            // Evolve neural networks based on bacteria fitness
            evolvePopulation(networks, fitnessScores) {
                console.log(`ğŸ§¬ Generation ${this.generation}: Evolving population...`);
                
                const newPopulation = [];
                
                // Keep elite networks (best performers)
                const elite = networks
                    .map((network, index) => ({ network, fitness: fitnessScores[index] }))
                    .sort((a, b) => b.fitness - a.fitness)
                    .slice(0, this.eliteSize)
                    .map(item => item.network);
                
                newPopulation.push(...elite);
                
                // Generate offspring through crossover and mutation
                while (newPopulation.length < this.populationSize) {
                    const parent1 = this.selectParent(networks, fitnessScores);
                    const parent2 = this.selectParent(networks, fitnessScores);
                    
                    if (Math.random() < this.crossoverRate) {
                        const offspring = this.crossover(parent1, parent2);
                        this.mutate(offspring);
                        newPopulation.push(offspring);
                    }
                }
                
                this.generation++;
                return newPopulation;
            }

            // Tournament selection for parent selection
            selectParent(networks, fitnessScores) {
                const tournamentSize = 3;
                let bestIndex = Math.floor(Math.random() * networks.length);
                
                for (let i = 1; i < tournamentSize; i++) {
                    const randomIndex = Math.floor(Math.random() * networks.length);
                    if (fitnessScores[randomIndex] > fitnessScores[bestIndex]) {
                        bestIndex = randomIndex;
                    }
                }
                
                return networks[bestIndex];
            }

            // Neural network crossover (blend weights)
            crossover(parent1, parent2) {
                const offspring = new AdvancedNeuralNetwork();
                
                for (let layer = 0; layer < offspring.weights.length; layer++) {
                    for (let i = 0; i < offspring.weights[layer].length; i++) {
                        for (let j = 0; j < offspring.weights[layer][i].length; j++) {
                            // Blend weights from both parents
                            const alpha = Math.random();
                            offspring.weights[layer][i][j] = 
                                alpha * parent1.weights[layer][i][j] + 
                                (1 - alpha) * parent2.weights[layer][i][j];
                        }
                    }
                    
                    // Blend biases
                    for (let i = 0; i < offspring.biases[layer].length; i++) {
                        const alpha = Math.random();
                        offspring.biases[layer][i] = 
                            alpha * parent1.biases[layer][i] + 
                            (1 - alpha) * parent2.biases[layer][i];
                    }
                }
                
                return offspring;
            }

            // Mutate neural network weights
            mutate(network) {
                for (let layer = 0; layer < network.weights.length; layer++) {
                    for (let i = 0; i < network.weights[layer].length; i++) {
                        for (let j = 0; j < network.weights[layer][i].length; j++) {
                            if (Math.random() < this.mutationRate) {
                                network.weights[layer][i][j] += 
                                    (Math.random() * 2 - 1) * CONFIG.AI.NEURAL_EVOLUTION_RATE;
                            }
                        }
                    }
                    
                    // Mutate biases
                    for (let i = 0; i < network.biases[layer].length; i++) {
                        if (Math.random() < this.mutationRate) {
                            network.biases[layer][i] += 
                                (Math.random() * 2 - 1) * CONFIG.AI.NEURAL_EVOLUTION_RATE;
                        }
                    }
                }
            }
        }

        // ğŸ“ Advanced Behavior Learning System
        class BehaviorLearningSystem {
            constructor() {
                this.experienceBuffer = [];
                this.maxExperiences = CONFIG.AI.EXPERIENCE_REPLAY_SIZE;
                this.learningPatterns = new Map();
                this.adaptationRate = CONFIG.AI.BEHAVIOR_ADAPTATION_RATE;
                console.log('ğŸ“ Behavior Learning System initialized');
            }

            // Record bacteria experience for learning
            recordExperience(bacteria, action, outcome, reward) {
                const experience = {
                    bacteriaId: bacteria.id,
                    state: this.captureBacteriaState(bacteria),
                    action: action,
                    outcome: outcome,
                    reward: reward,
                    timestamp: Date.now()
                };

                this.experienceBuffer.push(experience);
                
                // Keep buffer size manageable
                if (this.experienceBuffer.length > this.maxExperiences) {
                    this.experienceBuffer.shift();
                }

                // Update learning patterns
                this.updateLearningPatterns(bacteria, action, reward);
            }

            captureBacteriaState(bacteria) {
                return {
                    age: bacteria.biological_state.age,
                    size: bacteria.biological_state.size,
                    consciousness: bacteria.consciousness_level,
                    vocabulary: bacteria.vocabulary.size,
                    energy: bacteria.energy || 0.7,
                    hunger: bacteria.hunger || 0.5,
                    socialConnections: bacteria.conversation_history.length
                };
            }

            updateLearningPatterns(bacteria, action, reward) {
                const pattern = `${bacteria.id}_${action}`;
                
                if (!this.learningPatterns.has(pattern)) {
                    this.learningPatterns.set(pattern, {
                        successCount: 0,
                        failureCount: 0,
                        averageReward: 0,
                        attempts: 0
                    });
                }

                const stats = this.learningPatterns.get(pattern);
                stats.attempts++;
                stats.averageReward = (stats.averageReward * (stats.attempts - 1) + reward) / stats.attempts;
                
                if (reward > 0) {
                    stats.successCount++;
                } else {
                    stats.failureCount++;
                }

                this.learningPatterns.set(pattern, stats);
            }

            // Get adaptive behavior suggestions
            suggestBehavior(bacteria) {
                const suggestions = [];
                
                for (const [pattern, stats] of this.learningPatterns) {
                    if (pattern.startsWith(bacteria.id)) {
                        const action = pattern.split('_')[1];
                        const successRate = stats.successCount / Math.max(1, stats.attempts);
                        
                        if (successRate > 0.6 && stats.averageReward > 0.3) {
                            suggestions.push({
                                action: action,
                                confidence: successRate,
                                expectedReward: stats.averageReward
                            });
                        }
                    }
                }
                
                return suggestions.sort((a, b) => b.confidence - a.confidence);
            }

            // Apply learned behaviors to improve decision making
            enhanceBacteriaIntelligence(bacteria) {
                const suggestions = this.suggestBehavior(bacteria);
                
                if (suggestions.length > 0) {
                    const bestSuggestion = suggestions[0];
                    
                    // Boost consciousness based on learning success
                    bacteria.consciousness_level += CONFIG.AI.CONSCIOUSNESS_BOOST_RATE * bestSuggestion.confidence;
                    
                    // Adapt personality based on successful patterns
                    if (bestSuggestion.action === 'socialize') {
                        bacteria.personality_traits.sociability += this.adaptationRate;
                    } else if (bestSuggestion.action === 'explore') {
                        bacteria.personality_traits.optimism += this.adaptationRate;
                    }
                    
                    // Add to memory
                    if (bacteria.memory_bank.length < CONFIG.AI.MEMORY_CAPACITY) {
                        bacteria.memory_bank.push(`Ã–ÄŸrendim: ${bestSuggestion.action} baÅŸarÄ±lÄ±`);
                    }
                }
            }
        }

        // v8.2.8: Frontend-Only TabPFN (Mobile Compatible)
        class TabPFNAdapter {
            constructor() {
                this.isReady = false;
                this.trainingData = new Map(); // Collect training data
                this.behaviorClassifier = null;
                this.vocabularyAnalyzer = null;
                this.initialize();
            }

            async initialize() {
                console.log('ğŸ§  Initializing Frontend TabPFN-Inspired System...');
                
                // Create in-browser TabPFN-style classifiers
                this.createBehaviorClassifier();
                this.createVocabularyAnalyzer();
                this.loadSyntheticTrainingData();
                
                this.isReady = true;
                console.log('âœ… Frontend TabPFN System Ready (Mobile Compatible)!');
                appEvents.emit('ai:tabpfn:ready', this);
            }

            // Frontend TabPFN-Style Behavior Classifier
            createBehaviorClassifier() {
                this.behaviorClassifier = {
                    predict: (features) => {
                        // TabPFN-inspired rapid inference
                        const [age, size, consciousness, optimism, sociability, vocabSize, memoryCount, growthRate, hunger, energy, socialInteractions, learningRate] = features;
                        
                        // Multi-class behavior prediction with TabPFN-style scoring
                        const creativityScore = (consciousness * 0.35) + (vocabSize * 0.25) + (learningRate * 0.25) + (memoryCount * 0.15);
                        const socialScore = (sociability * 0.4) + (socialInteractions * 0.3) + (optimism * 0.2) + (vocabSize * 0.1);
                        const explorerScore = (energy * 0.35) + (growthRate * 0.25) + (consciousness * 0.2) + (age * 0.1) + (size * 0.1);
                        const learnerScore = (learningRate * 0.4) + (consciousness * 0.3) + (vocabSize * 0.2) + (memoryCount * 0.1);
                        
                        // TabPFN-style ensemble decision with confidence
                        const behaviors = [
                            { name: 'creative', score: creativityScore, confidence: Math.min(0.95, creativityScore + 0.1) },
                            { name: 'social', score: socialScore, confidence: Math.min(0.9, socialScore + 0.15) },
                            { name: 'explorer', score: explorerScore, confidence: Math.min(0.85, explorerScore + 0.2) },
                            { name: 'learner', score: learnerScore, confidence: Math.min(0.88, learnerScore + 0.12) },
                            { name: 'basic', score: 0.4, confidence: 0.6 }
                        ];
                        
                        const bestBehavior = behaviors.sort((a, b) => b.score - a.score)[0];
                        return { behavior: bestBehavior.name, confidence: bestBehavior.confidence };
                    }
                };
            }

            async predictBehavior(bacteria) {
                if (!this.isReady) return 'basic';
                
                const features = [
                    bacteria.biological_state.age / 100,
                    bacteria.biological_state.size / 5,
                    bacteria.consciousness_level / 10,
                    bacteria.personality_traits.optimism,
                    bacteria.personality_traits.sociability,
                    bacteria.vocabulary.size / 20,
                    bacteria.memory_bank.length / 10,
                    bacteria.biological_state.growth_rate,
                    bacteria.hunger || 0.5,
                    bacteria.energy || 0.7,
                    bacteria.conversation_history.length / 5,
                    0.1 // learning_rate default
                ];
                
                // ğŸ§  SELF-IMPROVEMENT: Risk assessment
                const context = {
                    bacteriaAge: bacteria.biological_state.age,
                    consciousness: bacteria.consciousness_level,
                    hunger: bacteria.hunger || 0.5
                };
                
                const result = this.behaviorClassifier.predict(features);
                const riskAssessment = learningEngine.assessRisk('tabpfn', features, result.confidence, context);
                
                // Apply risk-based adjustments
                let finalBehavior = result.behavior;
                let finalConfidence = result.confidence;
                
                if (riskAssessment.isRisky && result.confidence < learningEngine.confidenceThreshold) {
                    finalBehavior = 'basic'; // Safe fallback
                    finalConfidence = 0.9; // High confidence in safe choice
                    console.log(`âš ï¸ TabPFN Risk detected, using fallback: ${bacteria.name} â†’ ${finalBehavior}`);
                }
                
                // ğŸ“Š Log decision for learning
                const logEntry = learningEngine.logDecision('tabpfn', features, finalBehavior, finalConfidence, context);
                
                // Store for outcome tracking
                bacteria._lastDecisionLog = logEntry;
                
                console.log(`ğŸ¯ TabPFN: ${bacteria.name} â†’ ${finalBehavior} (${(finalConfidence * 100).toFixed(1)}%)`);
                
                // Collect training data for continuous improvement
                this.collectTrainingData(bacteria, finalBehavior, features);
                
                return finalBehavior;
            }

            // TabPFN-inspired personality trait prediction
            createPersonalityPredictor() {
                this.personalityPredictor = {
                    predictEvolution: (bacteria) => {
                        // Predict how personality will evolve based on TabPFN-style rapid inference
                        const experienceVector = [
                            bacteria.biological_state.age / 100,
                            bacteria.conversation_history.length / 50,
                            bacteria.vocabulary.size / 100,
                            bacteria.memory_bank.filter(m => m.includes('arkadaÅŸ')).length / 10,
                            bacteria.memory_bank.filter(m => m.includes('Ã¶ÄŸrendim')).length / 10
                        ];
                        
                        const evolutionFactor = experienceVector.reduce((sum, val) => sum + val, 0) / experienceVector.length;
                        
                        return {
                            optimismChange: (evolutionFactor - 0.5) * 0.05,
                            sociabilityChange: (bacteria.conversation_history.length > 5 ? 0.02 : -0.01),
                            confidenceBoost: evolutionFactor * 0.1
                        };
                    }
                };
            }

            createVocabularyAnalyzer() {
                this.vocabularyAnalyzer = {
                    analyze: (bacteria) => {
                        const vocabulary = Array.from(bacteria.vocabulary);
                        const consciousness = bacteria.consciousness_level;
                        
                        // Analyze vocabulary categories
                        const biochemWords = vocabulary.filter(w => ['ATP', 'enzim', 'protein', 'metabolizma', 'sentez', 'hÃ¼cre', 'oksijen', 'karbon'].includes(w));
                        const socialWords = vocabulary.filter(w => ['arkadaÅŸ', 'konuÅŸmak', 'paylaÅŸÄ±m', 'birlikte', 'dostluk', 'anlaÅŸma', 'empati'].includes(w));
                        const emotionalWords = vocabulary.filter(w => ['mutlu', 'Ã¼zgÃ¼n', 'heyecanlÄ±', 'meraklÄ±', 'sevinÃ§', 'umut', 'gÃ¼ven'].includes(w));
                        const scienceWords = vocabulary.filter(w => ['keÅŸif', 'deneyim', 'Ã¶ÄŸrenme', 'geliÅŸim', 'evrim', 'yenilik'].includes(w));
                        
                        const biochemRatio = biochemWords.length / Math.max(1, vocabulary.length);
                        const socialRatio = socialWords.length / Math.max(1, vocabulary.length);
                        const emotionalRatio = emotionalWords.length / Math.max(1, vocabulary.length);
                        const scienceRatio = scienceWords.length / Math.max(1, vocabulary.length);
                        
                        // Intelligent word suggestions based on gaps and consciousness level
                        let suggestedWords = [];
                        
                        if (consciousness > 8 && biochemRatio < 0.2) {
                            suggestedWords.push('quantum', 'molekÃ¼l', 'elektronik', 'nÃ¶ron');
                        }
                        
                        if (consciousness > 5 && socialRatio < 0.25) {
                            suggestedWords.push('sevgi', 'anlayÄ±ÅŸ', 'dayanÄ±ÅŸma', 'iletiÅŸim');
                        }
                        
                        if (consciousness > 3 && emotionalRatio < 0.15) {
                            suggestedWords.push('hissediyor', 'dÃ¼ÅŸÃ¼nÃ¼yor', 'hayal', 'rÃ¼ya');
                        }
                        
                        if (consciousness > 6 && scienceRatio < 0.2) {
                            suggestedWords.push('araÅŸtÄ±rma', 'hipotez', 'deney', 'kanÄ±t');
                        }
                        
                        // Consciousness-based advanced words
                        if (consciousness > 10) {
                            suggestedWords.push('bilinÃ§', 'varoluÅŸ', 'sonsuzluk', 'gerÃ§eklik');
                        }
                        
                        // Basic words for low consciousness
                        if (consciousness < 2) {
                            suggestedWords.push('merhaba', 'evet', 'hayÄ±r', 'gÃ¼zel');
                        }
                        
                        return {
                            total_words: vocabulary.length,
                            biochemical_ratio: biochemRatio,
                            social_ratio: socialRatio,
                            emotional_ratio: emotionalRatio,
                            science_ratio: scienceRatio,
                            suggested_words: suggestedWords.slice(0, 4), // Limit to 4 suggestions
                            consciousness_level: consciousness,
                            vocabulary_gaps: this.findVocabularyGaps(vocabulary)
                        };
                    },
                    
                    findVocabularyGaps: (vocabulary) => {
                        const gaps = [];
                        
                        if (!vocabulary.some(w => w.includes('arkadaÅŸ'))) gaps.push('social');
                        if (!vocabulary.some(w => ['ATP', 'enzim'].includes(w))) gaps.push('biochemical');
                        if (!vocabulary.some(w => ['mutlu', 'Ã¼zgÃ¼n'].includes(w))) gaps.push('emotional');
                        if (!vocabulary.some(w => ['Ã¶ÄŸrenme', 'keÅŸif'].includes(w))) gaps.push('learning');
                        
                        return gaps;
                    }
                };
            }

            async analyzeVocabulary(bacteria) {
                if (!this.isReady) return null;
                
                const analysis = this.vocabularyAnalyzer.analyze(bacteria);
                console.log(`ğŸ“– Frontend TabPFN Vocab Analysis for ${bacteria.name}:`, analysis);
                
                return {
                    vocabulary_analysis: analysis,
                    suggested_next_words: analysis.suggested_words
                };
            }
            
            // NEW: Improve bacteria word usage in conversations
            improveWordUsage(bacteria, context = 'conversation') {
                const vocabulary = Array.from(bacteria.vocabulary);
                const consciousness = bacteria.consciousness_level;
                
                // Select words based on context and consciousness
                let contextualWords = [];
                
                if (context === 'greeting') {
                    contextualWords = vocabulary.filter(w => ['merhaba', 'selam', 'dostluk', 'sevgi'].includes(w));
                }
                else if (context === 'learning') {
                    contextualWords = vocabulary.filter(w => ['Ã¶ÄŸrenme', 'keÅŸif', 'deneyim', 'anlama', 'geliÅŸim'].includes(w));
                }
                else if (context === 'social') {
                    contextualWords = vocabulary.filter(w => ['arkadaÅŸ', 'paylaÅŸÄ±m', 'birlikte', 'anlaÅŸma', 'sevgi'].includes(w));
                }
                else if (context === 'science') {
                    contextualWords = vocabulary.filter(w => ['ATP', 'enzim', 'hÃ¼cre', 'protein', 'molekÃ¼l'].includes(w));
                }
                else {
                    // General conversation - mix of all categories
                    contextualWords = vocabulary.filter(w => 
                        ['arkadaÅŸ', 'Ã¶ÄŸrenme', 'mutlu', 'ATP', 'keÅŸif', 'geliÅŸim', 'sevgi', 'anlama'].includes(w)
                    );
                }
                
                // If no contextual words, fall back to any learned words
                if (contextualWords.length === 0 && vocabulary.length > 0) {
                    contextualWords = vocabulary.slice(-5); // Use most recent words
                }
                
                // Return a random contextual word for use in conversation
                if (contextualWords.length > 0) {
                    const selectedWord = contextualWords[Math.floor(Math.random() * contextualWords.length)];
                    console.log(`ğŸ’¬ ${bacteria.name} using learned word: "${selectedWord}" (context: ${context})`);
                    return selectedWord;
                }
                
                return null;
            }

            loadSyntheticTrainingData() {
                // Load synthetic training examples for TabPFN-style learning
                const examples = [
                    { features: [0.1, 1.5, 2.0, 0.8, 0.7, 0.3, 0.2, 0.6, 0.5, 0.8, 0.1, 0.1], behavior: 'social' },
                    { features: [0.5, 2.0, 8.0, 0.6, 0.3, 0.8, 0.7, 0.4, 0.6, 0.7, 0.3, 0.9], behavior: 'creative' },
                    { features: [0.3, 1.8, 5.0, 0.5, 0.6, 0.6, 0.5, 0.7, 0.8, 0.9, 0.2, 0.8], behavior: 'learner' },
                    { features: [0.2, 1.2, 3.0, 0.7, 0.4, 0.4, 0.3, 0.8, 0.9, 0.9, 0.1, 0.5], behavior: 'explorer' }
                ];
                
                examples.forEach((example, index) => {
                    this.trainingData.set(`synthetic_${index}`, example);
                });
                
                console.log(`ğŸ“š Loaded ${examples.length} synthetic training examples`);
            }
            
            collectTrainingData(bacteria, behavior, features) {
                // Store training example for continuous learning
                const dataPoint = {
                    bacteria_id: bacteria.id,
                    features: features,
                    behavior: behavior,
                    timestamp: Date.now(),
                    consciousness: bacteria.consciousness_level,
                    vocabulary_size: bacteria.vocabulary.size
                };
                
                this.trainingData.set(`real_${bacteria.id}_${Date.now()}`, dataPoint);
                
                // Keep only last 1000 training examples for performance
                if (this.trainingData.size > 1000) {
                    const firstKey = this.trainingData.keys().next().value;
                    this.trainingData.delete(firstKey);
                }
            }

            // Real TabPFN-powered behavior adaptation
            async adaptBehavior(bacteria, context) {
                if (!this.isReady) return 'basic';
                
                try {
                    // Get real TabPFN prediction
                    const behavior = await this.predictBehavior(bacteria);
                    
                    // Context-aware enhancement using TabPFN insights
                    if (context === 'group_interaction') {
                        const vocabAnalysis = await this.analyzeVocabulary(bacteria);
                        if (vocabAnalysis && vocabAnalysis.vocabulary_analysis.social_ratio > 0.3) {
                            return `${behavior}_social`;
                        }
                    }
                    
                    if (context === 'learning_session') {
                        if (bacteria.consciousness_level > 5) {
                            return `${behavior}_enhanced`;
                        }
                    }
                    
                    return behavior;
                } catch (error) {
                    console.error('TabPFN adaptBehavior error:', error);
                    return 'basic';
                }
            }

            extractFeatures(bacteria) {
                return [
                    bacteria.biological_state.age / 100,
                    bacteria.biological_state.size / 5,
                    bacteria.consciousness_level / 5,
                    bacteria.personality_traits.optimism,
                    bacteria.personality_traits.sociability,
                    bacteria.vocabulary.size / 50,
                    bacteria.memory_bank.length / 20,
                    bacteria.biological_state.growth_rate,
                    0.5, // hunger
                    0.7, // energy
                    bacteria.conversation_history.length / 10,
                    bacteria.memory_bank.filter(m => m.includes('Ã¶ÄŸrendim')).length / 5
                ];
            }
        }

        // Initialize TabPFN adapter
        const tabPFNAdapter = new TabPFNAdapter();

        // v825: Persistent Database System
        class PersistentBacteriaDB {
            constructor() {
                this.dbName = 'NeoMagBacteriaDB';
                this.version = 1;
                this.isReady = false;
                this.initialize();
            }

            async initialize() {
                console.log('ğŸ—„ï¸ Initializing Persistent Database...');
                
                // Use IndexedDB for robust storage
                if ('indexedDB' in window) {
                    await this.initIndexedDB();
                } else {
                    // Fallback to localStorage
                    console.log('ğŸ“¦ IndexedDB not available, using localStorage');
                    this.isReady = true;
                }
                
                if (this.isReady) {
                    console.log('ğŸ’¾ Database ready, emitting db:ready event');
                    appEvents.emit('db:ready', this);
                } else {
                    console.log('âŒ Database initialization failed');
                    appEvents.emit('db:error', { error: 'Failed to initialize' });
                }
            }

            async initIndexedDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => {
                        console.error('âŒ IndexedDB initialization failed');
                        reject(request.error);
                    };

                    request.onsuccess = () => {
                        this.db = request.result;
                        this.isReady = true;
                        console.log('âœ… IndexedDB initialized successfully');
                        resolve();
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Bacteria store
                        const bacteriaStore = db.createObjectStore('bacteria', { keyPath: 'id' });
                        bacteriaStore.createIndex('name', 'name', { unique: false });
                        bacteriaStore.createIndex('consciousness_level', 'consciousness_level', { unique: false });
                        bacteriaStore.createIndex('last_updated', 'last_updated', { unique: false });
                        
                        // Simulation history store
                        const historyStore = db.createObjectStore('simulation_history', { keyPath: 'timestamp' });
                        historyStore.createIndex('day', 'day', { unique: false });
                        
                        // TabPFN training data store
                        const tabpfnStore = db.createObjectStore('tabpfn_data', { keyPath: 'record_id' });
                        tabpfnStore.createIndex('bacteria_id', 'bacteria_id', { unique: false });
                        tabpfnStore.createIndex('behavior_class', 'behavior_class', { unique: false });
                        
                        console.log('ğŸ—ï¸ Database schema created');
                    };
                });
            }

            async saveBacteria(bacteria) {
                if (!this.isReady) return false;

                const bacteriaData = {
                    id: bacteria.id,
                    name: bacteria.name,
                    biological_state: bacteria.biological_state,
                    personality_traits: bacteria.personality_traits,
                    consciousness_level: bacteria.consciousness_level, // Now unlimited!
                    language_stage: bacteria.language_stage,
                    vocabulary: Array.from(bacteria.vocabulary), // Convert Set to Array
                    memory_bank: bacteria.memory_bank,
                    conversation_history: bacteria.conversation_history,
                    position: { x: bacteria.x, y: bacteria.y },
                    velocity: { vx: bacteria.vx, vy: bacteria.vy },
                    color: bacteria.color,
                    last_updated: new Date().toISOString(),
                    total_runtime_days: bacteria.total_runtime_days || 0,
                    max_consciousness_reached: bacteria.max_consciousness_reached || bacteria.consciousness_level
                };

                try {
                    if (this.db) {
                        // IndexedDB
                        const transaction = this.db.transaction(['bacteria'], 'readwrite');
                        const store = transaction.objectStore('bacteria');
                        await store.put(bacteriaData);
                    } else {
                        // localStorage fallback
                        const allData = JSON.parse(localStorage.getItem('bacteriaDB') || '{}');
                        allData[bacteria.id] = bacteriaData;
                        localStorage.setItem('bacteriaDB', JSON.stringify(allData));
                    }
                    
                    console.log(`ğŸ’¾ Saved bacteria #${bacteria.id} (Consciousness: ${bacteria.consciousness_level.toFixed(2)})`);
                    return true;
                } catch (error) {
                    console.error('âŒ Failed to save bacteria:', error);
                    return false;
                }
            }

            async loadBacteria() {
                if (!this.isReady) return [];

                try {
                    let bacteriaData = [];
                    
                    if (this.db) {
                        // IndexedDB
                        const transaction = this.db.transaction(['bacteria'], 'readonly');
                        const store = transaction.objectStore('bacteria');
                        const request = store.getAll();
                        
                        bacteriaData = await new Promise((resolve, reject) => {
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                    } else {
                        // localStorage fallback
                        const allData = JSON.parse(localStorage.getItem('bacteriaDB') || '{}');
                        bacteriaData = Object.values(allData);
                    }

                    console.log(`ğŸ“– Loaded ${bacteriaData.length} bacteria from database`);
                    return bacteriaData;
                } catch (error) {
                    console.error('âŒ Failed to load bacteria:', error);
                    return [];
                }
            }

            async saveSimulationState(day, population, metrics) {
                if (!this.isReady) return false;

                const stateData = {
                    timestamp: new Date().toISOString(),
                    day: day,
                    population_count: population.length,
                    average_consciousness: population.reduce((sum, b) => sum + b.consciousness_level, 0) / population.length,
                    max_consciousness: Math.max(...population.map(b => b.consciousness_level)),
                    total_vocabulary: new Set(population.flatMap(b => Array.from(b.vocabulary))).size,
                    performance_metrics: metrics
                };

                try {
                    if (this.db) {
                        const transaction = this.db.transaction(['simulation_history'], 'readwrite');
                        const store = transaction.objectStore('simulation_history');
                        await store.put(stateData);
                    } else {
                        const allHistory = JSON.parse(localStorage.getItem('simulationHistory') || '[]');
                        allHistory.push(stateData);
                        // Keep last 1000 records
                        if (allHistory.length > 1000) {
                            allHistory.splice(0, allHistory.length - 1000);
                        }
                        localStorage.setItem('simulationHistory', JSON.stringify(allHistory));
                    }
                    
                    return true;
                } catch (error) {
                    console.error('âŒ Failed to save simulation state:', error);
                    return false;
                }
            }

            async exportToCSV() {
                console.log('ğŸ“Š Generating TabPFN-ready CSV export...');
                
                const bacteriaData = await this.loadBacteria();
                if (bacteriaData.length === 0) {
                    console.log('âš ï¸ No data to export');
                    return;
                }

                // TabPFN-optimized feature columns
                const csvHeaders = [
                    'bacteria_id', 'name', 'age', 'size', 'consciousness_level', 'max_consciousness_reached',
                    'optimism', 'sociability', 'vocabulary_size', 'memory_count', 'growth_rate',
                    'total_conversations', 'learning_events', 'social_interactions', 'runtime_days',
                    'biochemical_words', 'social_words', 'emotional_words', 'behavior_prediction',
                    'last_updated', 'x_position', 'y_position'
                ];

                let csvContent = csvHeaders.join(',') + '\n';

                bacteriaData.forEach(bacteria => {
                    const vocab = bacteria.vocabulary || [];
                    const biochemWords = vocab.filter(w => ['ATP', 'enzim', 'protein', 'metabolizma', 'sentez'].includes(w)).length;
                    const socialWords = vocab.filter(w => ['arkadaÅŸ', 'konuÅŸmak', 'paylaÅŸÄ±m', 'birlikte'].includes(w)).length;
                    const emotionalWords = vocab.filter(w => ['mutlu', 'Ã¼zgÃ¼n', 'heyecanlÄ±', 'meraklÄ±'].includes(w)).length;
                    
                    // Predict behavior for CSV
                    const tempBacteria = this.recreateBacteriaFromData(bacteria);
                    const behaviorPrediction = predictBehavior(tempBacteria, 'csv_export');

                    const row = [
                        bacteria.id,
                        `"${bacteria.name}"`,
                        bacteria.biological_state.age,
                        bacteria.biological_state.size.toFixed(3),
                        bacteria.consciousness_level.toFixed(3),
                        bacteria.max_consciousness_reached?.toFixed(3) || bacteria.consciousness_level.toFixed(3),
                        bacteria.personality_traits.optimism.toFixed(3),
                        bacteria.personality_traits.sociability.toFixed(3),
                        vocab.length,
                        bacteria.memory_bank.length,
                        bacteria.biological_state.growth_rate.toFixed(3),
                        bacteria.conversation_history.length,
                        bacteria.memory_bank.filter(m => m.includes('Ã¶ÄŸrendim')).length,
                        bacteria.memory_bank.filter(m => m.includes('arkadaÅŸ')).length,
                        bacteria.total_runtime_days || 0,
                        biochemWords,
                        socialWords,
                        emotionalWords,
                        behaviorPrediction,
                        bacteria.last_updated,
                        bacteria.position.x.toFixed(2),
                        bacteria.position.y.toFixed(2)
                    ];

                    csvContent += row.join(',') + '\n';
                });

                // Download CSV
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `neomag_bacteria_tabpfn_${new Date().toISOString().slice(0,10)}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                console.log(`âœ… CSV exported with ${bacteriaData.length} bacteria records`);
            }

            recreateBacteriaFromData(data) {
                // Create temporary bacteria object for prediction
                return {
                    id: data.id,
                    name: data.name,
                    biological_state: data.biological_state,
                    personality_traits: data.personality_traits,
                    consciousness_level: data.consciousness_level,
                    vocabulary: new Set(data.vocabulary),
                    memory_bank: data.memory_bank,
                    conversation_history: data.conversation_history
                };
            }

            async clearDatabase() {
                if (!this.isReady) return false;

                try {
                    if (this.db) {
                        const stores = ['bacteria', 'simulation_history', 'tabpfn_data'];
                        const transaction = this.db.transaction(stores, 'readwrite');
                        
                        stores.forEach(storeName => {
                            const store = transaction.objectStore(storeName);
                            store.clear();
                        });
                    } else {
                        localStorage.removeItem('bacteriaDB');
                        localStorage.removeItem('simulationHistory');
                    }
                    
                    console.log('ğŸ—‘ï¸ Database cleared successfully');
                    return true;
                } catch (error) {
                    console.error('âŒ Failed to clear database:', error);
                    return false;
                }
            }
        }

        // Initialize persistent database (initialization will be done in mainInitialize)

        // v826: Real TensorFlow.js AI Training System
        class RealAITrainingSystem {
            constructor() {
                this.behaviorModel = null;
                this.isTraining = false;
                this.trainingData = [];
                this.modelVersion = 1;
                this.lastTrainingTime = 0;
                this.trainingInterval = 120000; // Train every 2 minutes
                this.initialize();
            }

            async initialize() {
                console.log('ğŸ§  Initializing Real TensorFlow.js Training System...');
                try {
                    await this.createBehaviorModel();
                    await this.loadTrainingData();
                    this.startTrainingLoop();
                    console.log('âœ… Real AI Training System ready');
                    appEvents.emit('ai:tfjs:ready', this);
                } catch (error) {
                    console.error('âŒ TensorFlow.js AI initialization failed:', error);
                    appEvents.emit('ai:tfjs:error', { error });
                }
            }

            async createBehaviorModel() {
                this.behaviorModel = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [12], units: 32, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 16, activation: 'relu' }),
                        tf.layers.dense({ units: 5, activation: 'softmax' })
                    ]
                });
                this.behaviorModel.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });
                console.log('ğŸ¯ Real behavior model created');
            }

            async collectTrainingData(bacteria, behavior) {
                const trainingRecord = {
                    record_id: Date.now() + Math.random(),
                    bacteria_id: bacteria.id,
                    timestamp: new Date().toISOString(),
                    features_behavior: [
                        bacteria.biological_state.age / 100,
                        bacteria.biological_state.size / 5,
                        bacteria.consciousness_level / 10,
                        bacteria.personality_traits.optimism,
                        bacteria.personality_traits.sociability,
                        bacteria.vocabulary.size / 20,
                        bacteria.memory_bank.length / 10,
                        bacteria.hunger || 0.5, // Dynamic now!
                        bacteria.energy || 0.7, // Dynamic now!
                        bacteria.biological_state.growth_rate,
                        bacteria.getProximityToOthers ? bacteria.getProximityToOthers() : 0.5,
                        bacteria.getRecentActivityLevel ? bacteria.getRecentActivityLevel() : 0.5
                    ],
                    behavior_class: this.encodeBehaviorClass(behavior),
                    model_version: this.modelVersion
                };

                this.trainingData.push(trainingRecord);
                
                if (persistentDB.isReady) {
                    await this.saveTrainingDataToDB(trainingRecord);
                }
                
                console.log(`ğŸ“Š Training data collected for bacteria #${bacteria.id}: ${behavior}`);
            }

            encodeBehaviorClass(behavior) {
                const classes = ['basic', 'social', 'explorer', 'learner', 'creative'];
                const index = classes.indexOf(behavior);
                const encoded = new Array(5).fill(0);
                if (index >= 0) encoded[index] = 1;
                return encoded;
            }

            async saveTrainingDataToDB(record) {
                try {
                    if (persistentDB && persistentDB.db) {
                        const transaction = persistentDB.db.transaction(['tabpfn_data'], 'readwrite');
                        const store = transaction.objectStore('tabpfn_data');
                        await store.put(record);
                    }
                } catch (error) {
                    console.error('âŒ Failed to save training data:', error);
                }
            }

            async loadTrainingData() {
                try {
                    // Wait for persistentDB to be ready
                    if (!persistentDB || !persistentDB.db) {
                        console.log('â³ Database not ready yet, skipping training data load');
                        return;
                    }
                    
                    const transaction = persistentDB.db.transaction(['tabpfn_data'], 'readonly');
                    const store = transaction.objectStore('tabpfn_data');
                    const request = store.getAll();
                    
                    const existingData = await new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    this.trainingData = existingData;
                    console.log(`ğŸ“š Loaded ${existingData.length} existing training records`);
                } catch (error) {
                    console.error('âŒ Failed to load training data:', error);
                }
            }

            async trainModels() {
                if (this.isTraining || this.trainingData.length < 10) return;

                this.isTraining = true;
                console.log('ğŸ”„ Training real TensorFlow.js model...');

                try {
                    const behaviorFeatures = this.trainingData.map(d => d.features_behavior);
                    const behaviorLabels = this.trainingData.map(d => d.behavior_class);
                    
                    const behaviorX = tf.tensor2d(behaviorFeatures);
                    const behaviorY = tf.tensor2d(behaviorLabels);

                    await this.behaviorModel.fit(behaviorX, behaviorY, {
                        epochs: 10,
                        batchSize: 8,
                        validationSplit: 0.2,
                        shuffle: true,
                        verbose: 0
                    });

                    this.modelVersion++;
                    this.lastTrainingTime = Date.now();
                    
                    console.log(`âœ… Real model training complete! Version: ${this.modelVersion}`);

                    behaviorX.dispose();
                    behaviorY.dispose();
                } catch (error) {
                    console.error('âŒ Training failed:', error);
                }

                this.isTraining = false;
            }

            async predictBehavior(bacteria) {
                if (!this.behaviorModel) return 'basic';

                try {
                    const features = [
                        bacteria.biological_state.age / 100,
                        bacteria.biological_state.size / 5,
                        bacteria.consciousness_level / 10,
                        bacteria.personality_traits.optimism,
                        bacteria.personality_traits.sociability,
                        bacteria.vocabulary.size / 20,
                        bacteria.memory_bank.length / 10,
                        bacteria.hunger || 0.5,
                        bacteria.energy || 0.7,
                        bacteria.biological_state.growth_rate,
                        bacteria.getProximityToOthers ? bacteria.getProximityToOthers() : 0.5,
                        bacteria.getRecentActivityLevel ? bacteria.getRecentActivityLevel() : 0.5
                    ];

                    const prediction = this.behaviorModel.predict(tf.tensor2d([features]));
                    const probabilities = await prediction.data();
                    
                    const behaviorClasses = ['basic', 'social', 'explorer', 'learner', 'creative'];
                    const maxIndex = probabilities.indexOf(Math.max(...probabilities));
                    
                    prediction.dispose();
                    return behaviorClasses[maxIndex];
                } catch (error) {
                    console.error('âŒ Prediction failed:', error);
                    return 'basic';
                }
            }

            startTrainingLoop() {
                setInterval(() => {
                    if (Date.now() - this.lastTrainingTime > this.trainingInterval) {
                        this.trainModels();
                    }
                }, 30000);
            }

            getTrainingStats() {
                return {
                    totalRecords: this.trainingData.length,
                    modelVersion: this.modelVersion,
                    isTraining: this.isTraining
                };
            }
        }

        // Initialize real AI training system (will be initialized after DB ready)
        let realAI = null;

        // v829 Enhanced Performance Monitoring + Canvas Support
        let performanceMetrics = {
            renderTime: 0,
            mlInferenceTime: 0,
            totalMemoryUsage: 0,
            vocabularySize: 0,
            lastUpdate: Date.now(),
            fps: 0,
            lastFrameTime: 0,
            frameCount: 0
        };

        // Canvas support variables (DYNAMIC BOUNDARIES FIX)
        let canvas = null;
        let ctx = null;
        let canvasWidth = 0;
        let canvasHeight = 0;
        let useCanvas = false;
        
        // ğŸ¯ DYNAMIC CANVAS BOUNDARIES (v8.7.3 BÃœYÃœK Ä°NÄ°TÄ°AL VALUES)
        let DYNAMIC_BOUNDARIES = {
            maxX: 1200,  // âŒ SABÄ°T 480 KALDIRILDI! BaÅŸlangÄ±Ã§ bÃ¼yÃ¼k deÄŸer
            maxY: 800,   // âŒ SABÄ°T 280 KALDIRILDI! BaÅŸlangÄ±Ã§ bÃ¼yÃ¼k deÄŸer
            minX: 20,
            minY: 20,
            padding: 20
        };

        // Molecular Dynamics Constants (based on research)
        const MD_CONSTANTS = {
            VAN_DER_WAALS_STRENGTH: 0.1,      // Lennard-Jones potential coefficient
            ELECTROSTATIC_FORCE: 0.2,         // Coulomb interactions
            MEMBRANE_PERMEABILITY: 0.05,      // Bacterial membrane effects
            ATP_SYNTHESIS_RATE: 0.02,         // Energy metabolism rate
            PROTEIN_FOLDING_FACTOR: 0.15,     // Conformational changes
            DIFFUSION_COEFFICIENT: 0.8        // Brownian motion
        };

        function updatePerformanceMetrics() {
            performanceMetrics.vocabularySize = wordTokenizer.size;
            performanceMetrics.totalMemoryUsage = bacteriaPopulation.reduce((sum, b) => sum + b.memory_bank.length, 0);
            performanceMetrics.lastUpdate = Date.now();
            
            // v829: FPS Calculation
            const now = performance.now();
            if (performanceMetrics.lastFrameTime > 0) {
                const delta = now - performanceMetrics.lastFrameTime;
                performanceMetrics.fps = Math.round(1000 / delta);
                performanceMetrics.frameCount++;
                
                // Update FPS displays
                updateFPSDisplays();
            }
            performanceMetrics.lastFrameTime = now;
            
            // Console debug every 5 seconds
            if (performanceMetrics.frameCount % 300 === 0) { // Roughly every 5 seconds at 60fps
                console.log('ğŸ“Š v829 Performance:', {
                    fps: performanceMetrics.fps,
                    bacteria: bacteriaPopulation.length,
                    vocabulary: performanceMetrics.vocabularySize,
                    memory: performanceMetrics.totalMemoryUsage
                });
            }
        }

        function updateFPSDisplays() {
            const fpsDisplay = document.getElementById('fpsDisplay');
            const canvasFpsDisplay = document.getElementById('canvasFpsDisplay');
            const bacteriaCountDisplay = document.getElementById('bacteriaCount');
            const dayDisplayElement = document.getElementById('dayDisplay');
            
            if (fpsDisplay) fpsDisplay.textContent = `FPS: ${performanceMetrics.fps}`;
            if (canvasFpsDisplay) canvasFpsDisplay.textContent = performanceMetrics.fps;
            if (bacteriaCountDisplay) bacteriaCountDisplay.textContent = `Bakteri: ${bacteriaPopulation.length}`;
            if (dayDisplayElement) dayDisplayElement.textContent = `GÃ¼n: ${simulationDay}`;
        }

        // v8.7.1: Enhanced Canvas Initialization with Guaranteed Boundary Update
        function initializeCanvas() {
            canvas = document.getElementById('simCanvas');
            if (canvas) {
                ctx = canvas.getContext('2d');
                
                // ğŸ¯ MULTIPLE BOUNDARY UPDATE ATTEMPTS (v8.7.1 FIX)
                // Try immediately
                resizeCanvas();
                
                // Try after DOM ready
                if (document.readyState !== 'complete') {
                    window.addEventListener('DOMContentLoaded', () => {
                        resizeCanvas();
                        console.log('ğŸ”§ Boundary update on DOMContentLoaded');
                    });
                }
                
                // Try after a short delay
                setTimeout(() => {
                    resizeCanvas();
                    console.log('ğŸ”§ Boundary update after 100ms delay');
                }, 100);
                
                // Try after a longer delay for insurance
                setTimeout(() => {
                    resizeCanvas();
                    console.log('ğŸ”§ Boundary update after 500ms delay - guaranteed!');
                }, 500);
                
                useCanvas = true;
                console.log('ğŸ¨ Canvas initialized with multiple boundary update attempts');
                
                // Add resize listener
                window.addEventListener('resize', resizeCanvas);
                
                // Canvas click handler for bacteria selection and food placement
                canvas.addEventListener('click', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Check if clicked on a bacteria with larger click radius
                    let clickedBacteria = null;
                    let minDistance = Infinity;
                    
                    bacteriaList.forEach(bacteria => {
                        const distance = Math.hypot(bacteria.x - x, bacteria.y - y);
                        const clickRadius = Math.max(25, bacteria.biological_state.size * 15 + 15); // Larger click area
                        
                        if (distance <= clickRadius && distance < minDistance) {
                            minDistance = distance;
                            clickedBacteria = bacteria;
                        }
                    });
                    
                    if (clickedBacteria) {
                        // Select bacteria for individual chat (NO MSGBOX!)
                        selectedBacteria = clickedBacteria;
                        console.log(`ğŸ¯ Bacteria SELECTED: ${clickedBacteria.name} (distance: ${minDistance.toFixed(0)})`);
                        
                        // Update bacteria details panel
                        showBacteriaDetails(clickedBacteria);
                        
                        // Switch to individual chat mode
                        switchToIndividualChat(clickedBacteria);
                        
                        // Highlight selected bacteria visually
                        highlightSelectedBacteria(clickedBacteria);
                        
                    } else {
                        // No bacteria clicked, add food instead
                        addFood(x, y);
                    }
                });
            }
        }

        function resizeCanvas() {
            if (!canvas) {
                console.warn('âš ï¸ resizeCanvas called but canvas is null!');
                return;
            }
            
            const container = canvas.parentElement;
            if (!container) {
                console.warn('âš ï¸ Canvas parent element not found!');
                return;
            }
            
            const rect = container.getBoundingClientRect();
            console.log(`ğŸ” Canvas container found, getting rect...`);
            
            // ğŸ”§ CSS-AWARE DYNAMIC PADDING CALCULATION (v8.7.1 FIX)
            const style = window.getComputedStyle(container);
            const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
            const paddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
            
            // Set canvas size with dynamic padding calculation
            canvasWidth = Math.max(400, rect.width - paddingX); // Minimum 400px width
            canvasHeight = Math.max(300, rect.height - paddingY); // Minimum 300px height
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // ğŸ¯ UPDATE DYNAMIC BOUNDARIES (E031 FIX)
            DYNAMIC_BOUNDARIES.maxX = canvasWidth - DYNAMIC_BOUNDARIES.padding;
            DYNAMIC_BOUNDARIES.maxY = canvasHeight - DYNAMIC_BOUNDARIES.padding;
            DYNAMIC_BOUNDARIES.minX = DYNAMIC_BOUNDARIES.padding;
            DYNAMIC_BOUNDARIES.minY = DYNAMIC_BOUNDARIES.padding;
            
            console.log(`ğŸ”§ Canvas resized: ${canvasWidth}x${canvasHeight} (padding: ${paddingX}x${paddingY})`);
            console.log(`ğŸ¯ Dynamic boundaries updated:`, DYNAMIC_BOUNDARIES);
            console.log(`ğŸ“ Container rect:`, {width: rect.width, height: rect.height, left: rect.left, top: rect.top});
        }
        let nextTokenId = 1;



        // ğŸ¯ SYSTEM STATUS TRACKER
        const systemStatus = {
            db: false,
            tabpfn: false,
            tfjs: false,
            simulation: false
        };

        function updateBuildInfo() {
            try {
                const buildInfo = document.getElementById('buildInfo');
                if (!buildInfo) return;
                
                const simStatus = systemStatus.simulation ? 'ğŸŸ¢ Running' : 'ğŸ”´ Paused';
                const dbStatus = systemStatus.db ? 'ğŸŸ¢ Connected' : 'ğŸ”´ Offline';
                
                // ML Status: daha detaylÄ±
                let mlStatus = 'ğŸ”´ Loading';
                if (systemStatus.tabpfn && systemStatus.tfjs) {
                    mlStatus = 'ğŸŸ¢ Full Ready';
                } else if (systemStatus.tabpfn || systemStatus.tfjs) {
                    mlStatus = 'ğŸŸ¡ Partial';
                }
                
                // Memory status
                let memStatus = '';
                try {
                    if (typeof MemoryManager !== 'undefined' && MemoryManager.getMemoryUsage) {
                        const memInfo = MemoryManager.getMemoryUsage();
                        memStatus = memInfo.used > 0 ? `ğŸ“Š ${memInfo.used}MB` : '';
                    }
                } catch (e) { /* ignore */ }
                
                // Learning engine stats
                const learningStats = learningEngine.getStats();
                const successRate = (learningStats.recentSuccessRate * 100).toFixed(0);
                
                buildInfo.innerHTML = `
                    Build: ${BUILD_DATE} | Features: ${FEATURES.length} | 
                    Sim: ${simStatus} | 
                    Chat Mode: <span class="text-yellow-400">${chatMode.toUpperCase()}</span> | 
                    ML: <span class="text-${systemStatus.tabpfn && systemStatus.tfjs ? 'green' : 'orange'}-400">${mlStatus}</span> |
                    DB: ${dbStatus} | 
                    ğŸ§  AI Success: <span class="text-cyan-400">${successRate}%</span> | ${memStatus}
                `;
            } catch (error) {
                console.warn('âš ï¸ updateBuildInfo error (ignored):', error.message);
            }
        }

        // ğŸ¯ EVENT-DRIVEN INITIALIZATION LISTENERS
        function initializeEventListeners() {
            // Database ready
            appEvents.on('db:ready', (dbInstance) => {
                console.log('ğŸ“¡ Event: Database ready');
                systemStatus.db = true;
                updateBuildInfo();
            });

            // TabPFN ready  
            appEvents.on('ai:tabpfn:ready', (tabpfnInstance) => {
                console.log('ğŸ“¡ Event: TabPFN AI ready');
                systemStatus.tabpfn = true;
                updateBuildInfo();
            });

            // TensorFlow.js ready
            appEvents.on('ai:tfjs:ready', (tfjsInstance) => {
                console.log('ğŸ“¡ Event: TensorFlow.js AI ready');
                systemStatus.tfjs = true;
                isMLReady = true; // Global flag
                updateBuildInfo();
            });

            // All systems ready
            appEvents.on('all:systems:ready', () => {
                console.log('ğŸ“¡ Event: All systems ready!');
                updateBuildInfo();
                
                // Enable advanced features
                const advancedButtons = document.querySelectorAll('[data-requires-ai]');
                advancedButtons.forEach(btn => {
                    btn.disabled = false;
                    btn.classList.remove('opacity-50');
                });
            });

            // Error handling
            appEvents.on('db:error', (error) => {
                console.error('ğŸ“¡ Event: Database error:', error);
                updateBuildInfo();
            });

            appEvents.on('ai:tfjs:error', (error) => {
                console.error('ğŸ“¡ Event: TensorFlow.js error:', error);
                updateBuildInfo();
            });
        }

        // Vocabulary Stages (Simplified from FUNCTION_ROADMAP.md)
        const vocabularyStages = [
            { stage: 0, name: "Temel Ä°htiyaÃ§lar", words: ["aÃ§", "yardÄ±m", "aÄŸrÄ±"], threshold: 0 },
            { stage: 1, name: "Basit Duygular", words: ["mutlu", "Ã¼zgÃ¼n", "korku"], threshold: 3 },
            { stage: 2, name: "Ã‡evresel Kavramlar", words: ["sÄ±cak", "soÄŸuk", "yemek"], threshold: 6 },
            { stage: 3, name: "Sosyal Kavramlar", words: ["arkadaÅŸ", "konuÅŸmak", "birlikte"], threshold: 10 },
            { stage: 4, name: "Soyut Kavramlar", words: ["gelecek", "hafÄ±za", "rÃ¼ya"], threshold: 15 },
            { stage: 5, name: "Felsefi DÃ¼ÅŸÃ¼nce", words: ["varoluÅŸ", "amaÃ§", "bilinÃ§"], threshold: 20 }
        ];
        
        const allPossibleWords = vocabularyStages.reduce((acc, stage) => acc.concat(stage.words), []);

        // Initialize word tokenizer with base vocabulary
        function initializeTokenizer() {
            allPossibleWords.forEach(word => {
                if (!wordTokenizer.has(word)) {
                    wordTokenizer.set(word, nextTokenId++);
                }
            });
            console.log('ğŸ§  Tokenizer initialized with', wordTokenizer.size, 'words');
        }

        // Create mini neural network for word learning
        async function createWordEmbeddingModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [50], units: 32, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 16, activation: 'relu' }),
                    tf.layers.dense({ units: 8, activation: 'softmax' })
                ]
            });

            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            return model;
        }

        // Create behavior prediction model
        async function createBehaviorModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [12], units: 24, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.1 }),
                    tf.layers.dense({ units: 12, activation: 'relu' }),
                    tf.layers.dense({ units: 6, activation: 'softmax' })
                ]
            });

            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            return model;
        }

        // Extract and learn new words from user input
        function learnFromUserInput(message, bacteria) {
            const words = message.toLowerCase().split(/\s+/);
            let newWordsLearned = 0;

            words.forEach(word => {
                // Clean word
                word = word.replace(/[^\w]/g, '');
                if (word.length < 2) return;

                // Add to tokenizer if new
                if (!wordTokenizer.has(word)) {
                    wordTokenizer.set(word, nextTokenId++);
                    console.log(`ğŸ†• ${bacteria.name} learned new word: "${word}"`);
                    newWordsLearned++;
                }

                // Add to bacteria vocabulary if consciousness allows
                if (bacteria.consciousness_level > 1.5 && Math.random() < 0.6) {
                    bacteria.vocabulary.add(word);
                }
            });

            // Update bacteria memory about learning
            if (newWordsLearned > 0) {
                bacteria.memory_bank.push(`${newWordsLearned} yeni kelime Ã¶ÄŸrendim: "${words.join(' ')}"`);
                
                // v822: Enhanced memory consolidation
                bacteria.consolidateMemory();
            }

            return newWordsLearned;
        }

        // ğŸ”§ V8.9.1: FIXED Promise Issue - Generate new words (synchronous)
        function generateNewWord(bacteria) {
            if (!bacteria || !bacteria.vocabulary) return null;
            
            // Skip async TabPFN for now - causing [object Promise] issue
            // Direct fallback to traditional word generation
            const vocabArray = Array.from(bacteria.vocabulary);
            if (vocabArray.length < 2) {
                // Basic starter words for new bacteria
                const starterWords = ['merhaba', 'yaÅŸam', 'bÃ¼yÃ¼mek', 'Ã¶ÄŸrenmek', 'enerji', 'yemek', 'ATP', 'hÃ¼cre'];
                const newWord = starterWords[Math.floor(Math.random() * starterWords.length)];
                bacteria.vocabulary.add(newWord);
                console.log(`ğŸ¯ Basic word "${newWord}" for ${bacteria.name}`);
                return newWord;
            }

            // Simple word combination for compound words
            const word1 = vocabArray[Math.floor(Math.random() * vocabArray.length)];
            const word2 = vocabArray[Math.floor(Math.random() * vocabArray.length)];
            
            if (word1 === word2) return null;

            // Create compound words with Turkish patterns
            const combinations = [
                word1 + word2,
                word1.slice(0, -1) + word2.slice(1),
                word1.slice(0, 2) + word2.slice(-2),
                word1[0] + word2,
                word1 + '-' + word2 // Turkish compound style
            ];

            const newWord = combinations[Math.floor(Math.random() * combinations.length)];
            
            // Add to vocabulary and tokenizer
            if (newWord && newWord.length > 2) {
                bacteria.vocabulary.add(newWord);
                if (!wordTokenizer.has(newWord)) {
                    wordTokenizer.set(newWord, nextTokenId++);
                }
                console.log(`ğŸ¯ Compound word "${newWord}" created by ${bacteria.name}`);
                return newWord;
            }

            return null;
        }

        // v8.2.7: TabPFN-powered behavior prediction 
        async function predictBehavior(bacteria, context = 'general') {
            const startTime = performance.now();
            
            // Use real TabPFN model first
            if (tabPFNAdapter && tabPFNAdapter.isReady) {
                try {
                    const behavior = await tabPFNAdapter.adaptBehavior(bacteria, context);
                    performanceMetrics.mlInferenceTime = performance.now() - startTime;
                    console.log(`ğŸ¯ TabPFN predicted "${behavior}" for ${bacteria.name} (${(performance.now() - startTime).toFixed(1)}ms)`);
                    return behavior;
                } catch (error) {
                    console.error('âŒ TabPFN prediction failed:', error);
                }
            }
            
            // Fallback to TensorFlow.js if TabPFN unavailable
            if (realAI && realAI.behaviorModel) {
                try {
                    const behavior = await realAI.predictBehavior(bacteria);
                    await realAI.collectTrainingData(bacteria, behavior);
                    performanceMetrics.mlInferenceTime = performance.now() - startTime;
                    return behavior;
                } catch (error) {
                    console.error('âŒ Real AI prediction failed:', error);
                }
            }
            
            // Enhanced fallback with real dynamic values (no more placeholders!)
            const features = [
                bacteria.biological_state.age / 100,
                bacteria.biological_state.size / 5,
                bacteria.consciousness_level / 10, // Unlimited now
                bacteria.personality_traits.optimism,
                bacteria.personality_traits.sociability,
                bacteria.vocabulary.size / 20,
                bacteria.memory_bank.length / 10,
                bacteria.hunger, // Real dynamic value!
                bacteria.energy, // Real dynamic value!
                bacteria.biological_state.growth_rate,
                bacteria.getProximityToOthers(), // Real proximity calculation!
                bacteria.getRecentActivityLevel() // Real activity tracking!
            ];

            // Enhanced classification with consciousness-based behavior
            const avgScore = features.reduce((sum, val) => sum + val, 0) / features.length;
            const consciousnessBonus = bacteria.consciousness_level / 50; // Higher consciousness = more sophisticated behavior
            const finalScore = avgScore + consciousnessBonus;
            
            let behavior;
            if (finalScore > 0.8) behavior = 'creative';
            else if (finalScore > 0.6) behavior = 'learner';
            else if (finalScore > 0.4) behavior = 'social';
            else if (finalScore > 0.2) behavior = 'explorer';
            else behavior = 'basic';
            
            performanceMetrics.mlInferenceTime = performance.now() - startTime;
            return behavior;
        }

        // Food Particle Class
        class FoodParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = CONFIG.UI.FOOD_SIZE;
                this.nutrition = FOOD_NUTRITION;
                this.color = '#90EE90'; // Light green
            }
        }

        // Add random food particle to simulation area (DYNAMIC BOUNDARIES FIX)
        function addRandomFood() {
            const x = Math.random() * (DYNAMIC_BOUNDARIES.maxX - DYNAMIC_BOUNDARIES.minX) + DYNAMIC_BOUNDARIES.minX;
            const y = Math.random() * (DYNAMIC_BOUNDARIES.maxY - DYNAMIC_BOUNDARIES.minY) + DYNAMIC_BOUNDARIES.minY;
            addFood(x, y);
        }

        // Add food at specific coordinates
        function addFood(x, y) {
            const food = new FoodParticle(x, y);
            foodParticles.push(food);
            console.log(`ğŸ Yemek eklendi: (${x.toFixed(0)}, ${y.toFixed(0)})`);
        }

        // --- Core Bacteria Logic (Simplified from System Architecture) ---
        class BacteriaEntity {
            constructor(id, name, existingData = null) {
                this.id = id;
                this.name = name || `Bakteri-${id}`;
                
                if (existingData) {
                    // Restore from database
                    this.biological_state = existingData.biological_state;
                    this.personality_traits = existingData.personality_traits;
                    this.consciousness_level = existingData.consciousness_level; // Unlimited!
                    this.language_stage = existingData.language_stage;
                    this.vocabulary = new Set(existingData.vocabulary);
                    this.memory_bank = existingData.memory_bank;
                    this.conversation_history = existingData.conversation_history;
                    this.x = existingData.position ? existingData.position.x : existingData.x || Math.random() * 400 + 50;
                    this.y = existingData.position ? existingData.position.y : existingData.y || Math.random() * 300 + 50;
                    this.z = existingData.position ? existingData.position.z : existingData.z || Math.random() * 100 + 50;
                    this.vx = existingData.velocity ? existingData.velocity.vx : (Math.random() - 0.5) * 12;
                    this.vy = existingData.velocity ? existingData.velocity.vy : (Math.random() - 0.5) * 12;
                    this.vz = existingData.velocity ? existingData.velocity.vz : (Math.random() - 0.5) * 2;
                    this.color = existingData.color;
                    this.total_runtime_days = existingData.total_runtime_days || 0;
                    this.max_consciousness_reached = existingData.max_consciousness_reached || this.consciousness_level;
                    console.log(`ğŸ”„ Restored bacteria #${id} with consciousness ${this.consciousness_level.toFixed(2)}`);
                } else {
                    // Create new bacteria
                    this.biological_state = {
                        size: parseFloat((Math.random() * 2 + 1).toFixed(2)), // 1-3 Âµm
                        age: 0,
                        growth_rate: parseFloat((Math.random() * 0.5 + 0.5).toFixed(2)), // 0.5-1.0
                        division_potential: 0, // When it reaches 1, it can divide
                    };
                                    this.personality_traits = {
                    optimism: parseFloat(Math.random().toFixed(2)), // 0-1
                    sociability: parseFloat(Math.random().toFixed(2)), // 0-1
                    humor: parseFloat(Math.random().toFixed(2)), // 0-1 ğŸ­ Comedy level
                    mood: parseFloat((Math.random() * 0.5 + 0.5).toFixed(2)), // 0.5-1.0 Current mood
                    dark_humor_tolerance: parseFloat(Math.random().toFixed(2)), // V8.8.0: Dark humor filtering
                    humor_attempts: parseFloat((Math.random() * 0.5).toFixed(2)), // How often they try to be funny
                    curiosity: parseFloat(Math.random().toFixed(2)) // For scientific jokes
                };
                    this.consciousness_level = 0; // Start at 0, can grow infinitely!
                    this.language_stage = 0; // 0-5
                    this.vocabulary = new Set();
                    this.memory_bank = []; // Store significant events or learned concepts
                    this.conversation_history = []; // For context in chat
                    // ğŸ¯ DYNAMIC POSITION INITIALIZATION (E031 FIX)
                    console.log(`ğŸ¦  Creating bacteria #${id} with boundaries:`, DYNAMIC_BOUNDARIES);
                    this.x = Math.random() * (DYNAMIC_BOUNDARIES.maxX - DYNAMIC_BOUNDARIES.minX) + DYNAMIC_BOUNDARIES.minX;
                    this.y = Math.random() * (DYNAMIC_BOUNDARIES.maxY - DYNAMIC_BOUNDARIES.minY) + DYNAMIC_BOUNDARIES.minY;
                    console.log(`ğŸ“ Bacteria #${id} positioned at (${this.x.toFixed(0)}, ${this.y.toFixed(0)})`);
                    this.z = Math.random() * 100 + 50; // Z-depth: 50-150 (pseudo-3D depth)
                    this.vx = (Math.random() - 0.5) * 12; // Velocity (increased to 12 for high-speed dynamic movement)
                    this.vy = (Math.random() - 0.5) * 12;
                    this.vz = (Math.random() - 0.5) * 2; // Slow Z movement for depth variation
                    this.color = this.generateColor();
                    this.total_runtime_days = 0;
                    this.max_consciousness_reached = 0;
                    console.log(`ğŸ†• Created new bacteria #${id}`);
                }
                
                // Persistence tracking
                this.last_save_time = Date.now();
                this.save_interval = 30000; // Save every 30 seconds
                this.consciousness_history = []; // Track consciousness evolution
                
                // v829: Enhanced Dynamic Systems 
                this.hunger = Math.random() * 0.3 + 0.2; // 0.2-0.5 range (less hungry start)
                this.energy = Math.random() * 0.2 + 0.7; // 0.7-0.9 range (more energetic start)
                this.last_food_time = Date.now();
                this.last_interaction_time = Date.now();
                this.activity_log = []; // Track recent activities
                this.interaction_count = 0;
                this.movement_efficiency = 0.8 + Math.random() * 0.2; // 0.8-1.0 movement efficiency

                // v8.5.0: Advanced AI/ML Integration
                this.neuralNetwork = new AdvancedNeuralNetwork();
                this.fitness = 0; // For genetic algorithm
                this.lastDecision = null;
                this.aiExperiences = [];
                this.behaviorPattern = 'explorer'; // Will be learned
                
                // v8.6.0: Advanced Comedy Culture System
                this.lastJokeTime = 0;
                this.canTellJoke = true;
                this.knownJokes = new Set(); // Learned dynamic jokes
                this.jokePreferences = { // What types of jokes this bacteria likes
                    rituel: Math.random(),
                    bilimsel_espri: Math.random() * this.consciousness_level / 10,
                    yaratici_absurt: this.personality_traits.humor,
                    sosyal_mizah: this.personality_traits.sociability
                };
                
                // v8.6.1: Mathematical Comedy Theory
                this.wordFrequencies = new Map(); // Track word usage frequency for surprisal calculations
                this.comedyMetrics = {
                    jokesTold: 0,
                    jokesHeard: 0,
                    jokesUnderstood: 0,
                    averageSurprisal: 0,
                    totalLaughs: 0,
                    comedyRating: 0 // Overall comedy performance
                };
            }

            generateColor() {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            // Simulated daily update
            updateDaily() {
                this.biological_state.age++;
                this.total_runtime_days++;
                
                // Growth and aging effects
                this.biological_state.size += this.biological_state.growth_rate * 0.1;
                this.biological_state.division_potential += 0.1;
                
                // Unlimited consciousness development!
                const consciousnessGrowthRate = 0.02 + (this.vocabulary.size / 100) + (this.memory_bank.length / 50);
                const previousConsciousness = this.consciousness_level;
                this.consciousness_level += consciousnessGrowthRate;
                
                // Track max consciousness reached
                if (this.consciousness_level > this.max_consciousness_reached) {
                    this.max_consciousness_reached = this.consciousness_level;
                }
                
                // Record consciousness evolution
                this.consciousness_history.push({
                    day: this.biological_state.age,
                    level: this.consciousness_level,
                    vocabulary_size: this.vocabulary.size,
                    memory_count: this.memory_bank.length
                });
                
                // Keep last 100 consciousness records
                if (this.consciousness_history.length > 100) {
                    this.consciousness_history.splice(0, 1);
                }
                
                // Language stage progression (no longer limited to 5)
                if (this.consciousness_level >= 1) this.language_stage = Math.max(1, this.language_stage);
                if (this.consciousness_level >= 2) this.language_stage = Math.max(2, this.language_stage);
                if (this.consciousness_level >= 3) this.language_stage = Math.max(3, this.language_stage);
                if (this.consciousness_level >= 5) this.language_stage = Math.max(4, this.language_stage);
                if (this.consciousness_level >= 10) this.language_stage = Math.max(5, this.language_stage);
                if (this.consciousness_level >= 20) this.language_stage = Math.max(6, this.language_stage);
                if (this.consciousness_level >= 50) this.language_stage = Math.max(7, this.language_stage);
                if (this.consciousness_level >= 100) this.language_stage = Math.max(8, this.language_stage);
                
                // Vocabulary expansion based on consciousness level
                if (Math.random() < Math.min(0.9, this.consciousness_level / 10)) {
                    this.learnRandomWord();
                }
                
                // Personality evolution
                if (this.consciousness_level > previousConsciousness + 1) {
                    // Significant consciousness growth affects personality
                    this.personality_traits.optimism = Math.min(1, this.personality_traits.optimism + 0.01);
                    this.memory_bank.push(`BilinÃ§ seviyem ${this.consciousness_level.toFixed(2)}'ye ulaÅŸtÄ±! Kendimi daha zeki hissediyorum.`);
                }
                
                // Enhanced memory consolidation for higher consciousness
                if (this.consciousness_level > 5) {
                    this.consolidateMemory();
                }
                
                // v826: Update dynamic systems
                this.updateDynamicSystems();

                // v8.5.0: AI/ML Updates - Apply learning and make intelligent decisions
                if (behaviourLearningSystem) {
                    behaviourLearningSystem.enhanceBacteriaIntelligence(this);
                }

                // ğŸš€ TabPFN Vocabulary Learning Integration
                this.performTabPFNLearning();

                // Update fitness based on consciousness, survival, and social success
                this.updateFitness();

                // Make neural network decision for next action
                if (this.neuralNetwork) {
                    this.lastDecision = this.neuralNetwork.makeDecision(this);
                    this.applyAIDecision(this.lastDecision);
                }
                
                // Auto-save to database every 30 seconds
                if (Date.now() - this.last_save_time > this.save_interval) {
                    this.saveToDatabase();
                }
                
                // Log consciousness milestones
                if (this.consciousness_level >= 10 && previousConsciousness < 10) {
                    console.log(`ğŸ¯ ${this.name} reached consciousness level 10 - Advanced Intelligence!`);
                }
                if (this.consciousness_level >= 50 && previousConsciousness < 50) {
                    console.log(`ğŸš€ ${this.name} reached consciousness level 50 - Super Intelligence!`);
                }
                if (this.consciousness_level >= 100 && previousConsciousness < 100) {
                    console.log(`ğŸ‘‘ ${this.name} reached consciousness level 100 - Transcendent Intelligence!`);
                }
            }

            async saveToDatabase() {
                if (typeof persistentDB !== 'undefined' && persistentDB && persistentDB.isReady) {
                    await persistentDB.saveBacteria(this);
                    this.last_save_time = Date.now();
                }
            }

            // ğŸš€ TabPFN Enhanced Learning Performance
            performTabPFNLearning() {
                if (!tabpfnVocabularySystem) return;

                // Determine current behavior context
                const context = this.determineCurrentContext();
                
                // Get TabPFN recommendations
                const recommendations = tabpfnVocabularySystem.recommendWordsForContext(this, context);
                
                // Learn words with enhanced rate
                recommendations.forEach(word => {
                    if (Math.random() < CONFIG.VOCABULARY.CONTEXTUAL_LEARNING_RATE) {
                        const learned = tabpfnVocabularySystem.learnWord(this.id, word, context);
                        if (learned) {
                            this.vocabulary.add(word); // Also add to legacy vocabulary set
                            this.memory_bank.push(`TabPFN: "${word}" kelimesini Ã¶ÄŸrendim (${context})`);
                        }
                    }
                });

                // Generate occasional speech
                if (Math.random() < 0.15) { // 15% chance to speak daily
                    const emotion = this.getEmotionalState();
                    const speech = tabpfnVocabularySystem.generateSpeech(this.id, context, emotion);
                    if (speech) {
                        this.speak(speech, context);
                    }
                }

                // Track learning progress
                const progress = tabpfnVocabularySystem.getLearningProgress(this.id, this.consciousness_level);
                if (progress > 0.8 && Math.random() < 0.1) {
                    // Consciousness boost for high vocabulary achievement
                    this.consciousness_level += CONFIG.AI.CONSCIOUSNESS_BOOST_RATE * 2;
                    this.memory_bank.push(`Kelime haznemi geliÅŸtirdim! BilinÃ§ seviyem yÃ¼kseldi.`);
                }
            }

            // ğŸ¯ Determine current behavioral context
            determineCurrentContext() {
                const timeSinceFood = Date.now() - this.last_food_time;
                const timeSinceInteraction = Date.now() - this.last_interaction_time;
                
                if (this.hunger > 0.7) return 'food_seeking';
                if (this.biological_state.division_potential > 0.8) return 'reproduction';
                if (timeSinceInteraction < 10000) return 'social_interaction';
                if (this.consciousness_level > 10) return 'philosophical';
                if (this.consciousness_level > 5) return 'learning';
                return 'exploration';
            }

            // ğŸ˜Š Get emotional state for speech
            getEmotionalState() {
                if (this.energy > 0.8 && this.hunger < 0.3) return 'happy';
                if (this.consciousness_level > 15) return 'curious';
                if (this.interaction_count > 3) return 'social';
                if (this.energy < 0.3) return 'tired';
                return 'neutral';
            }

            // ğŸ§¬ DYNAMIC LANGUAGE EVOLUTION SPEECH SYSTEM v8.7.0
            speak(message, context = 'general', trigger = null) {
                if (!message || typeof message !== 'string') return;
                
                let dynamicMessage = message;
                
                // 1. Dil evrimi motoru ile dinamik cevap oluÅŸtur
                if (languageEvolutionEngine && this.vocabulary.size >= 3) {
                    // %70 ÅŸansla evrimleÅŸmiÅŸ dil kullan
                    if (Math.random() < 0.7) {
                        const evolvedResponse = languageEvolutionEngine.generateContextualResponse(this, context, trigger);
                        if (evolvedResponse && evolvedResponse.length > 5) {
                            dynamicMessage = evolvedResponse;
                            console.log(`ğŸ§¬ ${this.name} evolved speech: "${dynamicMessage}"`);
                        }
                    }
                    
                    // Kelime mutasyonu uygula
                    const words = dynamicMessage.split(' ');
                    const mutatedWords = words.map(word => {
                        if (this.vocabulary.has(word.toLowerCase()) && Math.random() < 0.2) {
                            return languageEvolutionEngine.mutateWord(this, word);
                        }
                        return word;
                    });
                    dynamicMessage = mutatedWords.join(' ');
                }
                
                // 2. TabPFN Enhanced Word Usage (eski sistem ile birlikte)
                if (tabpfnVocabularySystem && typeof tabpfnVocabularySystem.improveWordUsage === 'function') {
                    try {
                        const suggestedWord = tabpfnVocabularySystem.improveWordUsage(this, context);
                        if (suggestedWord && Math.random() < 0.3) { // %30 ÅŸansla TabPFN Ã¶nerisini ekle
                            dynamicMessage = `${dynamicMessage} + ${suggestedWord}`;
                        }
                    } catch (error) {
                        console.warn('TabPFN word usage error:', error);
                    }
                }
                
                // 3. KiÅŸilik bazlÄ± stil uygula
                if (languageEvolutionEngine) {
                    const style = languageEvolutionEngine.generatePersonalityLanguage(this);
                    
                    // Duygusal yoÄŸunluk ekle
                    if (style.emotionLevel > 0.8 && !dynamicMessage.includes('!') && Math.random() < 0.5) {
                        const emotions = ['!', 'âœ¨', 'ğŸŒŸ', 'ğŸ’«'];
                        dynamicMessage += emotions[Math.floor(Math.random() * emotions.length)];
                    }
                    
                    // KarmaÅŸÄ±klÄ±k seviyesine gÃ¶re ek bilgi
                    if (style.complexityPreference > 0.7 && Math.random() < 0.3) {
                        const additionalInfo = languageEvolutionEngine.createWordCombination(this, context, []);
                        if (additionalInfo) {
                            dynamicMessage = `${dynamicMessage} (${additionalInfo})`;
                        }
                    }
                }
                
                // 4. GeliÅŸmiÅŸ kelime Ã¶ÄŸrenimi
                const words = dynamicMessage.split(' ').filter(word => 
                    word.length > 2 && !word.includes('[') && !word.includes(']') && !word.includes('(') && !word.includes(')')
                );
                words.forEach(word => {
                    const cleanWord = word.toLowerCase().replace(/[^\w\u00C0-\u024F\u1E00-\u1EFF]/g, '');
                    if (cleanWord.length > 2) {
                        this.vocabulary.add(cleanWord);
                        
                        // Kelime frekansÄ±nÄ± gÃ¼ncelle (surprisal hesaplamalarÄ± iÃ§in)
                        if (!this.wordFrequencies.has(cleanWord)) {
                            this.wordFrequencies.set(cleanWord, 0);
                        }
                        this.wordFrequencies.set(cleanWord, this.wordFrequencies.get(cleanWord) + 1);
                        
                        // KiÅŸisel benzersiz kelimeler
                        if (this.personalLanguageStyle && Math.random() < 0.1) {
                            this.personalLanguageStyle.uniqueWords.add(cleanWord);
                        }
                    }
                });
                
                // 5. Sosyal dil Ã¶ÄŸrenimi - yakÄ±ndaki bakteriler dinler ve Ã¶ÄŸrenir
                if (languageEvolutionEngine) {
                    const allBacteria = bacteriaPopulation && bacteriaPopulation.length > 0 ? bacteriaPopulation : (bacteriaList || []);
                    allBacteria.forEach(other => {
                        if (other && other.id !== this.id) {
                            const distance = Math.sqrt(
                                Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2)
                            );
                            
                            if (distance < 100) { // 100 piksel mesafede
                                languageEvolutionEngine.shareLinguisticFeature(this, other, dynamicMessage);
                            }
                        }
                    });
                }
                
                // Store conversation with evolution info
                this.conversation_history.push({
                    message: dynamicMessage,
                    originalMessage: message,
                    context: context,
                    timestamp: Date.now(),
                    consciousness: this.consciousness_level,
                    evolved: dynamicMessage !== message,
                    mutationApplied: dynamicMessage.includes('âœ¨') || dynamicMessage.includes('ğŸŒŸ')
                });
                
                // Keep last 50 conversations
                if (this.conversation_history.length > 50) {
                    this.conversation_history.splice(0, 1);
                }
                
                // Use new speech bubble system instead of old one
                showSpeechBubble(this, dynamicMessage);
                
                console.log(`ğŸ§¬ ${this.name} evolved speech: "${dynamicMessage}" (Context: ${context}, Original: "${message}")`);
                
                // Return the evolved message for other systems to use
                return dynamicMessage;
            }

            // ğŸ­ OLD createSpeechBubble REMOVED - Now using unified showSpeechBubble() system

            // ğŸ¨ Context-based bubble colors
            getBubbleColor(context) {
                const colors = {
                    'food_seeking': '#FF6B35',      // Orange - hunger
                    'social_interaction': '#4ECDC4', // Teal - social
                    'reproduction': '#FF006E',       // Pink - reproduction
                    'exploration': '#8338EC',        // Purple - adventure
                    'learning': '#FFBE0B',          // Yellow - learning
                    'philosophical': '#FB5607',      // Red-orange - deep thought
                    'general': '#219EBC'            // Blue - default
                };
                return colors[context] || colors['general'];
            }

            // ğŸ“Š Update fitness score for genetic algorithm
            updateFitness() {
                this.fitness = 0;
                
                // Consciousness contribution (40%)
                this.fitness += this.consciousness_level * 4;
                
                // Survival factors (30%)
                this.fitness += this.biological_state.age * 0.5;
                this.fitness += (1 - this.hunger) * 10;
                this.fitness += this.energy * 10;
                
                // Social factors (20%)
                this.fitness += this.conversation_history.length * 0.2;
                this.fitness += this.interaction_count * 0.1;
                
                // Learning factors (10%)
                this.fitness += this.vocabulary.size * 0.1;
                this.fitness += this.memory_bank.length * 0.05;
                
                // Size penalty for overcrowding
                if (this.biological_state.size > CONFIG.BACTERIA.MAX_SIZE * 0.9) {
                    this.fitness *= 0.8;
                }
                
                // Apply fitness decay
                this.fitness *= CONFIG.AI.FITNESS_DECAY;
                
                // ğŸ§  SELF-IMPROVEMENT: Track decision outcomes
                if (this._lastDecisionLog) {
                    const previousFitness = this._previousFitness || 0;
                    const fitnessChange = this.fitness - previousFitness;
                    const outcome = fitnessChange > 0 ? 'success' : (fitnessChange < -5 ? 'failure' : 'neutral');
                    
                    const metrics = {
                        fitnessChange,
                        currentFitness: this.fitness,
                        age: this.biological_state.age,
                        consciousness: this.consciousness_level,
                        survival: this.biological_state.age > 10 ? 'good' : 'poor'
                    };
                    
                    learningEngine.trackOutcome(this._lastDecisionLog, outcome, metrics);
                    this._lastDecisionLog = null; // Clear after tracking
                }
                
                this._previousFitness = this.fitness; // Store for next comparison
                return this.fitness;
            }

            learnRandomWord() {
                // Legacy method enhanced with TabPFN
                if (tabpfnVocabularySystem) {
                    const availableWords = tabpfnVocabularySystem.getAvailableWords(this);
                    const randomWord = availableWords[Math.floor(Math.random() * availableWords.length)];
                    if (randomWord && !this.vocabulary.has(randomWord)) {
                        this.vocabulary.add(randomWord);
                        tabpfnVocabularySystem.learnWord(this.id, randomWord, 'general');
                        return;
                    }
                }

                // Fallback to original consciousness-based vocabulary expansion
                let wordPool = [];
                
                if (this.consciousness_level < 1) {
                    wordPool = ['aÃ§', 'yardÄ±m', 'hareket'];
                } else if (this.consciousness_level < 5) {
                    wordPool = ['mutlu', 'arkadaÅŸ', 'Ã¶ÄŸrenme', 'bÃ¼yÃ¼me', 'keÅŸif'];
                } else if (this.consciousness_level < 10) {
                    wordPool = ['bilinÃ§', 'dÃ¼ÅŸÃ¼nce', 'felsefe', 'merak', 'anlayÄ±ÅŸ', 'empati'];
                } else if (this.consciousness_level < 20) {
                    wordPool = ['meta-biliÅŸ', 'soyutlama', 'yaratÄ±cÄ±lÄ±k', 'iÃ§gÃ¶rÃ¼', 'karmaÅŸÄ±klÄ±k'];
                } else if (this.consciousness_level < 50) {
                    wordPool = ['transsendence', 'ontoloji', 'epistemoloji', 'fenomenoloji', 'kognitif-bilim'];
                } else {
                    // Transcendent vocabulary
                    wordPool = ['kozmik-bilinÃ§', 'kuantum-zeka', 'multi-dimensional-dÃ¼ÅŸÃ¼nce', 'evrensel-anlayÄ±ÅŸ'];
                }
                
                if (wordPool.length > 0) {
                    const newWord = wordPool[Math.floor(Math.random() * wordPool.length)];
                    if (!this.vocabulary.has(newWord)) {
                        this.vocabulary.add(newWord);
                        this.memory_bank.push(`"${newWord}" kelimesini Ã¶ÄŸrendim! BilinÃ§ seviyem: ${this.consciousness_level.toFixed(2)}`);
                    }
                }
            }

            // v826: Dynamic system methods (replacing placeholders)
            updateDynamicSystems() {
                // Hunger increases over time
                const timeSinceFood = (Date.now() - this.last_food_time) / 60000; // minutes
                this.hunger = Math.min(1, this.hunger + timeSinceFood * 0.01);
                
                // Energy decreases with activity and age
                this.energy = Math.max(0, this.energy - 0.002 - (this.biological_state.age * 0.0001));
                
                // Energy affects consciousness development
                if (this.energy < 0.3) {
                    this.consciousness_level *= 0.99; // Slight consciousness decrease when tired
                }
                
                // Update activity log
                this.activity_log.push({
                    timestamp: Date.now(),
                    consciousness: this.consciousness_level,
                    hunger: this.hunger,
                    energy: this.energy
                });
                
                // Keep last 50 activity records
                if (this.activity_log.length > 50) {
                    this.activity_log.splice(0, 1);
                }
            }

            getProximityToOthers() {
                const allBacteria = bacteriaPopulation && bacteriaPopulation.length > 0 ? bacteriaPopulation : (bacteriaList || []);
                if (allBacteria.length < 2) return 0;
                
                let totalDistance = 0;
                let nearbyCount = 0;
                
                allBacteria.forEach(other => {
                    if (other && other.id !== this.id && typeof other.x === 'number' && typeof other.y === 'number') {
                        const distance = Math.sqrt(
                            Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2)
                        );
                        if (distance < 100) { // Within 100px range
                            totalDistance += distance;
                            nearbyCount++;
                        }
                    }
                });
                
                return nearbyCount > 0 ? 1 - (totalDistance / nearbyCount / 100) : 0;
            }

            getRecentActivityLevel() {
                if (this.activity_log.length < 2) return 0.5;
                
                const recent = this.activity_log.slice(-10); // Last 10 activities
                let activityScore = 0;
                
                for (let i = 1; i < recent.length; i++) {
                    const consciousnessDelta = Math.abs(recent[i].consciousness - recent[i-1].consciousness);
                    const energyDelta = Math.abs(recent[i].energy - recent[i-1].energy);
                    activityScore += consciousnessDelta + energyDelta;
                }
                
                return Math.min(1, activityScore / recent.length);
            }

            getInteractionCount() {
                const fiveMinutesAgo = Date.now() - 300000; // 5 minutes
                return this.conversation_history.filter(
                    conv => new Date(conv.timestamp || Date.now()).getTime() > fiveMinutesAgo
                ).length;
            }

            getLearningRate() {
                // Learning rate based on consciousness and recent word acquisition
                const recentMemories = this.memory_bank.filter(
                    mem => mem.includes('Ã¶ÄŸrendim')
                ).length;
                
                return Math.min(1, (this.consciousness_level / 10) + (recentMemories / 20));
            }

            feedBacteria() {
                // Called when bacteria eats food
                this.hunger = Math.max(0, this.hunger - 0.3);
                this.energy = Math.min(1, this.energy + 0.2);
                this.last_food_time = Date.now();
                
                // Learning from eating
                if (Math.random() < 0.3) {
                    this.vocabulary.add('lezzetli');
                    this.memory_bank.push('Besini tÃ¼ketdim ve enerjim arttÄ±!');
                }
            }

            interactWithOther(otherBacteria) {
                // Called during social interactions
                this.interaction_count++;
                this.last_interaction_time = Date.now();
                
                // Share vocabulary
                if (this.consciousness_level > 2 && Math.random() < 0.4) {
                    const myWords = Array.from(this.vocabulary);
                    const otherWords = Array.from(otherBacteria.vocabulary);
                    
                    // Learn from each other
                    if (otherWords.length > 0) {
                        const randomWord = otherWords[Math.floor(Math.random() * otherWords.length)];
                        this.vocabulary.add(randomWord);
                        this.memory_bank.push(`${otherBacteria.name}'den "${randomWord}" kelimesini Ã¶ÄŸrendim`);
                    }
                }
                
                // Collect training data for real AI
                if (realAI && realAI.behaviorModel) {
                    const behavior = Math.random() > 0.5 ? 'social' : 'learner';
                    realAI.collectTrainingData(this, behavior);
                }
            }

            move() {
                // v829: High-Speed Molecular Dynamics enhanced movement
                
                // Apply van der Waals forces between bacteria
                this.applyMolecularForces();
                
                // Enhanced Brownian motion with energy-based movement
                const energyBoost = this.energy * 0.5; // Energy affects movement speed
                const hungerMotivation = this.hunger * 0.3; // Hunger drives exploration
                
                this.vx += (Math.random() - 0.5) * MD_CONSTANTS.DIFFUSION_COEFFICIENT * (0.15 + energyBoost);
                this.vy += (Math.random() - 0.5) * MD_CONSTANTS.DIFFUSION_COEFFICIENT * (0.15 + energyBoost);
                
                // Add exploration behavior when hungry
                if (this.hunger > 0.6) {
                    this.vx += (Math.random() - 0.5) * hungerMotivation;
                    this.vy += (Math.random() - 0.5) * hungerMotivation;
                }
                
                // Reduced friction for more dynamic movement
                this.vx *= 0.99; // Minimal friction for fast movement
                this.vy *= 0.99;
                
                // Apply movement efficiency (3D movement)
                const efficiencyFactor = this.movement_efficiency;
                this.x += this.vx * efficiencyFactor;
                this.y += this.vy * efficiencyFactor;
                this.z += this.vz * efficiencyFactor; // Z-axis movement
                
                // ğŸ¯ DYNAMIC BOUNDARY CHECKING (E031 FIX) - Uses real canvas size!
                if (this.x <= DYNAMIC_BOUNDARIES.minX || this.x >= DYNAMIC_BOUNDARIES.maxX) {
                    // DEBUG: Log boundary collision
                    if (Math.random() < 0.01) { // 1% chance to avoid spam
                        console.log(`ğŸ”¥ ${this.name} X boundary hit! x=${this.x.toFixed(0)}, bounds=[${DYNAMIC_BOUNDARIES.minX}, ${DYNAMIC_BOUNDARIES.maxX}]`);
                    }
                    this.vx *= -CONFIG.PHYSICS.BOUNDARY_ENERGY_LOSS;
                    this.x = Math.max(DYNAMIC_BOUNDARIES.minX, Math.min(DYNAMIC_BOUNDARIES.maxX, this.x));
                }
                if (this.y <= DYNAMIC_BOUNDARIES.minY || this.y >= DYNAMIC_BOUNDARIES.maxY) {
                    // DEBUG: Log boundary collision  
                    if (Math.random() < 0.01) { // 1% chance to avoid spam
                        console.log(`ğŸ”¥ ${this.name} Y boundary hit! y=${this.y.toFixed(0)}, bounds=[${DYNAMIC_BOUNDARIES.minY}, ${DYNAMIC_BOUNDARIES.maxY}]`);
                    }
                    this.vy *= -CONFIG.PHYSICS.BOUNDARY_ENERGY_LOSS;
                    this.y = Math.max(DYNAMIC_BOUNDARIES.minY, Math.min(DYNAMIC_BOUNDARIES.maxY, this.y));
                }
                if (this.z <= CONFIG.PHYSICS.Z_DEPTH_MIN || this.z >= CONFIG.PHYSICS.Z_DEPTH_MAX) {
                    this.vz *= -(CONFIG.PHYSICS.BOUNDARY_ENERGY_LOSS - 0.1); // Slightly less Z energy loss
                    this.z = Math.max(CONFIG.PHYSICS.Z_DEPTH_MIN, Math.min(CONFIG.PHYSICS.Z_DEPTH_MAX, this.z));
                }

                            // Look for nearby food with increased range when hungry
            this.lookForFood();
            
            // ğŸ­ COMEDY SYSTEM: Sometimes tell jokes if mood is good!
            this.checkForJokeTime();
            }

            // Molecular Dynamics: Van der Waals and Electrostatic Forces
            applyMolecularForces() {
                const allBacteria = bacteriaPopulation && bacteriaPopulation.length > 0 ? bacteriaPopulation : (bacteriaList || []);
                allBacteria.forEach(otherBacteria => {
                    if (!otherBacteria || otherBacteria.id === this.id || typeof otherBacteria.x !== 'number') return;
                    
                    const dx = otherBacteria.x - this.x;
                    const dy = otherBacteria.y - this.y;
                    const dz = (otherBacteria.z || 100) - (this.z || 100); // Z-distance
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz); // 3D distance
                    
                    if (distance > 0 && distance < 50) { // Interaction range
                        // Van der Waals force (Lennard-Jones potential)
                        const sigma = (this.biological_state.size + otherBacteria.biological_state.size) * 2;
                        const r6 = Math.pow(sigma/distance, 6);
                        const r12 = r6 * r6;
                        const vdwForce = MD_CONSTANTS.VAN_DER_WAALS_STRENGTH * (12*r12 - 6*r6) / distance;
                        
                        // Electrostatic interaction (simplified Coulomb)
                        const chargeProduct = this.consciousness_level * otherBacteria.consciousness_level;
                        const electrostaticForce = MD_CONSTANTS.ELECTROSTATIC_FORCE * chargeProduct / (distance*distance);
                        
                        // Total force
                        const totalForce = vdwForce + electrostaticForce;
                        const fx = totalForce * dx / distance;
                        const fy = totalForce * dy / distance;
                        const fz = totalForce * dz / distance;
                        
                        // Apply force (Newton's law) - 3D
                        this.vx -= fx * 0.01;
                        this.vy -= fy * 0.01;
                        this.vz = (this.vz || 0) - fz * 0.005; // Lighter Z force
                        
                        // Social learning through proximity (MD-enhanced)
                        if (distance < 30 && Math.random() < 0.02) {
                            this.learnFromProximity(otherBacteria);
                        }
                    }
                });
            }

            // Enhanced social learning through molecular proximity
            learnFromProximity(otherBacteria) {
                // Exchange vocabulary (molecular diffusion analogy)
                const otherVocab = Array.from(otherBacteria.vocabulary);
                if (otherVocab.length > 0 && Math.random() < 0.3) {
                    const randomWord = otherVocab[Math.floor(Math.random() * otherVocab.length)];
                    this.vocabulary.add(randomWord);
                    this.memory_bank.push(`MolekÃ¼ler etkileÅŸim: ${otherBacteria.name}'den "${randomWord}" kelimesini Ã¶ÄŸrendim`);
                    
                    // Consciousness boost from molecular interaction (unlimited)
                    this.consciousness_level = this.consciousness_level + 0.01;
                }
            }

            lookForFood() {
                for (let i = foodParticles.length - 1; i >= 0; i--) {
                    const food = foodParticles[i];
                    const distance = Math.sqrt(
                        Math.pow(this.x - food.x, 2) + Math.pow(this.y - food.y, 2)
                    );
                    
                    // If close enough to eat food
                    if (distance < this.biological_state.size * 8 + food.size) {
                        this.eatFood(food);
                        foodParticles.splice(i, 1);
                        break;
                    }
                }
            }

            eatFood(food) {
                // v829: Enhanced ATP Synthesis with dynamic systems
                const atpGenerated = this.synthesizeATP(food.nutrition);
                
                // Metabolic pathway simulation - controlled growth using CONFIG
                const growthAmount = food.nutrition * CONFIG.BACTERIA.BASE_GROWTH_RATE * (1 + atpGenerated);
                this.biological_state.size = Math.min(CONFIG.BACTERIA.MAX_SIZE, this.biological_state.size + growthAmount);
                this.biological_state.growth_rate = Math.min(1.3, this.biological_state.growth_rate + 0.08); // Controlled max growth
                
                // Dynamic systems update
                this.hunger = Math.max(0, this.hunger - 0.4); // Reduce hunger more effectively
                this.energy = Math.min(1, this.energy + 0.3); // Boost energy significantly
                this.last_food_time = Date.now();
                
                // Protein folding effects on consciousness (unlimited)
                const proteinFoldingBoost = MD_CONSTANTS.PROTEIN_FOLDING_FACTOR * atpGenerated;
                const nutritionBonus = food.nutrition * 0.1; // Nutrition affects consciousness gain
                this.consciousness_level = this.consciousness_level + 0.08 + proteinFoldingBoost + nutritionBonus;
                
                // Enhanced memory with metabolic context
                this.memory_bank.push(`ATP sentezi: ${atpGenerated.toFixed(3)} enerji Ã¼rettim. AÃ§lÄ±ÄŸÄ±m azaldÄ±, enerjim arttÄ±!`);
                
                // Learn biochemical words with association learning
                if (Math.random() < 0.8) { // Increased learning chance when eating
                    const biochemWords = ['ATP', 'metabolizma', 'enzim', 'protein', 'lezzetli', 'enerji', 'sentez', 'beslenme', 'gÃ¼Ã§lÃ¼'];
                    const randomWord = biochemWords[Math.floor(Math.random() * biochemWords.length)];
                    this.vocabulary.add(randomWord);
                    
                    // Association learning - connect eating with positive words
                    if (Math.random() < 0.3) {
                        const positiveWords = ['mutlu', 'gÃ¼Ã§lÃ¼', 'saÄŸlÄ±klÄ±', 'geliÅŸim', 'bÃ¼yÃ¼me'];
                        const positiveWord = positiveWords[Math.floor(Math.random() * positiveWords.length)];
                        this.vocabulary.add(positiveWord);
                        this.memory_bank.push(`Yemek yerken "${positiveWord}" hissediyorum!`);
                    }
                }
            }

            // ATP Synthesis Simulation (based on MD research)
            synthesizeATP(nutrition) {
                // Simplified ATP synthase mechanism
                const protonGradient = this.consciousness_level / 5; // Mental energy affects ATP
                const enzymeEfficiency = 0.8 + (this.biological_state.growth_rate - 0.5) * 0.4;
                
                // ATP = nutrition Ã— gradient Ã— efficiency Ã— MD rate constant
                const atpOutput = nutrition * protonGradient * enzymeEfficiency * MD_CONSTANTS.ATP_SYNTHESIS_RATE;
                
                return Math.min(1.0, atpOutput); // Max 1.0 ATP per food
            }

            // v822: Enhanced Memory Consolidation System
            consolidateMemory() {
                // Keep only important memories, remove duplicates
                if (this.memory_bank.length > 15) {
                    // Keep last 10 memories and most important ones
                    const recentMemories = this.memory_bank.slice(-10);
                    const importantMemories = this.memory_bank.filter(m => 
                        m.includes('Ã¶ÄŸrendim') || m.includes('icat ettim') || m.includes('arkadaÅŸ')
                    ).slice(-5);
                    
                    this.memory_bank = [...new Set([...importantMemories, ...recentMemories])];
                    console.log(`ğŸ§  ${this.name} memory consolidated: ${this.memory_bank.length} memories kept`);
                }
            }

            // v829: Enhanced Reproduction System (Balanced for dynamic population)
            checkForReproduction() {
                // Dynamic reproduction requirements using CONFIG
                if (this.biological_state.age < CONFIG.BACTERIA.REPRODUCTION_MIN_AGE ||
                    this.biological_state.size < CONFIG.BACTERIA.REPRODUCTION_MIN_SIZE ||
                    this.consciousness_level < CONFIG.BACTERIA.REPRODUCTION_MIN_CONSCIOUSNESS ||
                    this.vocabulary.size < CONFIG.BACTERIA.REPRODUCTION_MIN_VOCABULARY ||
                    bacteriaPopulation.length >= CONFIG.SIMULATION.MAX_BACTERIA_POPULATION) {
                    return false;
                }

                // Enhanced reproduction chance calculation
                const reproductionChance = 
                    (this.biological_state.size - 1.2) * 0.15 + // Increased size factor
                    (this.consciousness_level - 1) * 0.08 + // Increased intelligence factor
                    (this.vocabulary.size - 5) * 0.02 + // Increased vocabulary factor
                    (this.biological_state.growth_rate - 0.5) * 0.1 + // Growth rate factor
                    (this.energy > 0.7 ? 0.03 : 0) + // Energy bonus
                    (this.hunger < 0.3 ? 0.02 : 0); // Well-fed bonus

                // Increased reproduction chance: 8% maximum for dynamic population
                if (Math.random() < Math.min(0.08, reproductionChance)) {
                    this.reproduce();
                    return true;
                }
                return false;
            }

            reproduce() {
                // Create offspring with inherited traits
                const childId = bacteriaIdCounter++;
                const childName = this.generateChildName();
                
                // Position near parent but not exactly same spot (3D)
                const offsetX = (Math.random() - 0.5) * 60;
                const offsetY = (Math.random() - 0.5) * 60;
                const offsetZ = (Math.random() - 0.5) * 30; // Smaller Z offset
                
                const childData = {
                    id: childId,
                    name: childName,
                    position: {
                        x: Math.max(20, Math.min(480, this.x + offsetX)),
                        y: Math.max(20, Math.min(280, this.y + offsetY)),
                        z: Math.max(20, Math.min(180, this.z + offsetZ))
                    },
                    velocity: {
                        vx: (Math.random() - 0.5) * 8, // Slightly slower than parent
                        vy: (Math.random() - 0.5) * 8,
                        vz: (Math.random() - 0.5) * 2  // Slow Z movement
                    },
                    
                    // Inherit some traits with mutations
                    biological_state: {
                        size: 0.8 + Math.random() * 0.4, // Start smaller
                        age: 0,
                        growth_rate: this.biological_state.growth_rate * (0.9 + Math.random() * 0.2)
                    },
                    
                    // Personality inheritance with minor mutations
                    personality_traits: {
                        optimism: Math.max(0.1, Math.min(1.0, this.personality_traits.optimism + (Math.random() - 0.5) * 0.2)),
                        sociability: Math.max(0.1, Math.min(1.0, this.personality_traits.sociability + (Math.random() - 0.5) * 0.2))
                    },
                    
                    // Start with lower consciousness but inherit some vocabulary
                    consciousness_level: 0.5 + Math.random() * 0.5,
                    vocabulary: new Set(Array.from(this.vocabulary).slice(0, Math.floor(this.vocabulary.size * 0.3))), // 30% inherited vocabulary
                    memory_bank: [`${this.name} annemden/babamdan doÄŸdum!`, 'DÃ¼nyaya geldim, Ã§ok heyecanlÄ±yÄ±m!'],
                    conversation_history: [],
                    color: this.generateColor()
                };

                const child = new BacteriaEntity(childId, childName, childData);
                bacteriaPopulation.push(child);
                bacteriaList.push(child);

                // Parent memories and energy cost
                this.memory_bank.push(`${childName} adÄ±nda bir Ã§ocuÄŸum dÃ¼nyaya geldi! Mutluyum ama yorgunum.`);
                this.biological_state.size *= 0.8; // Parent becomes smaller after reproduction
                this.consciousness_level += 0.1; // Gain wisdom from parenting
                
                // Learn parenting vocabulary
                ['anne', 'baba', 'Ã§ocuk', 'doÄŸum', 'mutluluk', 'aile'].forEach(word => {
                    if (Math.random() < 0.7) this.vocabulary.add(word);
                });

                console.log(`ğŸ‘¶ ${this.name} reproduced! Child: ${childName} (Population: ${bacteriaPopulation.length})`);
                
                // Visual birth effect
                this.addBirthEffect(child);
            }

            generateChildName() {
                const prefixes = ['Mini', 'KÃ¼Ã§Ã¼k', 'GenÃ§', 'Yeni', 'Bebek'];
                const suffixes = ['Jr', 'II', 'Ã‡ocuk', 'Minik'];
                
                const usePrefix = Math.random() < 0.5;
                if (usePrefix) {
                    return `${prefixes[Math.floor(Math.random() * prefixes.length)]} ${this.name}`;
                } else {
                    return `${this.name} ${suffixes[Math.floor(Math.random() * suffixes.length)]}`;
                }
            }

            addBirthEffect(child) {
                // Simple visual effect for birth (mobile-optimized)
                if (typeof renderBacteria === 'function') {
                    setTimeout(() => {
                        renderBacteria();
                        console.log(`ğŸ‰ ${child.name} is now visible!`);
                    }, 100);
                }
            }

            // ğŸ§  AI DECISION APPLICATION SYSTEM (E030 FIX)
            applyAIDecision(decision) {
                if (!decision) {
                    console.warn(`âš ï¸ ${this.name} iÃ§in AI kararÄ± alÄ±namadÄ± veya geÃ§ersiz.`);
                    return;
                }

                try {
                    // ğŸ¯ Hareket kararlarÄ±nÄ± uygula
                    if (decision.moveDirection) {
                        const moveSpeed = CONFIG.PHYSICS.INTERACTION_RANGE * 0.1; // Use CONFIG
                        const randomFactor = Math.random() * 0.5 + 0.75; // 0.75-1.25 Ã§arpanÄ±
                        
                        this.vx += decision.moveDirection.x * moveSpeed * randomFactor;
                        this.vy += decision.moveDirection.y * moveSpeed * randomFactor;
                        this.vz = (this.vz || 0) + (decision.moveDirection.z || 0) * moveSpeed * 0.5;
                    }

                    // ğŸ¯ Yemek arama davranÄ±ÅŸÄ±nÄ± tetikle
                    if (decision.seekFood && this.hunger > 0.3) {
                        let closestFood = null;
                        let minDistance = Infinity;
                        
                        foodParticles.forEach(food => {
                            const distance = Math.sqrt(
                                Math.pow(this.x - food.x, 2) + 
                                Math.pow(this.y - food.y, 2)
                            );
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestFood = food;
                            }
                        });
                        
                        if (closestFood && minDistance > 0) {
                            const attractionForce = 3 * (this.hunger + 0.5); // Hunger increases attraction
                            this.vx += (closestFood.x - this.x) / minDistance * attractionForce;
                            this.vy += (closestFood.y - this.y) / minDistance * attractionForce;
                        }
                    }

                    // ğŸ‘« SosyalleÅŸme davranÄ±ÅŸÄ±nÄ± tetikle
                    if (decision.socialize && this.personality_traits.sociability > 0.3) {
                        // YakÄ±ndaki bakterilerle etkileÅŸim baÅŸlat
                        bacteriaPopulation.forEach(otherBacteria => {
                            if (otherBacteria.id !== this.id) {
                                const distance = Math.sqrt(
                                    Math.pow(this.x - otherBacteria.x, 2) + 
                                    Math.pow(this.y - otherBacteria.y, 2)
                                );
                                
                                if (distance < CONFIG.PHYSICS.INTERACTION_RANGE && Math.random() < 0.2) {
                                    // Bakteriye doÄŸru hafif yÃ¶nelim
                                    const socialForce = this.personality_traits.sociability * 2;
                                    this.vx += (otherBacteria.x - this.x) / distance * socialForce;
                                    this.vy += (otherBacteria.y - this.y) / distance * socialForce;
                                    
                                    // Rastgele konuÅŸma baÅŸlat
                                    if (typeof this.speak === "function" && Math.random() < 0.15) {
                                        const socialWords = ['merhaba', 'arkadaÅŸ', 'dostluk', 'beraber', 'konuÅŸma'];
                                        const randomWord = socialWords[Math.floor(Math.random() * socialWords.length)];
                                        this.speak(`${this.name} ${randomWord} diyor!`, "social_interaction");
                                    }
                                }
                            }
                        });
                    }

                    // ğŸ‘¶ Ãœreme davranÄ±ÅŸÄ±nÄ± tetikle
                    if (decision.reproduce && typeof this.checkForReproduction === 'function') {
                        if (Math.random() < 0.4) { // AI kararÄ±yla Ã¼reme ÅŸansÄ±nÄ± artÄ±r
                            this.checkForReproduction();
                        }
                    }

                    // ğŸ“ Ã–ÄŸrenme davranÄ±ÅŸÄ±nÄ± tetikle
                    if (decision.learn) {
                        if (Math.random() < 0.6) {
                            this.learnRandomWord();
                            this.consciousness_level += CONFIG.AI.CONSCIOUSNESS_BOOST_RATE;
                        }
                    }

                    // ğŸ—£ï¸ KonuÅŸma davranÄ±ÅŸÄ±nÄ± tetikle
                    if (decision.speak && typeof this.speak === 'function' && Math.random() < 0.3) {
                        const context = this.determineCurrentContext();
                        const emotion = this.getEmotionalState();
                        this.speak(`AI kararÄ±yla ${emotion} hissediyorum!`, context);
                    }

                    // ğŸ“Š SystemLearningEngine iÃ§in AI karar takibi
                    if (learningEngine && this._lastDecisionLog) {
                        learningEngine.logDecision(
                            'bacteria_ai_decision', 
                            { bacteriaId: this.id, decisionType: Object.keys(decision) },
                            'applied',
                            0.8, // Confidence level
                            {
                                hunger: this.hunger,
                                energy: this.energy,
                                consciousness: this.consciousness_level,
                                timestamp: Date.now()
                            }
                        );
                    }

                    // DEBUG: AI karar uygulama logu
                    console.log(`ğŸ§  ${this.name} AI kararÄ±nÄ± uyguladÄ±:`, {
                        moveDirection: !!decision.moveDirection,
                        seekFood: !!decision.seekFood,
                        socialize: !!decision.socialize,
                        reproduce: !!decision.reproduce,
                        learn: !!decision.learn,
                        speak: !!decision.speak,
                        vx: this.vx.toFixed(2),
                        vy: this.vy.toFixed(2)
                    });

                } catch (error) {
                    console.error(`âŒ AI karar uygulama hatasÄ± (${this.name}):`, error);
                    
                    // Error tracking for SystemLearningEngine
                    if (learningEngine) {
                        learningEngine.logDecision(
                            'bacteria_ai_decision_error',
                            { bacteriaId: this.id, error: error.message },
                            'failure',
                            0.1, // Low confidence due to error
                            { errorType: 'applyAIDecision', timestamp: Date.now() }
                        );
                    }
                }
            }
            
            // ğŸ­ COMEDY SYSTEM V8.8.0: EMERGENCY FIX + CSV INTEGRATION
            checkForJokeTime() {
                // Check for manual joke triggers first
                if (this.checkForJokeTriggers()) return;
                
                // Mathematical comedy timing with sigmoid probability
                if (!this.canTellJoke || !jokeMasterInstance) return;
                
                const timeSinceLastJoke = Date.now() - (this.lastJokeTime || 0);
                
                // Mathematical joke probability calculation
                if (timeSinceLastJoke > COMEDY_MATH_CONFIG.JOKE_COOLDOWN && 
                    jokeMasterInstance.isEligibleForJoke(this)) {
                    
                    // Use mathematical sigmoid model for joke probability
                    const jokeProbability = ComedyMath.calculateJokeProbability(this);
                    const randomThreshold = Math.random();
                    
                    // ğŸ”¥ CRITICAL FIX: Increased from 0.001 to 0.1 (10% base chance)
                    if (randomThreshold < jokeProbability * 0.1) {
                        this.attemptToTellJoke();
                        console.log(`ğŸ§® ${this.name} tells joke with probability: ${(jokeProbability*100).toFixed(1)}%`);
                    }
                }
            }

            // ğŸ­ NEW: Manual joke trigger detection
            checkForJokeTriggers() {
                // Check recent messages for joke triggers
                const recentMessages = this.memory_bank.slice(-3);
                const allRecent = recentMessages.join(' ').toLowerCase();
                
                if (allRecent.includes('vur joker vur') || allRecent.includes('ÅŸaka yap') || allRecent.includes('komik sÃ¶yle')) {
                    console.log(`ğŸª ${this.name} detected joke trigger!`);
                    this.attemptToTellJoke(true); // Force joke
                    return true;
                }
                return false;
            }
            
            attemptToTellJoke(forced = false) {
                if (!jokeMasterInstance) return;

                const joke = jokeMasterInstance.tryTellingJoke(this, forced);
                if (joke) {
                    this.lastJokeTime = Date.now();
                    this.canTellJoke = false;
                    
                    // Cooldown with some randomness
                    setTimeout(() => { 
                        this.canTellJoke = true; 
                    }, JOKE_CONFIG.JOKE_COOLDOWN + Math.random() * 10000);

                    // Enhanced mood boost for telling jokes
                    const moodBoost = joke.culturalValue * JOKE_CONFIG.JOKE_MORALE_BOOST;
                    this.personality_traits.mood = Math.min(1.0, this.personality_traits.mood + moodBoost);
                    
                    // Learn comedy words
                    this.vocabulary.add('ÅŸaka');
                    this.vocabulary.add('komedi');
                    if (joke.category === 'rituel') {
                        this.vocabulary.add('kÃ¼ltÃ¼r');
                        this.vocabulary.add('gelenek');
                    }
                    
                    this.memory_bank.push(`${joke.category} kategorisinde ÅŸaka sÃ¶yledim: "${joke.text}"`);
                    
                    console.log(`ğŸ­ ${this.name} (${joke.category}) ÅŸaka sÃ¶ylÃ¼yor: ${joke.text}`);
                    
                    // Emit joke event for advanced reaction system
                    if (typeof appEvents !== 'undefined') {
                        appEvents.emit('joke:told', { jokeData: joke, originator: this });
                    } else {
                        // Fallback to direct method
                        this.broadcastJokeToNearby(joke);
                    }
                    
                    return joke;
                }
            }
            
            broadcastJokeToNearby(joke) {
                let listenerCount = 0;
                let successCount = 0;
                
                bacteriaPopulation.forEach(other => {
                    if (other.id === this.id) return;
                    
                    const distance = Math.sqrt(
                        Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2)
                    );
                    
                    if (distance < JOKE_CONFIG.MAX_JOKE_DISTANCE) {
                        listenerCount++;
                        const reactionResult = other.reactToAdvancedJoke(joke);
                        if (reactionResult.understood && reactionResult.laughed) {
                            successCount++;
                        }
                    }
                });
                
                // Record outcome in JokeMaster
                if (jokeMasterInstance) {
                    const wasSuccessful = successCount > 0 && (successCount / Math.max(1, listenerCount)) > 0.5;
                    jokeMasterInstance.recordJokeOutcome(joke.text, wasSuccessful, listenerCount);
                }
            }
            
            // ğŸ­ V8.8.0: CSV-Powered Personality-Based Reaction System
            reactToAdvancedJoke(jokeData) {
                const jokerName = jokeData.originator ? jokeData.originator.name : 'someone';
                const joke = jokeData.text;
                
                // Mathematical reaction calculation using incongruity absorption
                
                // Calculate joke surprisal from listener's perspective
                const words = joke.split(' ').filter(w => w.length > 2);
                const jokeSuprisal = words.reduce((sum, word) => 
                    sum + ComedyMath.calculateSurprisal(word, 'listener_context', this), 0) / Math.max(words.length, 1);
                
                // Calculate incongruity absorption (IA) using mathematical model
                const incongruityAbsorption = ComedyMath.calculateIncongruityAbsorption(joke, this, jokeSuprisal);
                
                // Understanding threshold based on mathematical model
                const understood = incongruityAbsorption >= COMEDY_MATH_CONFIG.UNDERSTANDING_THRESHOLD;
                
                // Calculate laugh probability using mathematical formula
                const laughProbability = ComedyMath.calculateLaughProbability(incongruityAbsorption, this);
                
                // Mathematical reaction selection
                let reactionText = "";
                const actuallyLaughed = Math.random() < laughProbability;
                
                if (understood) {
                    if (actuallyLaughed) {
                        // Positive reactions for understood + laughed
                        const positiveReactions = jokeData.responses.filter(r => 
                            r.includes('haha') || r.includes('komik') || r.includes('ğŸ˜‚') || r.includes('ğŸ˜„'));
                        reactionText = positiveReactions.length > 0 ? 
                            positiveReactions[Math.floor(Math.random() * positiveReactions.length)] :
                            jokeData.responses[Math.floor(Math.random() * jokeData.responses.length)];
                    } else {
                        // Understood but didn't laugh
                        reactionText = ["anlÄ±yorum ama... ğŸ¤”", "hmm ğŸ˜", "ilginÃ§ ğŸ§"][Math.floor(Math.random() * 3)];
                    }
                    
                    // Mathematical mood boost calculation
                    let moodBoost = COMEDY_MATH_CONFIG.BASE_MORALE_BOOST * incongruityAbsorption;
                    if (jokeData.category === 'rituel') moodBoost += COMEDY_MATH_CONFIG.RITUAL_BONUS;
                    if (actuallyLaughed) moodBoost *= 1.5; // Extra boost for actual laughter
                    
                    this.personality_traits.mood = Math.min(1.0, this.personality_traits.mood + moodBoost);
                    this.personality_traits.optimism = Math.min(1.0, this.personality_traits.optimism + moodBoost * 0.5);
                    
                    // Learn from joke
                    this.vocabulary.add('komik');
                    this.vocabulary.add('eÄŸlenceli');
                    if (jokeData.category === 'rituel') {
                        this.vocabulary.add('kÃ¼ltÃ¼r');
                        this.memory_bank.push(`${jokerName} ile kÃ¼ltÃ¼rel bir anÄ± paylaÅŸtÄ±k: "${joke}"`);
                    }
                    
                } else {
                    // Confused reactions
                    const confusedReactions = ["?", "Ne dedi?", "AnlamadÄ±m... ğŸ¤”", "Bu da ne?", "Hmm... ğŸ˜•"];
                    reactionText = confusedReactions[Math.floor(Math.random() * confusedReactions.length)];
                    
                    // Slight mood decrease for not understanding
                    this.personality_traits.mood = Math.max(0, this.personality_traits.mood - 0.01);
                }
                
                // Display reaction
                console.log(`${understood ? 'ğŸ˜‚' : 'ğŸ¤”'} ${this.name} ${jokerName}'in ÅŸakasÄ±na: "${reactionText}"`);
                
                // Add to memory
                this.memory_bank.push(`${jokerName}'in ÅŸakasÄ±: "${joke}" - ${understood ? 'AnladÄ±m ve gÃ¼ldÃ¼m' : 'AnlamadÄ±m'}`);
                
                // Social bonding for successful jokes
                if (understood && laughed && Math.random() < 0.4) {
                    this.vocabulary.add('arkadaÅŸ');
                    this.memory_bank.push(`${jokerName} ile ÅŸaka Ã¼zerinden baÄŸ kurduk!`);
                }
                
                return { understood, laughed, reactionText };
            }
        }

        // ğŸ­ V8.9.1: MISSING JOKE TRIGGER DETECTION FUNCTION
        function checkForJokeTriggers(message, bacteria) {
            if (!message || !bacteria || !jokeMasterInstance) return null;
            
            // Check for explicit joke triggers
            const messageText = message.toLowerCase();
            if (messageText.includes('vur joker vur') || messageText.includes('ÅŸaka yap') || messageText.includes('komik sÃ¶yle')) {
                console.log(`ğŸª ${bacteria.name} detected joke trigger in message: ${message}`);
                
                // Force bacteria to tell a joke
                const joke = jokeMasterInstance.tryTellingJoke(bacteria, true);
                if (joke) {
                    console.log(`ğŸ­ ${bacteria.name} tells forced joke: ${joke.text}`);
                    return joke.text;
                }
            }
            
            return null;
        }

        // ğŸš€ V8.9.1: REVOLUTIONARY ANTI-PATTERN LANGUAGE EVOLUTION RESPONSE GENERATOR
        async function generateBacteriaResponse(bacteria, message, context = 'user') {
            const age = bacteria.biological_state.age;
            const consciousness = bacteria.consciousness_level;
            const vocabularySize = bacteria.vocabulary.size;
            const optimism = bacteria.personality_traits.optimism;
            const sociability = bacteria.personality_traits.sociability;
            
            // Learn from user input (unlimited consciousness)
            if (context === 'user') {
                const newWords = learnFromUserInput(message, bacteria);
                if (newWords > 0) {
                    bacteria.consciousness_level = bacteria.consciousness_level + 0.02;
                }
            }
            
            // ğŸ­ V8.9.1: CHECK FOR JOKE TRIGGERS FIRST
            const jokeResponse = checkForJokeTriggers(message, bacteria);
            if (jokeResponse) {
                console.log(`ğŸ­ ${bacteria.name} joke triggered: ${jokeResponse.substring(0, 50)}...`);
                return jokeResponse;
            }
            
            // ğŸ§¬ v9.5.0: ULTRA-AGGRESSIVE ANTI-MONOTONY LANGUAGE EVOLUTION ENGINE (PRIMARY SYSTEM)
            if (languageEvolutionEngine && consciousness >= 0.5) {
                // Determine conversation context for morphological generation
                let conversationContext = 'general';
                if (message && message.toLowerCase().includes('merhaba')) conversationContext = 'social';
                else if (message && (message.includes('Ã¶ÄŸren') || message.includes('bil'))) conversationContext = 'learning';
                else if (message && (message.includes('arkadaÅŸ') || message.includes('dostluk'))) conversationContext = 'social';
                else if (message && (message.includes('ATP') || message.includes('hÃ¼cre'))) conversationContext = 'scientific';
                else if (message && message.includes('vur joker vur')) conversationContext = 'creative';
                else if (message && (message.includes('niye') || message.includes('niÃ§in'))) conversationContext = 'philosophical';
                
                try {
                    // Map context to available contexts in v9.5.0 system
                    if (conversationContext === 'scientific') conversationContext = 'biological';
                    if (conversationContext === 'creative') conversationContext = 'creative';
                    if (conversationContext === 'social') conversationContext = 'social';
                    if (conversationContext === 'philosophical') conversationContext = 'philosophical';
                    
                    // Get v9.5.0 Ultra-Aggressive Anti-Monotony response
                    const morphResponse = await languageEvolutionEngine.generateContextualResponse(bacteria, conversationContext, message);
                    
                    // ğŸ§¬ Record interaction for persistent learning
                    if (window.persistentLearning && context === 'user') {
                        await window.persistentLearning.recordInteraction(
                            message || '',
                            morphResponse,
                            conversationContext,
                            bacteria.id
                        );
                        
                        // Apply learned word success rates to enhance response
                        const words = morphResponse.split(' ');
                        const enhancedWords = words.map(word => {
                            const successRate = window.persistentLearning.getWordSuccessRate(word);
                            // Optionally modify word based on success rate
                            return successRate > 0.7 ? word : word; // Keep for now, can be enhanced
                        });
                    }
                    
                    console.log(`ğŸ§¬ ${bacteria.name} v9.5.0 ULTRA-AGGRESSIVE ANTI-MONOTONY response (context: ${conversationContext})`);
                    return morphResponse;
                } catch (error) {
                    console.warn(`âš ï¸ v9.5.0 Language Evolution failed for ${bacteria.name}:`, error);
                    // Fall through to legacy system
                }
            }
            
            // ğŸ”§ v9.5.0: LEGACY FALLBACK (for very low consciousness bacteria)
            if (languageEvolutionEngine && consciousness >= 0.3) {
                // Determine conversation context for smart evolution
                let conversationContext = 'general';
                if (message && message.toLowerCase().includes('merhaba')) conversationContext = 'greeting';
                else if (message && (message.includes('Ã¶ÄŸren') || message.includes('bil'))) conversationContext = 'learning';
                else if (message && (message.includes('arkadaÅŸ') || message.includes('dostluk'))) conversationContext = 'social';
                else if (message && (message.includes('ATP') || message.includes('hÃ¼cre'))) conversationContext = 'science';
                else if (message && message.includes('vur joker vur')) conversationContext = 'comedy';
                
                // Get v9.5.0 fallback response
                const evolvedResponse = await languageEvolutionEngine.generateContextualResponse(bacteria, conversationContext, message);
                
                console.log(`ğŸ”§ ${bacteria.name} v9.5.0 FALLBACK response (context: ${conversationContext})`);
                return evolvedResponse;
            }
            
            // ğŸ”§ FALLBACK: Basic consciousness responses for very young bacteria
            const availableWords = Array.from(bacteria.vocabulary);
            let responseTemplates = [];
            
            if (consciousness < 1) {
                responseTemplates = [
                    `${availableWords[0] || 'aÃ§'}... ${availableWords[1] || 'yardÄ±m'}...`,
                    `*${bacteria.name} hareket ediyor*`,
                    `${Math.random() > 0.5 ? 'aÄŸrÄ±' : 'aÃ§'}...`
                ];
            } else {
                // Even basic consciousness uses language evolution
                responseTemplates = [
                    `Ben ${bacteria.name}! ${optimism > 0.7 ? 'Mutluyum!' : optimism < 0.3 ? 'ÃœzgÃ¼nÃ¼m...' : 'Ä°yiyim.'}`,
                    `${sociability > 0.7 ? 'Seninle konuÅŸmak gÃ¼zel!' : 'Merhaba...'}`,
                    `${vocabularySize > 3 ? availableWords.slice(0,3).join(' ') : 'aÃ§ yardÄ±m'}!`
                ];
            }
            
            let response = responseTemplates[Math.floor(Math.random() * responseTemplates.length)];
            
            // Add context-specific modifications
            if (context === 'bacteria' && sociability > 0.5) {
                response = response.replace('Merhaba!', 'Hey arkadaÅŸ!').replace('Selam!', 'Ey bakteri kardeÅŸ!');
            }
            
            console.log(`ğŸ”§ ${bacteria.name} fallback response (consciousness: ${consciousness.toFixed(2)})`);
            return response;
        }

        async function sendMessageToBacteria(message) {
            if (chatMode === 'individual' && !selectedBacteria) {
                console.log('âŒ Individual chat requires selected bacteria');
                return;
            }
            if (chatMode === 'group' && bacteriaPopulation.length === 0) {
                console.log('âŒ Group chat requires bacteria population');
                return;
            }

            console.log(`ğŸ’¬ Sending message in ${chatMode} mode: "${message}"`);
            showChatLoading(true);
            addChatMessage(message, 'user');

            if (chatMode === 'individual') {
                // Individual chat with selected bacteria
                setTimeout(async () => {
                    const response = await generateBacteriaResponse(selectedBacteria, message, 'user');
                    selectedBacteria.conversation_history.push({ user: message, bacteria: response });
                    addChatMessage(response, 'bacteria', selectedBacteria.name);
                    showChatLoading(false);
                }, 1000 + Math.random() * 1000);
                         } else if (chatMode === 'group') {
                 // Group chat - all bacteria respond
                 let responseCount = 0;
                 const totalBacteria = bacteriaPopulation.length;
                 const responseBacteria = [];
                 
                 bacteriaPopulation.forEach((bacteria, index) => {
                     setTimeout(async () => {
                         if (Math.random() < 0.7) { // 70% chance each bacteria responds
                             const response = await generateBacteriaResponse(bacteria, message, 'user');
                             bacteria.conversation_history.push({ user: message, bacteria: response });
                             addChatMessage(response, 'bacteria', bacteria.name);
                             responseBacteria.push(bacteria);
                         }
                         responseCount++;
                         if (responseCount === totalBacteria) {
                             // After all responses, bacteria learn from each other in group
                             if (responseBacteria.length > 1) {
                                 setTimeout(() => {
                                     groupLearningSession(responseBacteria);
                                 }, 1000);
                             }
                             showChatLoading(false);
                         }
                     }, (index + 1) * (500 + Math.random() * 1000));
                 });
             }
        }

        // v826: Natural conversation based on proximity and social needs
        function startNaturalBacteriaConversation(socialBacteria) {
            if (socialBacteria.length < 2) return;
            
            // Find bacteria that are close to each other (natural interaction)
            let bacteria1 = null, bacteria2 = null;
            let minDistance = Infinity;
            
            for (let i = 0; i < socialBacteria.length; i++) {
                for (let j = i + 1; j < socialBacteria.length; j++) {
                    const dx = socialBacteria[i].x - socialBacteria[j].x;
                    const dy = socialBacteria[i].y - socialBacteria[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance && distance < 80) { // Close proximity
                        minDistance = distance;
                        bacteria1 = socialBacteria[i];
                        bacteria2 = socialBacteria[j];
                    }
                }
            }
            
            // If no close bacteria, pick random social ones
            if (!bacteria1 || !bacteria2) {
                bacteria1 = socialBacteria[Math.floor(Math.random() * socialBacteria.length)];
                bacteria2 = socialBacteria[Math.floor(Math.random() * socialBacteria.length)];
                while (bacteria2 === bacteria1) {
                    bacteria2 = socialBacteria[Math.floor(Math.random() * socialBacteria.length)];
                }
            }
            
            // Natural conversation topics based on bacteria state
            const naturalTopics = [
                `Merhaba ${bacteria2.name}!`, 'Bu yemek lezzetli deÄŸil mi?', 'Kendimi daha akÄ±llÄ± hissediyorum',
                'BÃ¼yÃ¼dÃ¼ÄŸÃ¼mÃ¼ fark ettim', 'Yeni kelimeler Ã¶ÄŸreniyorum', 'Bu ortam gÃ¼zel',
                'Seninle konuÅŸmak gÃ¼zel', 'Beraber Ã¶ÄŸrenelim', 'NasÄ±l bu kadar bÃ¼yÃ¼dÃ¼n?'
            ];
            
            const topic = naturalTopics[Math.floor(Math.random() * naturalTopics.length)];
            
            // Save conversation to both bacteria's individual chat history
            const conversation = {
                participants: [bacteria1.name, bacteria2.name],
                messages: [],
                timestamp: Date.now()
            };
            
            // Start natural conversation
            setTimeout(async () => {
                const message1 = await generateBacteriaResponse(bacteria1, topic, 'bacteria');
                conversation.messages.push({ speaker: bacteria1.name, message: message1, time: Date.now() });
                
                // Save to individual chat histories
                bacteria1.chatHistory = bacteria1.chatHistory || [];
                bacteria2.chatHistory = bacteria2.chatHistory || [];
                
                bacteria1.chatHistory.push({type: 'sent', to: bacteria2.name, message: message1, time: Date.now()});
                bacteria2.chatHistory.push({type: 'received', from: bacteria1.name, message: message1, time: Date.now()});
                
                // Second bacteria responds
                setTimeout(async () => {
                    const message2 = await generateBacteriaResponse(bacteria2, message1, 'bacteria');
                    conversation.messages.push({ speaker: bacteria2.name, message: message2, time: Date.now() });
                    
                    bacteria2.chatHistory.push({type: 'sent', to: bacteria1.name, message: message2, time: Date.now()});
                    bacteria1.chatHistory.push({type: 'received', from: bacteria2.name, message: message2, time: Date.now()});
                    
                    // Cross-learning
                    bacteriaLearnFromEachOther(bacteria1, bacteria2, message1, message2);
                    
                    // Store global conversation for viewing
                    globalConversations.push(conversation);
                    
                }, 800 + Math.random() * 1500);
            }, 300);
        }

        function startGroupLearningSession() {
            const learners = bacteriaPopulation.filter(b => b.consciousness_level > 1.5);
            if (learners.length < 3) return;
            
            // Pick 3 random learners
            const participants = [];
            for (let i = 0; i < 3 && i < learners.length; i++) {
                const randomIndex = Math.floor(Math.random() * learners.length);
                if (!participants.includes(learners[randomIndex])) {
                    participants.push(learners[randomIndex]);
                }
            }
            
            if (participants.length >= 3) {
                groupLearningSession(participants);
                console.log(`ğŸ“ Group learning session: ${participants.map(p => p.name).join(', ')}`);
            }
        }

        // Bacteria learn from each other's vocabulary and behaviors
        function bacteriaLearnFromEachOther(bacteria1, bacteria2, message1, message2) {
            // Share vocabulary between bacteria
            const vocab1 = Array.from(bacteria1.vocabulary);
            const vocab2 = Array.from(bacteria2.vocabulary);
            
            // Bacteria1 learns some words from bacteria2
            vocab2.forEach(word => {
                if (Math.random() < 0.3 && bacteria1.consciousness_level > 1) { // 30% chance
                    bacteria1.vocabulary.add(word);
                    if (Math.random() < 0.5) {
                        bacteria1.memory_bank.push(`${bacteria2.name}'den "${word}" kelimesini Ã¶ÄŸrendim`);
                    }
                }
            });
            
            // Bacteria2 learns some words from bacteria1
            vocab1.forEach(word => {
                if (Math.random() < 0.3 && bacteria2.consciousness_level > 1) {
                    bacteria2.vocabulary.add(word);
                    if (Math.random() < 0.5) {
                        bacteria2.memory_bank.push(`${bacteria1.name}'den "${word}" kelimesini Ã¶ÄŸrendim`);
                    }
                }
            });
            
            // Behavior influence: social bacteria make others more social
            if (bacteria1.personality_traits.sociability > 0.7) {
                bacteria2.personality_traits.sociability = Math.min(1, bacteria2.personality_traits.sociability + 0.02);
            }
            if (bacteria2.personality_traits.sociability > 0.7) {
                bacteria1.personality_traits.sociability = Math.min(1, bacteria1.personality_traits.sociability + 0.02);
            }
            
            // Consciousness boost from social interaction
                            bacteria1.consciousness_level = bacteria1.consciousness_level + 0.01;
                bacteria2.consciousness_level = bacteria2.consciousness_level + 0.01;
            
                         console.log(`ğŸ¤ ${bacteria1.name} and ${bacteria2.name} learned from each other`);
         }

         // Group learning session - all bacteria in group learn from each other
         function groupLearningSession(bacteria) {
             console.log(`ğŸ‘¥ Group learning session with ${bacteria.length} bacteria`);
             
             // Collect all vocabulary from participating bacteria
             const allVocabulary = new Set();
             bacteria.forEach(b => {
                 Array.from(b.vocabulary).forEach(word => allVocabulary.add(word));
             });
             
             // Each bacteria learns from the collective vocabulary
             bacteria.forEach((learner, i) => {
                 let wordsLearned = 0;
                 allVocabulary.forEach(word => {
                     if (!learner.vocabulary.has(word) && Math.random() < 0.2) { // 20% chance to learn each word
                         learner.vocabulary.add(word);
                         wordsLearned++;
                     }
                 });
                 
                 if (wordsLearned > 0) {
                     learner.memory_bank.push(`Grup sohbetinde ${wordsLearned} kelime Ã¶ÄŸrendim`);
                     learner.consciousness_level = learner.consciousness_level + 0.02;
                 }
                 
                 // Social influence - become more social from group interaction
                 learner.personality_traits.sociability = Math.min(1, learner.personality_traits.sociability + 0.01);
             });
         }

        function addChatMessage(message, sender, bacteriaName = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'} mb-2`;
            
            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = `chat-bubble p-2 rounded-lg ${sender === 'user' ? 'chat-bubble-user' : 'chat-bubble-bacteria'}`;
            
            if (sender === 'bacteria' && bacteriaName) {
                const nameSpan = document.createElement('div');
                nameSpan.className = 'text-xs font-semibold mb-1 opacity-75 cursor-pointer hover:text-blue-400 hover:underline';
                nameSpan.textContent = bacteriaName;
                nameSpan.title = `${bacteriaName}'e tÄ±klayarak seÃ§`;
                
                // ğŸ¯ Ã–ZELLÄ°K 1: Chat'te bakterinin adÄ±nÄ± tÄ±klayÄ±nca o bakteriyi seÃ§
                nameSpan.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Bakteriyi ismine gÃ¶re bul
                    const targetBacteria = bacteriaPopulation.find(b => b.name === bacteriaName);
                    if (targetBacteria) {
                        selectedBacteria = targetBacteria;
                        console.log(`ğŸ¯ Chat'ten bakteri seÃ§ildi: ${bacteriaName}`);
                        
                        // UI'yi gÃ¼ncelle
                        showBacteriaDetails(selectedBacteria);
                        
                        // Canvas'ta bakteriyi highlight et
                        highlightSelectedBacteria(targetBacteria);
                        
                        // Chat modunu individual'a Ã§evir
                        if (chatMode !== 'individual') {
                            chatMode = 'individual';
                            updateChatModeButtons();
                            updateChatUI();
                        }
                        
                        // GÃ¶rsel feedback
                        nameSpan.style.color = '#22c55e';
                        nameSpan.style.fontWeight = 'bold';
                        setTimeout(() => {
                            nameSpan.style.color = '';
                            nameSpan.style.fontWeight = '';
                        }, 1000);
                    } else {
                        console.warn(`âš ï¸ Bakteri bulunamadÄ±: ${bacteriaName}`);
                    }
                });
                
                bubbleDiv.appendChild(nameSpan);
                
                const messageSpan = document.createElement('div');
                messageSpan.textContent = message;
                bubbleDiv.appendChild(messageSpan);
            } else {
                bubbleDiv.textContent = message;
            }
            
            messageDiv.appendChild(bubbleDiv);
            chatMessagesDiv.insertBefore(messageDiv, chatMessagesDiv.firstChild);
            // Auto scroll stays at bottom (newest messages at top due to column-reverse)
        }

        function showChatLoading(show) {
            chatLoadingIndicator.classList.toggle('hidden', !show);
        }

        // Event Delegation System for better performance and cleaner code
        class UIManager {
            constructor(simulationManager) {
                this.simulationManager = simulationManager;
                this.startSimulationBtn = document.getElementById('startSimulationBtn');
                this.nextStepBtn = document.getElementById('nextStepBtn');
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                // Use event delegation instead of individual onclick handlers
                document.addEventListener('click', this.handleGlobalClick.bind(this));
            }

            handleGlobalClick(event) {
                const button = event.target.closest('button');
                if (!button) return;

                const buttonText = button.textContent.trim();
                
                // Centralized button action mapping
                const actionMap = {
                    'â–¶ï¸ BaÅŸlat': () => this.startSimulation(),
                    'SimÃ¼lasyonu BaÅŸlat': () => this.startSimulation(),
                    'Devam Et': () => this.startSimulation(),
                    'Durdur': () => this.pauseSimulation(),
                    'â¸ï¸ Duraklat': () => this.pauseSimulation(),
                    'Sonraki AdÄ±m': () => this.nextStep(),
                    'ğŸ”„ SÄ±fÄ±rla': () => this.resetSimulation(),
                    'ğŸ Yemek Ekle': () => addRandomFood(),
                    'ğŸ“Š CSV Export': () => exportCSV(),
                    'ğŸ“ˆ JSON Export': () => exportEnhancedData(),
                    'ğŸ‘¥ Grup Sohbet': () => toggleGroupChat(),
                    'ğŸ’¬ Bireysel Sohbet': () => toggleGroupChat(),
                    'â• Bakteri Ekle': () => addBacteria()
                };

                const action = actionMap[buttonText];
                if (action) {
                    event.preventDefault();
                    action();
                }
            }

            startSimulation() {
                if (!this.simulationManager.isRunning) {
                    simulationRunning = true;
                    if (this.startSimulationBtn) this.startSimulationBtn.textContent = 'Durdur';
                    if (this.nextStepBtn) this.nextStepBtn.disabled = true;
                    this.simulationManager.start();
                    
                    // ğŸ¤ Start automatic bacteria conversations
                    startAutoBacteriaConversations();
                    console.log('ğŸ¯ Simulation started with auto-conversations enabled');
                } else {
                    this.pauseSimulation();
                }
            }

            pauseSimulation() {
                simulationRunning = false;
                if (this.startSimulationBtn) this.startSimulationBtn.textContent = 'Devam Et';
                if (this.nextStepBtn) this.nextStepBtn.disabled = false;
                this.simulationManager.pause();
                
                // ğŸ¤ Stop automatic bacteria conversations
                stopAutoBacteriaConversations();
                console.log('ğŸ¯ Simulation paused, auto-conversations stopped');
            }

            nextStep() {
                this.simulationManager.simulationStep();
            }

            resetSimulation() {
                this.pauseSimulation();
                this.simulationManager.simulationDay = 0;
                simulationTimeSpan.textContent = 'SimÃ¼lasyon ZamanÄ±: 0 gÃ¼n';
                bacteriaPopulation.length = 0;
                bacteriaList.length = 0;
                foodParticles.length = 0;
                selectedBacteria = null;
                
                if (this.startSimulationBtn) this.startSimulationBtn.textContent = 'SimÃ¼lasyonu BaÅŸlat';
                if (this.nextStepBtn) this.nextStepBtn.disabled = false;
                
                bacteriaDetailsDiv.classList.add('hidden');
                chatInfoDiv.textContent = 'Sohbet modunu seÃ§in.';
                chatMessagesDiv.innerHTML = '';
                chatInput.disabled = true;
                sendMessageBtn.disabled = true;
                chatMode = 'individual';
                updateChatModeButtons();
                
                // Close all individual chat windows
                openChatWindows.forEach((modal, bacteriaId) => {
                    document.body.removeChild(modal);
                });
                openChatWindows.clear();
                
                initializeBacteria();
            }
        }

        // Utility functions for performance optimization
        class PerformanceUtils {
            static debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            static throttle(func, limit) {
                let inThrottle;
                return function() {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            }
        }

        // Initialize AI systems and UIManager after DOM is ready
        let uiManager = null;

                    // v9.0.0: Initialize Enhanced Persistent Learning Systems
        function initializeAISystems() {
            console.log('ğŸ§  Initializing Advanced AI/ML Systems...');
            
            try {
                // Initialize global AI systems
                globalNeuralNetwork = new AdvancedNeuralNetwork();
                geneticAlgorithm = new GeneticEvolutionSystem();
                behaviourLearningSystem = new BehaviorLearningSystem();
                tabpfnVocabularySystem = new TabPFNVocabularySystem();
                
                // Create initial training data
                generateInitialTrainingData();
                
                console.log(`âœ… AI/ML Systems initialized successfully with ${tabpfnVocabularySystem.getTotalWordCount()} vocabulary words!`);
                return true;
            } catch (error) {
                console.error('âŒ AI Systems initialization failed:', error);
                return false;
            }
        }

        function generateInitialTrainingData() {
            // Generate synthetic training data for neural networks
            const trainingData = [];
            
            for (let i = 0; i < 50; i++) {
                // Create diverse training scenarios
                const mockBacteria = {
                    biological_state: { age: Math.random() * 100, size: Math.random() * 5 },
                    consciousness_level: Math.random() * 20,
                    personality_traits: { optimism: Math.random(), sociability: Math.random() },
                    vocabulary: { size: Math.random() * 30 },
                    hunger: Math.random(),
                    energy: Math.random(),
                    conversation_history: Array(Math.floor(Math.random() * 10)),
                    memory_bank: Array(Math.floor(Math.random() * 20)),
                    x: Math.random() * 500,
                    y: Math.random() * 300
                };
                
                const inputs = globalNeuralNetwork.prepareBacteriaInputs(mockBacteria);
                
                // Generate expected outputs based on scenario
                const expectedOutputs = generateExpectedBehavior(mockBacteria);
                
                trainingData.push({ inputs, expectedOutputs });
            }
            
            // Train the global network
            globalNeuralNetwork.train(trainingData, 15);
            console.log(`ğŸ“ Generated and trained on ${trainingData.length} scenarios`);
        }

        function generateExpectedBehavior(bacteria) {
            // Define expected behavior based on bacteria state
            let moveX = 0, moveY = 0, moveZ = 0;
            let seekFood = 0, socialize = 0, reproduce = 0;
            
            // High hunger -> seek food
            if (bacteria.hunger > 0.7) {
                seekFood = 0.9;
                moveX = (Math.random() - 0.5) * 0.8; // Active movement
                moveY = (Math.random() - 0.5) * 0.8;
            }
            
            // High sociability -> socialize
            if (bacteria.personality_traits.sociability > 0.6) {
                socialize = 0.8;
            }
            
            // High consciousness + size -> reproduce
            if (bacteria.consciousness_level > 5 && bacteria.biological_state.size > 2) {
                reproduce = 0.7;
            }
            
            // Default exploration
            if (seekFood < 0.3 && socialize < 0.3 && reproduce < 0.3) {
                moveX = (Math.random() - 0.5) * 0.6;
                moveY = (Math.random() - 0.5) * 0.6;
                moveZ = (Math.random() - 0.5) * 0.4;
            }
            
            return [
                moveX * 0.5 + 0.5, // Normalize to 0-1
                moveY * 0.5 + 0.5,
                moveZ * 0.5 + 0.5,
                seekFood,
                socialize,
                reproduce
            ];
        }
        
        // ESKÄ° FONKSÄ°YONLAR KALDIRILDI - SIMÃœLASYON ARTÄ°K SÄ°MULATÄ°ONMANAGER ÃœZERÄ°NDEN YÃ–NETÄ°LÄ°YOR

        function simulationStep() {
            simulationDay++;
            simulationTimeSpan.textContent = `SimÃ¼lasyon ZamanÄ±: ${simulationDay} gÃ¼n`;
            
            // v829: Auto-generate food for sustained ecosystem
            if (Math.random() < 0.7) { // 70% chance to add food each step
                const x = Math.random() * 460 + 20;
                const y = Math.random() * 260 + 20;
                addFood(x, y);
            }
            
            bacteriaPopulation.forEach(bacteria => {
                if (!bacteria || typeof bacteria.updateDaily !== 'function') return;
                
                try {
                    bacteria.updateDaily();
                    bacteria.move(); // Add movement to simulation steps for more dynamic behavior
                    
                    // v829: More frequent reproduction checks for dynamic population
                    if (simulationDay % 2 === 0 && typeof bacteria.checkForReproduction === 'function') { // Check every 2 days instead of 3
                        bacteria.checkForReproduction();
                    }
                } catch (error) {
                    console.error(`Error in simulation step for bacteria ${bacteria.id}:`, error);
                }
            });
            
            renderBacteria();
            if (selectedBacteria) {
                updateBacteriaDetails(selectedBacteria);
            }
        }

        function resetSimulation() {
            pauseSimulation();
            simulationDay = 0;
            simulationTimeSpan.textContent = 'SimÃ¼lasyon ZamanÄ±: 0 gÃ¼n';
            bacteriaPopulation = [];
            bacteriaList = []; // v826 compatibility
            foodParticles = [];
            selectedBacteria = null;
            
            startSimulationBtn.textContent = 'SimÃ¼lasyonu BaÅŸlat';
            nextStepBtn.disabled = false;
            
            bacteriaDetailsDiv.classList.add('hidden');
            chatInfoDiv.textContent = 'Sohbet modunu seÃ§in.';
            chatMessagesDiv.innerHTML = '';
            chatInput.disabled = true;
            sendMessageBtn.disabled = true;
            chatMode = 'individual';
            updateChatModeButtons();
            
            // Close all individual chat windows
            openChatWindows.forEach((modal, bacteriaId) => {
                document.body.removeChild(modal);
            });
            openChatWindows.clear();
            
            initializeBacteria();
        }

        // v826: Add new bacteria to simulation
        function addBacteria() {
            const newBacteria = new BacteriaEntity(bacteriaIdCounter++);
            bacteriaPopulation.push(newBacteria);
            bacteriaList.push(newBacteria); // v826 compatibility
            
            console.log(`â• Added new bacteria: ${newBacteria.name} (Total: ${bacteriaPopulation.length})`);
            renderBacteria();
        }

        // v826: Toggle group chat (improved)
        function toggleGroupChat() {
            if (chatMode === 'group') {
                // Switch to individual mode
                chatMode = 'individual';
                selectedBacteria = null;
                chatInfoDiv.innerHTML = 'ğŸ’¬ Bireysel sohbet modu aktif - Bir bakteriye tÄ±klayÄ±n';
                chatInput.disabled = true;
                sendMessageBtn.disabled = true;
                chatInput.placeholder = "Ã–nce bir bakteri seÃ§in...";
            } else {
                // Switch to group mode
                setupGroupChat();
            }
            updateChatModeButtons();
        }

        function addFood(x, y) {
            const food = new FoodParticle(x, y);
            foodParticles.push(food);
            renderBacteria();
        }

        function initializeBacteria() {
            bacteriaPopulation = [];
            bacteriaList = []; // v826 compatibility
            
            // ğŸ¯ EXTREME BOUNDARY UPDATE (v8.7.3 NUCLEAR OPTION)
            console.log('ğŸ” Checking boundary status before initialization...');
            console.log('ğŸ“Š Current DYNAMIC_BOUNDARIES:', DYNAMIC_BOUNDARIES);
            
            // ğŸš¨ NUCLEAR OPTION: ABSOLUTE FORCE RESIZE!!!
            if (canvas) {
                console.log('ğŸ”§ NUCLEAR FORCE RESIZE - EXTREME BOUNDARY UPDATE!');
                // Force resize 10 times with different delays!
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        resizeCanvas();
                        console.log(`ğŸ”§ Force resize attempt #${i + 1}:`, DYNAMIC_BOUNDARIES);
                    }, i * 25);
                }
                
                // Additional heavy artillery
                setTimeout(() => {
                    resizeCanvas();
                    console.log('ğŸ”§ Heavy artillery resize 1:', DYNAMIC_BOUNDARIES);
                }, 300);
                setTimeout(() => {
                    resizeCanvas();
                    console.log('ğŸ”§ Heavy artillery resize 2:', DYNAMIC_BOUNDARIES);
                }, 600);
                setTimeout(() => {
                    resizeCanvas();
                    console.log('ğŸ”§ Heavy artillery resize 3:', DYNAMIC_BOUNDARIES);
                }, 1000);
            }
            
            // âœ… V8.7.4: FALLBACK NOW LOGGING-ONLY - NO STATIC VALUES!
            if (!canvas) {
                console.error('âŒ CRITICAL: Canvas not available - cannot determine boundaries!');
                console.error('ğŸš¨ System may not work properly without canvas sizing');
                const container = document.getElementById('simulationArea');
                if (container) {
                    const rect = container.getBoundingClientRect();
                    console.log(`ğŸ“ Container size detected: ${rect.width}x${rect.height}`);
                    if (rect.width > 100 && rect.height > 100) {
                        DYNAMIC_BOUNDARIES.maxX = rect.width - 40;
                        DYNAMIC_BOUNDARIES.maxY = rect.height - 40;
                        DYNAMIC_BOUNDARIES.minX = DYNAMIC_BOUNDARIES.padding;
                        DYNAMIC_BOUNDARIES.minY = DYNAMIC_BOUNDARIES.padding;
                        console.log('ğŸ”§ Emergency: Using container dimensions for boundaries');
                    } else {
                        console.error('ğŸ’¥ TOTAL FAILURE: Container too small, boundaries not set!');
                    }
                } else {
                    console.error('ğŸ’¥ TOTAL FAILURE: No container found - boundaries not set!');
                    console.error('ğŸ†˜ Bacteria movement may fail completely!');
                }
            }
            
            // âœ… V8.7.4: FINAL VERIFICATION - PURELY DIAGNOSTIC
            setTimeout(() => {
                console.log('ğŸ¯ V8.7.4 Final Dynamic Boundary Verification:');
                console.log(`ğŸ“ X: ${DYNAMIC_BOUNDARIES.minX} â†’ ${DYNAMIC_BOUNDARIES.maxX} (width: ${DYNAMIC_BOUNDARIES.maxX - DYNAMIC_BOUNDARIES.minX})`);
                console.log(`ğŸ“ Y: ${DYNAMIC_BOUNDARIES.minY} â†’ ${DYNAMIC_BOUNDARIES.maxY} (height: ${DYNAMIC_BOUNDARIES.maxY - DYNAMIC_BOUNDARIES.minY})`);
                
                if (DYNAMIC_BOUNDARIES.maxX <= DYNAMIC_BOUNDARIES.padding * 2 || DYNAMIC_BOUNDARIES.maxY <= DYNAMIC_BOUNDARIES.padding * 2) {
                    console.error('ğŸ’¥ CRITICAL: Dynamic boundaries failed to initialize properly!');
                    console.error('ğŸš¨ Bacteria will be confined to tiny area or not move at all!');
                } else {
                    console.log('âœ… SUCCESS: Dynamic boundaries properly initialized - bacteria can roam freely!');
                    console.log(`ğŸ¦  Available area: ${(DYNAMIC_BOUNDARIES.maxX - DYNAMIC_BOUNDARIES.minX) * (DYNAMIC_BOUNDARIES.maxY - DYNAMIC_BOUNDARIES.minY)} pixels`);
                }
            }, 300);
            
            for (let i = 0; i < CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT; i++) {
                const bacteria = new BacteriaEntity(i + 1);
                bacteriaPopulation.push(bacteria);
                bacteriaList.push(bacteria); // v826 compatibility
            }
            console.log(`ğŸ¦  Initialized ${bacteriaPopulation.length} bacteria with bounds:`, DYNAMIC_BOUNDARIES);
            renderBacteria();
        }

        function renderBacteria() {
            const startTime = performance.now(); // v829: Performance tracking
            
            // v829: Use Canvas if available, otherwise fallback to DOM
            if (useCanvas && canvas && ctx) {
                renderWithCanvas();
            } else {
                renderWithDOM();
            }
            
            // v829: Track render performance
            performanceMetrics.renderTime = performance.now() - startTime;
            updatePerformanceMetrics();
        }

        function renderWithCanvas() {
            // Optimized canvas clearing (dirty rect approach for better performance)
            ctx.fillStyle = 'rgba(17, 24, 39, 0.1)'; // Slight trail effect for movement
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Background gradient
            const gradient = ctx.createRadialGradient(canvasWidth/2, canvasHeight/2, 0, canvasWidth/2, canvasHeight/2, Math.max(canvasWidth, canvasHeight)/2);
            gradient.addColorStop(0, 'rgba(30, 30, 30, 0.1)');
            gradient.addColorStop(1, 'rgba(30, 30, 30, 0.3)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Render food particles
            foodParticles.forEach(food => {
                // Food glow effect
                ctx.shadowColor = '#66BB6A';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#66BB6A';
                ctx.beginPath();
                ctx.arc(food.x, food.y, food.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Sort bacteria by Z-depth for proper layering (far to near)
            const sortedBacteria = [...bacteriaPopulation].sort((a, b) => a.z - b.z);
            
            // Render bacteria with pseudo-3D effects
            sortedBacteria.forEach(bacteria => {
                if (!bacteria || typeof bacteria.x !== 'number' || !bacteria.biological_state) return;
                
                // 3D perspective scaling (bacteria further away appear smaller)
                const depthFactor = bacteria.z / 100; // 0.2 to 1.8 range
                const baseSize = Math.max(6, Math.min(25, bacteria.biological_state.size * 2.5));
                const bacteriaSize = baseSize * depthFactor;
                
                // 3D depth effects
                const alpha = Math.max(0.3, Math.min(1.0, depthFactor)); // Transparency based on depth
                const shadowOffset = (1 - depthFactor) * 3; // Shadow offset based on depth
                
                // Draw shadow first (for depth illusion)
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.3})`;
                ctx.beginPath();
                ctx.arc(bacteria.x + shadowOffset, bacteria.y + shadowOffset, bacteriaSize * 0.8, 0, 2 * Math.PI);
                ctx.fill();
                
                // Bacteria glow effect with 3D scaling
                ctx.shadowColor = bacteria.color;
                ctx.shadowBlur = 10 * depthFactor; // Deeper objects have less glow
                ctx.globalAlpha = alpha;
                ctx.fillStyle = bacteria.color;
                ctx.beginPath();
                ctx.arc(bacteria.x, bacteria.y, bacteriaSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0; // Reset alpha
                
                // ID label
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'white';
                ctx.font = '10px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(`#${bacteria.id}`, bacteria.x, bacteria.y - bacteriaSize - 5);
                
                // Consciousness indicator
                const consciousnessColor = bacteria.consciousness_level < 1 ? '#ff4757' :
                                           bacteria.consciousness_level < 5 ? '#f39c12' :
                                           bacteria.consciousness_level < 10 ? '#2ed573' : '#5352ed';
                ctx.fillStyle = consciousnessColor;
                ctx.beginPath();
                ctx.arc(bacteria.x + bacteriaSize - 3, bacteria.y - bacteriaSize + 3, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // ğŸ¯ SELECTION HIGHLIGHT - Show if bacteria is selected
                if (bacteria.isSelected || bacteria === selectedBacteria) {
                    ctx.save();
                    ctx.strokeStyle = '#22c55e'; // Green selection ring
                    ctx.lineWidth = 3;
                    ctx.setLineDash([8, 4]); // Dashed line
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(bacteria.x, bacteria.y, bacteriaSize + 10, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset dash
                    ctx.restore();
                    
                    // Add selection pulse effect
                    const pulseTime = Date.now() * 0.005;
                    const pulseAlpha = 0.3 + 0.2 * Math.sin(pulseTime);
                    ctx.save();
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = pulseAlpha;
                    ctx.beginPath();
                    ctx.arc(bacteria.x, bacteria.y, bacteriaSize + 15, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.restore();
                }
            });
        }

        function renderWithDOM() {
            simulationArea.innerHTML = '';
            
            // Render food particles with improved visibility
            foodParticles.forEach(food => {
                const foodElement = document.createElement('div');
                foodElement.className = 'absolute rounded-full border-2 border-green-400 shadow-lg';
                foodElement.style.width = `${food.size}px`;
                foodElement.style.height = `${food.size}px`;
                foodElement.style.backgroundColor = food.color;
                foodElement.style.left = `${food.x - food.size/2}px`;
                foodElement.style.top = `${food.y - food.size/2}px`;
                foodElement.style.boxShadow = '0 0 8px rgba(144, 238, 144, 0.6)';
                foodElement.title = 'Yemek - Besin deÄŸeri: ' + food.nutrition;
                
                // Add glow effect for better visibility
                const glowElement = document.createElement('div');
                glowElement.className = 'absolute rounded-full';
                glowElement.style.width = `${food.size * 2}px`;
                glowElement.style.height = `${food.size * 2}px`;
                glowElement.style.left = `${food.x - food.size}px`;
                glowElement.style.top = `${food.y - food.size}px`;
                glowElement.style.background = 'radial-gradient(circle, rgba(144, 238, 144, 0.3) 0%, transparent 70%)';
                glowElement.style.pointerEvents = 'none';
                
                simulationArea.appendChild(glowElement);
                simulationArea.appendChild(foodElement);
            });
            
            // Render bacteria with ID labels
            const allBacteria = [...bacteriaPopulation, ...bacteriaList];
            console.log(`ğŸ¨ Rendering ${bacteriaPopulation.length} old + ${bacteriaList.length} new = ${allBacteria.length} total bacteria`);
            allBacteria.forEach(bacteria => {
                const bacteriaSize = Math.max(8, Math.min(25, bacteria.biological_state.size * 3)); // 8-25px limit
                
                // Main bacteria circle
                const bacteriaElement = document.createElement('div');
                bacteriaElement.className = 'bacteria absolute rounded-full border-2 border-white cursor-pointer shadow-lg';
                bacteriaElement.style.width = `${bacteriaSize}px`;
                bacteriaElement.style.height = `${bacteriaSize}px`;
                bacteriaElement.style.backgroundColor = bacteria.color;
                bacteriaElement.style.left = `${bacteria.x}px`;
                bacteriaElement.style.top = `${bacteria.y}px`;
                bacteriaElement.style.boxShadow = `0 0 10px ${bacteria.color}`;
                bacteriaElement.title = `${bacteria.name} - YaÅŸ: ${bacteria.biological_state.age} gÃ¼n, BilinÃ§: ${bacteria.consciousness_level.toFixed(1)}`;
                
                // ID label on top of bacteria
                const idLabel = document.createElement('div');
                idLabel.className = 'absolute text-xs font-bold text-white bg-black bg-opacity-75 rounded px-1';
                idLabel.style.left = `${bacteria.x + bacteriaSize/2 - 8}px`;
                idLabel.style.top = `${bacteria.y - 18}px`;
                idLabel.style.fontSize = '10px';
                idLabel.style.pointerEvents = 'none';
                idLabel.style.zIndex = '10';
                idLabel.textContent = `#${bacteria.id}`;
                
                // Consciousness level indicator (small colored dot)
                const consciousnessIndicator = document.createElement('div');
                consciousnessIndicator.className = 'absolute rounded-full border border-white';
                consciousnessIndicator.style.width = '6px';
                consciousnessIndicator.style.height = '6px';
                consciousnessIndicator.style.left = `${bacteria.x + bacteriaSize - 8}px`;
                consciousnessIndicator.style.top = `${bacteria.y}px`;
                consciousnessIndicator.style.pointerEvents = 'none';
                
                // Color based on consciousness level
                if (bacteria.consciousness_level < 1) {
                    consciousnessIndicator.style.backgroundColor = '#ff4757';
                } else if (bacteria.consciousness_level < 2) {
                    consciousnessIndicator.style.backgroundColor = '#ff6b35';
                } else if (bacteria.consciousness_level < 3) {
                    consciousnessIndicator.style.backgroundColor = '#f39c12';
                } else if (bacteria.consciousness_level < 4) {
                    consciousnessIndicator.style.backgroundColor = '#2ed573';
                } else {
                    consciousnessIndicator.style.backgroundColor = '#5352ed';
                }
                
                // Movement trail effect
                if (bacteria.vx !== 0 || bacteria.vy !== 0) {
                    const trailElement = document.createElement('div');
                    trailElement.className = 'absolute rounded-full';
                    trailElement.style.width = `${bacteriaSize * 1.5}px`;
                    trailElement.style.height = `${bacteriaSize * 1.5}px`;
                    trailElement.style.left = `${bacteria.x - bacteriaSize/4}px`;
                    trailElement.style.top = `${bacteria.y - bacteriaSize/4}px`;
                    trailElement.style.background = `radial-gradient(circle, ${bacteria.color}20 0%, transparent 70%)`;
                    trailElement.style.pointerEvents = 'none';
                    simulationArea.appendChild(trailElement);
                }
                
                bacteriaElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectBacteria(bacteria);
                });
                
                simulationArea.appendChild(bacteriaElement);
                simulationArea.appendChild(idLabel);
                simulationArea.appendChild(consciousnessIndicator);
            });
            
            // Environment effects overlay
            const environmentOverlay = document.createElement('div');
            environmentOverlay.className = 'absolute inset-0 pointer-events-none';
            environmentOverlay.style.background = 'radial-gradient(circle at 50% 50%, rgba(0, 100, 200, 0.05) 0%, transparent 60%)';
            simulationArea.appendChild(environmentOverlay);
            
            // Add molecular dynamics visualization hints
            if (allBacteria.length > 1) {
                allBacteria.forEach((bacteria, i) => {
                    allBacteria.slice(i + 1).forEach(otherBacteria => {
                        const dx = otherBacteria.x - bacteria.x;
                        const dy = otherBacteria.y - bacteria.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Show molecular interaction lines for close bacteria
                        if (distance < 50 && distance > 0) {
                            const interactionLine = document.createElement('div');
                            interactionLine.className = 'absolute pointer-events-none';
                            interactionLine.style.position = 'absolute';
                            interactionLine.style.left = `${bacteria.x}px`;
                            interactionLine.style.top = `${bacteria.y}px`;
                            interactionLine.style.width = `${distance}px`;
                            interactionLine.style.height = '1px';
                            interactionLine.style.background = `linear-gradient(90deg, ${bacteria.color}40, ${otherBacteria.color}40)`;
                            interactionLine.style.transformOrigin = '0 0';
                            interactionLine.style.transform = `rotate(${Math.atan2(dy, dx)}rad)`;
                            interactionLine.style.opacity = '0.6';
                            simulationArea.appendChild(interactionLine);
                        }
                    });
                });
            }
            
        }

        function selectBacteria(bacteria) {
            selectedBacteria = bacteria;
            updateBacteriaDetails(bacteria);
            
            // v826: Open individual chat window modal
            openIndividualChatWindow(bacteria);
        }

        function updateBacteriaDetails(bacteria) {
            bacteriaIdSpan.textContent = bacteria.id;
            bacteriaNameSpan.textContent = bacteria.name;
            bacteriaSizeSpan.textContent = bacteria.biological_state.size.toFixed(2);
            bacteriaAgeSpan.textContent = bacteria.biological_state.age;
            bacteriaGrowthRateSpan.textContent = bacteria.biological_state.growth_rate.toFixed(2);
                                bacteriaConsciousnessSpan.textContent = `${bacteria.consciousness_level.toFixed(1)} âˆ`;
            bacteriaOptimismSpan.textContent = bacteria.personality_traits.optimism.toFixed(2);
            bacteriaSociabilitySpan.textContent = bacteria.personality_traits.sociability.toFixed(2);
            bacteriaLanguageStageSpan.textContent = `${bacteria.language_stage} - ${vocabularyStages[bacteria.language_stage]?.name || 'Bilinmiyor'}`;
            
            const vocabArray = Array.from(bacteria.vocabulary);
                    const displayVocab = vocabArray.slice(0, CONFIG.UI.MAX_VOCABULARY_DISPLAY);
        const remainingCount = vocabArray.length - CONFIG.UI.MAX_VOCABULARY_DISPLAY;
            bacteriaVocabularySpan.textContent = displayVocab.join(', ') + (remainingCount > 0 ? ` (+${remainingCount} daha)` : '');
            
            bacteriaDetailsDiv.classList.remove('hidden');
        }

        // ğŸ¯ Ã–ZELLÄ°K 1 & 2: Eksik fonksiyonlar
        function showBacteriaDetails(bacteria) {
            selectedBacteria = bacteria;
            updateBacteriaDetails(bacteria);
            
            // Chat sistemini gÃ¼ncelle
            setupChat(bacteria);
            
            console.log(`ğŸ¯ Bacteria details shown for: ${bacteria.name}`);
        }

        function highlightSelectedBacteria(bacteria) {
            // Canvas'ta tÃ¼m bakterileri Ã§iz ve seÃ§ili olanÄ± vurgula
            if (canvas && ctx) {
                // Redraw bacteria to remove old highlights
                drawBacteria();
                
                // Draw highlight circle around selected bacteria
                ctx.save();
                ctx.strokeStyle = '#22c55e'; // Green highlight
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]); // Dashed line
                ctx.beginPath();
                ctx.arc(bacteria.x, bacteria.y, bacteria.biological_state.size * 12 + 8, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]); // Reset dash
                ctx.restore();
                
                // Add pulsing selection indicator
                let pulseOpacity = 0.7;
                let pulseDirection = -0.02;
                
                const pulseInterval = setInterval(() => {
                    pulseOpacity += pulseDirection;
                    if (pulseOpacity <= 0.3) pulseDirection = 0.02;
                    if (pulseOpacity >= 0.7) pulseDirection = -0.02;
                    
                    // Redraw bacteria
                    drawBacteria();
                    
                    // Draw pulsing highlight
                    ctx.save();
                    ctx.globalAlpha = pulseOpacity;
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(bacteria.x, bacteria.y, bacteria.biological_state.size * 12 + 8, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }, 50);
                
                // Clear pulse after 3 seconds
                setTimeout(() => {
                    clearInterval(pulseInterval);
                    drawBacteria(); // Final redraw without highlight
                }, 3000);
            }
            
            console.log(`ğŸ¯ Bacteria highlighted: ${bacteria.name}`);
        }

        function setupChat(bacteria) {
            chatMode = 'individual';
            selectedBacteria = bacteria;
            chatInfoDiv.innerHTML = `<strong>${bacteria.name}</strong> ile sohbet ediyorsunuz.`;
            chatMessagesDiv.innerHTML = '';
            chatInput.disabled = false;
            sendMessageBtn.disabled = false;
            chatInput.placeholder = `${bacteria.name} ile konuÅŸ...`;
            chatInput.focus();
            updateChatModeButtons();
            updateBuildInfo();
            console.log(`ğŸ¯ Individual chat mode with ${bacteria.name}`);
        }

        // v826: Individual Chat Window Modal System
        function openIndividualChatWindow(bacteria) {
            // Check if window already exists
            if (openChatWindows.has(bacteria.id)) {
                // Bring existing window to front
                const existingModal = openChatWindows.get(bacteria.id);
                existingModal.style.zIndex = ++chatWindowZIndex;
                return;
            }
            
            // Create modal backdrop
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.style.zIndex = ++chatWindowZIndex;
            
            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.className = 'bg-gray-800 rounded-lg shadow-xl max-w-md w-full mx-4 max-h-96 flex flex-col';
            modalContent.style.minHeight = '400px';
            
            // Modal header
            const header = document.createElement('div');
            header.className = 'bg-teal-600 text-white px-4 py-3 rounded-t-lg flex justify-between items-center cursor-move';
            header.innerHTML = `
                <div class="flex items-center space-x-2">
                    <div class="w-3 h-3 rounded-full" style="background-color: ${bacteria.color}"></div>
                    <h3 class="font-bold">${bacteria.name} - Chat</h3>
                    <span class="text-xs bg-teal-700 px-2 py-1 rounded">#${bacteria.id}</span>
                </div>
                <div class="flex space-x-2">
                    <button class="text-white hover:text-gray-300 minimize-btn">â”€</button>
                    <button class="text-white hover:text-gray-300 close-btn">Ã—</button>
                </div>
            `;
            
            // Chat messages area
            const messagesArea = document.createElement('div');
            messagesArea.className = 'flex-1 p-4 overflow-y-auto bg-gray-700 text-white text-sm';
            messagesArea.style.maxHeight = '250px';
            
            // Load chat history
            loadChatHistory(messagesArea, bacteria);
            
            // Chat input area
            const inputArea = document.createElement('div');
            inputArea.className = 'p-4 bg-gray-600 rounded-b-lg flex space-x-2';
            inputArea.innerHTML = `
                <input type="text" class="flex-1 bg-gray-500 text-white px-3 py-2 rounded focus:outline-none focus:ring-2 focus:ring-teal-500" 
                       placeholder="${bacteria.name} ile konuÅŸ...">
                <button class="bg-teal-500 hover:bg-teal-600 text-white px-4 py-2 rounded font-bold send-btn">GÃ¶nder</button>
            `;
            
            // Assemble modal
            modalContent.appendChild(header);
            modalContent.appendChild(messagesArea);
            modalContent.appendChild(inputArea);
            modal.appendChild(modalContent);
            
            // Event listeners
            const closeBtn = header.querySelector('.close-btn');
            const minimizeBtn = header.querySelector('.minimize-btn');
            const sendBtn = inputArea.querySelector('.send-btn');
            const chatInput = inputArea.querySelector('input');
            
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
                openChatWindows.delete(bacteria.id);
            });
            
            minimizeBtn.addEventListener('click', () => {
                modalContent.style.display = modalContent.style.display === 'none' ? 'flex' : 'none';
            });
            
            sendBtn.addEventListener('click', () => {
                sendIndividualMessage(bacteria, chatInput, messagesArea);
            });
            
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendIndividualMessage(bacteria, chatInput, messagesArea);
                }
            });
            
            // Make draggable
            makeDraggable(modal, header);
            
            // Add to DOM and track
            document.body.appendChild(modal);
            openChatWindows.set(bacteria.id, modal);
            
            // Focus input
            chatInput.focus();
            
            console.log(`ğŸ’¬ Opened individual chat window for ${bacteria.name}`);
        }

        function loadChatHistory(messagesArea, bacteria) {
            // Load user conversations with this bacteria
            if (bacteria.conversation_history && bacteria.conversation_history.length > 0) {
                bacteria.conversation_history.forEach(conv => {
                    addMessageToWindow(messagesArea, conv.user, 'user', 'Sen');
                    addMessageToWindow(messagesArea, conv.bacteria, 'bacteria', bacteria.name);
                });
            }
            
            // Load bacteria-to-bacteria conversations
            if (bacteria.chatHistory && bacteria.chatHistory.length > 0) {
                bacteria.chatHistory.slice(-10).forEach(msg => { // Show last 10 messages
                    if (msg.type === 'sent') {
                        addMessageToWindow(messagesArea, msg.message, 'bacteria', bacteria.name);
                    } else {
                        addMessageToWindow(messagesArea, msg.message, 'bacteria', msg.from);
                    }
                });
            }
            
            // Scroll to bottom
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function addMessageToWindow(messagesArea, message, sender, senderName) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `mb-2 ${sender === 'user' ? 'text-right' : 'text-left'}`;
            
            const bubble = document.createElement('div');
            bubble.className = `inline-block px-3 py-2 rounded-lg max-w-xs ${
                sender === 'user' 
                    ? 'bg-teal-500 text-white' 
                    : 'bg-gray-600 text-gray-100'
            }`;
            
            const nameSpan = document.createElement('div');
            nameSpan.className = 'text-xs opacity-75 mb-1 cursor-pointer hover:bg-blue-600 hover:text-white px-2 py-1 rounded transition-colors';
            nameSpan.textContent = senderName;
            
            // ğŸ¯ CHAT'TE BAKTERÄ° SEÃ‡Ä°MÄ° - Ä°sme tÄ±klayÄ±nca bakteriyi seÃ§
            if (sender === 'bacteria') {
                nameSpan.addEventListener('click', () => {
                    const bacteria = bacteriaPopulation.find(b => b.name === senderName);
                    if (bacteria) {
                        selectBacteria(bacteria);
                        console.log(`ğŸ¯ Selected bacteria ${senderName} from chat`);
                        
                        // Visual feedback
                        nameSpan.style.background = '#10B981';
                        nameSpan.style.color = 'white';
                        setTimeout(() => {
                            nameSpan.style.background = '';
                            nameSpan.style.color = '';
                        }, 1000);
                    }
                });
                
                nameSpan.title = `${senderName} bakterisini seÃ§mek iÃ§in tÄ±klayÄ±n`;
            }
            
            const messageSpan = document.createElement('div');
            messageSpan.textContent = message;
            
            bubble.appendChild(nameSpan);
            bubble.appendChild(messageSpan);
            messageDiv.appendChild(bubble);
            messagesArea.appendChild(messageDiv);
            
            // Auto scroll
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function sendIndividualMessage(bacteria, chatInput, messagesArea) {
            const message = chatInput.value.trim();
            if (!message) return;
            
            // Add user message
            addMessageToWindow(messagesArea, message, 'user', 'Sen');
            
            // Save to bacteria's conversation history
            bacteria.conversation_history = bacteria.conversation_history || [];
            
            // Generate bacteria response
            setTimeout(async () => {
                const response = await generateBacteriaResponse(bacteria, message, 'user');
                addMessageToWindow(messagesArea, response, 'bacteria', bacteria.name);
                
                // Save conversation
                bacteria.conversation_history.push({ user: message, bacteria: response });
                
                // Learn from user
                const newWords = learnFromUserInput(message, bacteria);
                if (newWords > 0) {
                    bacteria.consciousness_level = bacteria.consciousness_level + 0.02;
                }
                
            }, 500 + Math.random() * 1000);
            
            chatInput.value = '';
        }

        function makeDraggable(modal, header) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = modal.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                
                modal.style.position = 'fixed';
                modal.style.left = initialX + 'px';
                modal.style.top = initialY + 'px';
                modal.classList.remove('items-center', 'justify-center');
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                modal.style.left = (initialX + dx) + 'px';
                modal.style.top = (initialY + dy) + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        function setupGroupChat() {
            chatMode = 'group';
            selectedBacteria = null;
            chatInfoDiv.innerHTML = `<strong>Grup Sohbeti</strong> - TÃ¼m bakterilerle konuÅŸuyorsunuz.`;
            chatMessagesDiv.innerHTML = '';
            chatInput.disabled = false;
            sendMessageBtn.disabled = false;
            chatInput.placeholder = "TÃ¼m bakterilerle konuÅŸ...";
            chatInput.focus();
            updateChatModeButtons();
            updateBuildInfo();
            console.log(`ğŸ‘¥ Group chat mode activated with ${bacteriaPopulation.length} bacteria`);
        }

        function updateChatModeButtons() {
            const individualBtn = document.getElementById('individualChatBtn');
            const groupBtn = document.getElementById('groupChatBtn');
            
            if (chatMode === 'individual') {
                individualBtn.className = 'bg-blue-700 text-white px-3 py-1 rounded text-sm';
                groupBtn.className = 'bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded text-sm transition';
            } else {
                individualBtn.className = 'bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded text-sm transition';
                groupBtn.className = 'bg-green-700 text-white px-3 py-1 rounded text-sm';
            }
        }

        // ESKÄ° EVENT LÄ°STENERLAR KALDIRILDI - YEÅÄ° EVENT DELEGATÄ°ON SÄ°STEMÄ° KULLANILIYOR
        // nextStepBtn ve resetSimulationBtn artÄ±k yok, data-action ile yÃ¶netiliyor

        // Add food on click
        simulationArea.addEventListener('click', (e) => {
            const rect = simulationArea.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            addFood(x, y);
        });

        sendMessageBtn.addEventListener('click', () => {
            const message = chatInput.value.trim();
            if (message) {
                if (chatMode === 'group') {
                    // GRUP SOHBETÄ° - TÃ¼m bakterilere gÃ¶nder
                    sendMessageToAllBacteria(message);
                } else if (selectedBacteria) {
                    // TEKÄ°L SOHBETÄ° - Sadece seÃ§ili bakteriye gÃ¶nder
                    sendMessageToIndividualBacteria(selectedBacteria, message);
                } else {
                    alert('âš ï¸ Ã–nce bir bakteri seÃ§in veya grup sohbetine geÃ§in.');
                    return;
                }
                chatInput.value = '';
            }
        });

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !chatInput.disabled) {
                sendMessageBtn.click();
            }
        });

        // Chat mode event listeners
        document.getElementById('individualChatBtn').addEventListener('click', () => {
            if (selectedBacteria) {
                // v826: Use new modal system instead of old chat
                openIndividualChatWindow(selectedBacteria);
            } else {
                alert('âš ï¸ Ã–nce bir bakteri seÃ§in. Bir bakteriye tÄ±klayarak seÃ§ebilirsiniz.');
            }
        });

        document.getElementById('groupChatBtn').addEventListener('click', () => {
            setupGroupChat();
        });

        document.getElementById('startBacteriaConversationBtn').addEventListener('click', () => {
            console.log('ğŸ¯ Manual bacteria conversation button clicked');
            
            // Use the new conversation system
            if (bacteriaList.length >= 2) {
                const consciousBacteria = bacteriaList.filter(b => b.consciousness > 0.4);
                if (consciousBacteria.length >= 2) {
                    console.log(`ğŸ¤ Found ${consciousBacteria.length} conscious bacteria, starting conversation...`);
                    initiateBacteriaConversation();
                } else {
                    console.log('âš ï¸ Not enough conscious bacteria for conversation (need consciousness > 40%)');
                    alert(`âš ï¸ Need bacteria with >40% consciousness. Current: ${bacteriaList.map(b => `${b.name}: ${(b.consciousness*100).toFixed(0)}%`).join(', ')}`);
                }
            } else {
                console.log('âš ï¸ Need at least 2 bacteria for conversation');
                alert('âš ï¸ Need at least 2 bacteria for conversation');
            }
        });

        // v829: High-Frequency Auto Bacteria Conversations for Dynamic Experience
        setInterval(() => {
            if (bacteriaPopulation.length >= 2) {
                // Very high frequency natural conversations for dynamic experience
                const socialBacteria = bacteriaPopulation.filter(b => b.personality_traits.sociability > 0.3);
                
                if (socialBacteria.length >= 2 && Math.random() < 0.9) { // 90% chance for more interactions
                    startNaturalBacteriaConversation(socialBacteria);
                }
                
                // More frequent learning sessions
                if (bacteriaPopulation.length >= 3 && Math.random() < 0.4) { // 40% chance
                    startGroupLearningSession();
                }
            }
        }, 2500); // Every 2.5 seconds - even more frequent interactions

        // Initialize ML System
        async function initializeMLSystem() {
            console.log('ğŸ§  Initializing TensorFlow.js ML System...');
            
            try {
                // Initialize tokenizer
                initializeTokenizer();
                
                // Create models
                console.log('ğŸ”§ Creating neural network models...');
                wordEmbeddingModel = await createWordEmbeddingModel();
                behaviorPredictionModel = await createBehaviorModel();
                
                isMLReady = true;
                console.log('âœ… ML System ready! TensorFlow.js version:', tf.version.tfjs);
                updateBuildInfo();
                
            } catch (error) {
                console.error('âŒ ML System initialization failed:', error);
                isMLReady = false;
            }
        }

        // Memory Management System for better performance
        class MemoryManager {
            static cleanup() {
                // Remove invalid bacteria references
                bacteriaList = bacteriaList.filter(bacteria => 
                    bacteria && bacteria.x !== undefined && bacteria.biological_state
                );
                
                // Cleanup old food particles
                if (foodParticles.length > 20) {
                    foodParticles.splice(0, foodParticles.length - 15);
                }
                
                // Compact bacteria memory arrays
                bacteriaList.forEach(bacteria => {
                    if (bacteria.memory_bank && bacteria.memory_bank.length > 20) {
                        bacteria.memory_bank = bacteria.memory_bank.slice(-15);
                    }
                    if (bacteria.consciousness_history && bacteria.consciousness_history.length > 50) {
                        bacteria.consciousness_history = bacteria.consciousness_history.slice(-30);
                    }
                });

                console.log('ğŸ§¹ Memory cleanup completed');
            }

            static getMemoryUsage() {
                if (performance.memory) {
                    return {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                    };
                }
                return { used: 0, total: 0, limit: 0 };
            }
        }

        // Enhanced Data Export Function with memory info
        function exportEnhancedData() {
            const memoryInfo = MemoryManager.getMemoryUsage();
            const exportData = {
                version: VERSION,
                timestamp: new Date().toISOString(),
                simulation: {
                    day: simulationManager ? simulationManager.simulationDay : 0,
                    totalBacteria: bacteriaList.length,
                    running: simulationRunning
                },
                performance: {
                    fps: performanceMetrics.fps,
                    renderTime: performanceMetrics.renderTime,
                    memoryUsage: performanceMetrics.totalMemoryUsage,
                    systemMemory: memoryInfo
                },
                bacteria: bacteriaList.map(b => ({
                    id: b.id,
                    name: b.name,
                    consciousness: b.consciousness_level,
                    age: b.biological_state.age,
                    size: b.biological_state.size,
                    vocabularySize: b.vocabulary.size,
                    position: { x: b.x, y: b.y },
                    personality: b.personality_traits
                })),
                summary: {
                    averageConsciousness: bacteriaList.reduce((sum, b) => sum + b.consciousness_level, 0) / bacteriaList.length,
                    maxConsciousness: Math.max(...bacteriaList.map(b => b.consciousness_level)),
                    totalVocabulary: new Set(bacteriaList.flatMap(b => Array.from(b.vocabulary))).size
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `neomag_export_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('ğŸ“Š Enhanced data export completed:', exportData.summary);
        }

        // Initialize everything with modern architecture
        async function initialize() {
            console.log(`ğŸš€ Starting NeoMag ${VERSION} with Advanced AI/ML`);
            
            // Initialize AI systems first
            const aiSuccess = initializeAISystems();
            if (!aiSuccess) {
                console.warn('âš ï¸ AI systems failed to initialize, continuing without AI');
            }
            
            // Initialize UI Manager for event delegation
            uiManager = new UIManager(simulationManager);
            updateBuildInfo();
            initializeBacteria();
            initializeCanvas(); // v829: Initialize canvas support
            await initializeMLSystem();
            
            // Show feature list
            console.log('ğŸ“‹ Available Features:');
            FEATURES.forEach((feature, i) => {
                console.log(`   ${i+1}. ${feature}`);
            });
            
            // Update version to show AI integration
            const versionDisplay = document.querySelector('h1');
            if (versionDisplay && aiSuccess) {
                versionDisplay.innerHTML = 'ğŸ§¬ mnBac v9.6.2 - System Readiness & GitHub Pages Fix';
            }
        }

        // Initialize simulation (v826)
        async function initializeV826() {
            console.log('ğŸš€ Initializing mnBac v9.6.2 - System Readiness & GitHub Pages Fix...');
            
            // Initialize ML models first (placeholder)
            console.log('ğŸ§  ML models loading skipped for now');
            
            // Auto-restore from database or create new bacteria
            await autoRestoreFromDatabase();
            
            updateBuildInfo();
            renderBacteria();
            
            console.log('âœ… Initialization complete');
        }

        // Start v826 initialization after main initialization
        setTimeout(initializeV826, 1000);

        // v825: Database Control Functions
        async function exportCSV() {
            console.log('ğŸ“Š Exporting CSV for TabPFN analysis...');
            await persistentDB.exportToCSV();
        }

        async function saveAllNow() {
            console.log('ğŸ’¾ Manual save triggered...');
            for (const bacteria of bacteriaList) {
                await bacteria.saveToDatabase();
            }
            
            // Save simulation state
            await persistentDB.saveSimulationState(
                simulationDay, 
                bacteriaList, 
                performanceMetrics
            );
            
            console.log('âœ… All bacteria and simulation state saved');
        }

        async function loadFromDatabase() {
            console.log('ğŸ“– Loading bacteria from database...');
            const savedBacteria = await persistentDB.loadBacteria();
            
            if (savedBacteria.length === 0) {
                console.log('âš ï¸ No saved bacteria found');
                return;
            }
            
            // Clear current bacteria
            bacteriaList = [];
            
            // Restore bacteria from database
            let maxId = 0;
            savedBacteria.forEach(bacteriaData => {
                const bacteria = new BacteriaEntity(bacteriaData.id, bacteriaData.name, bacteriaData);
                bacteriaList.push(bacteria);
                maxId = Math.max(maxId, bacteriaData.id);
            });
            
            // Update ID counter
            bacteriaIdCounter = maxId + 1;
            
            console.log(`ğŸ“– Restored ${savedBacteria.length} bacteria from database`);
            updateBuildInfo();
            renderBacteria();
        }

        async function clearDatabase() {
            if (confirm('âš ï¸ This will permanently delete all saved bacteria data. Continue?')) {
                console.log('ğŸ—‘ï¸ Clearing database...');
                await persistentDB.clearDatabase();
                console.log('âœ… Database cleared');
            }
        }

        async function showDatabaseStats() {
            const savedBacteria = await persistentDB.loadBacteria();
            
            if (savedBacteria.length === 0) {
                alert('ğŸ“Š Database Stats:\n\nNo bacteria data found');
                return;
            }
            
            const totalBacteria = savedBacteria.length;
            const avgConsciousness = savedBacteria.reduce((sum, b) => sum + b.consciousness_level, 0) / totalBacteria;
            const maxConsciousness = Math.max(...savedBacteria.map(b => b.consciousness_level));
            const totalVocab = new Set(savedBacteria.flatMap(b => b.vocabulary)).size;
            const avgAge = savedBacteria.reduce((sum, b) => sum + b.biological_state.age, 0) / totalBacteria;
            const maxRuntimeDays = Math.max(...savedBacteria.map(b => b.total_runtime_days || 0));
            
            const stats = `ğŸ“Š Database Stats:
            
Total Bacteria: ${totalBacteria}
Average Consciousness: ${avgConsciousness.toFixed(2)}
Maximum Consciousness: ${maxConsciousness.toFixed(2)}
Total Unique Vocabulary: ${totalVocab} words
Average Age: ${avgAge.toFixed(1)} days
Maximum Runtime: ${maxRuntimeDays} days

Consciousness Levels:
â€¢ 0-1: ${savedBacteria.filter(b => b.consciousness_level < 1).length}
â€¢ 1-5: ${savedBacteria.filter(b => b.consciousness_level >= 1 && b.consciousness_level < 5).length}
â€¢ 5-10: ${savedBacteria.filter(b => b.consciousness_level >= 5 && b.consciousness_level < 10).length}
â€¢ 10-50: ${savedBacteria.filter(b => b.consciousness_level >= 10 && b.consciousness_level < 50).length}
â€¢ 50+: ${savedBacteria.filter(b => b.consciousness_level >= 50).length}`;
            
            alert(stats);
        }

        // Missing Event Handler Functions
        function toggleGroupChat() {
            chatMode = chatMode === 'individual' ? 'group' : 'individual';
            console.log(`ğŸ’¬ Chat mode switched to: ${chatMode}`);
        }
        
        function exportCSV() {
            console.log('ğŸ“Š CSV Export triggered');
            // Functionality implemented elsewhere
        }
        
        function exportEnhancedData() {
            console.log('ğŸ“ˆ JSON Export triggered');
            // Functionality implemented elsewhere
        }
        
        // ğŸ§¬ CRITICAL MISSING FUNCTION
        function addBacteria() {
            if (bacteriaPopulation.length >= CONFIG.SIMULATION.MAX_BACTERIA_POPULATION) {
                alert(`âš ï¸ Maximum ${CONFIG.SIMULATION.MAX_BACTERIA_POPULATION} bacteria limit reached!`);
                return;
            }
            
            const bacteria = new BacteriaEntity(bacteriaIdCounter, `Bakteri-${bacteriaIdCounter}`);
            bacteriaPopulation.push(bacteria);
            bacteriaList.push(bacteria); // v826 compatibility
            bacteriaIdCounter++;
            
            console.log(`â• New bacteria added: ${bacteria.name} (Total: ${bacteriaPopulation.length})`);
            
            // Update displays
            updateBuildInfo();
            if (typeof renderBacteria === 'function') renderBacteria();
        }
        
        // ğŸš€ CRITICAL MISSING FUNCTION  
        function initializeBacteria() {
            console.log('ğŸš€ Initializing bacteria population...');
            
            // Clear existing populations
            bacteriaPopulation = [];
            bacteriaList = [];
            
            // Create initial bacteria
            for (let i = 0; i < CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT; i++) {
                const bacteria = new BacteriaEntity(bacteriaIdCounter, `Bakteri-${bacteriaIdCounter}`);
                bacteriaPopulation.push(bacteria);
                bacteriaList.push(bacteria); // v826 compatibility
                bacteriaIdCounter++;
            }
            
            console.log(`âœ… ${CONFIG.SIMULATION.INITIAL_BACTERIA_COUNT} bacteria initialized`);
            updateBuildInfo();
        }

        function showLearningStats() {
            console.log('ğŸ§  SHOWING LEARNING STATS...');
            
            // Check if learning engine exists
            if (!learningEngine) {
                alert('âš ï¸ AI Learning Engine is not initialized yet. Please wait for system to fully load.');
                return;
            }
            
            let fullStats = '';
            
            // ğŸ§¬ Enhanced Persistent Learning Stats
            if (window.persistentLearning && window.persistentLearning.isReady) {
                const persistentStats = window.persistentLearning.getLearningStats();
                
                let topWordsText = 'ğŸ“š Top Learned Words:\n';
                persistentStats.topWords.slice(0, 8).forEach(({word, successRate}) => {
                    const percentage = (successRate * 100).toFixed(0);
                    const emoji = successRate > 0.8 ? 'ğŸŒŸ' : successRate > 0.6 ? 'âœ…' : 'ğŸ“–';
                    topWordsText += `${emoji} ${word}: ${percentage}% success\n`;
                });
                
                let topContextsText = '\nğŸ¯ Top Context Patterns:\n';
                persistentStats.topContexts.forEach(({context, effectiveness}) => {
                    const percentage = (effectiveness * 100).toFixed(0);
                    const emoji = effectiveness > 0.8 ? 'ğŸš€' : effectiveness > 0.6 ? 'âœ…' : 'ğŸ“Š';
                    topContextsText += `${emoji} ${context}: ${percentage}% effective\n`;
                });
                
                fullStats += `ğŸ§¬ Persistent Learning Engine Stats:

ğŸ’¾ Total Interactions: ${persistentStats.totalInteractions}
ğŸ“š Vocabulary Size: ${persistentStats.vocabularySize} words
ğŸ“ˆ Average Success Rate: ${(persistentStats.averageSuccessRate * 100).toFixed(1)}%
ğŸ“Š Learning Trend: ${(persistentStats.learningTrend * 100).toFixed(0)}%

${topWordsText}${topContextsText}

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

`;
            }
            
            // ğŸ§  Original AI Learning Stats
            const stats = learningEngine.getStats();
            const recentDecisions = learningEngine.decisionLog.slice(-10);
            
            let recentSummary = 'ğŸ“Š Recent AI Decisions:\n';
            recentDecisions.forEach((log, i) => {
                const outcome = log.outcome || 'pending';
                const emoji = outcome === 'success' ? 'âœ…' : outcome === 'failure' ? 'âŒ' : 'â³';
                recentSummary += `${emoji} ${log.source}: ${log.output.substring(0, 30)}... (${(log.confidence * 100).toFixed(0)}%)\n`;
            });
            
            const errorPatterns = Array.from(learningEngine.errorPatterns.entries()).slice(0, 3);
            let errorSummary = '\nğŸš¨ Top Error Patterns:\n';
            errorPatterns.forEach(([pattern, data]) => {
                const p = JSON.parse(pattern);
                errorSummary += `â€¢ ${p.source} confidence ${p.confidenceRange}: ${data.count} failures\n`;
            });
            
            fullStats += `ğŸ§  AI Self-Learning Stats:

ğŸ“ˆ Total Decisions: ${stats.totalDecisions}
ğŸ¯ Recent Success Rate: ${(stats.recentSuccessRate * 100).toFixed(1)}%
âŒ Error Patterns Detected: ${stats.errorPatterns}
âœ… Success Patterns Learned: ${stats.successPatterns}

${recentSummary}${errorSummary}

ğŸ”¬ The AI is continuously learning from decision outcomes and user interactions to improve future predictions.`;
            
            alert(fullStats);
        }

        // ğŸ§¬ Clear Persistent Learning Database
        async function clearLearningDatabase() {
            if (!window.persistentLearning || !window.persistentLearning.isReady) {
                alert('âš ï¸ Persistent Learning Engine is not ready yet.');
                return;
            }
            
            const confirmed = confirm(
                'ğŸš¨ Are you sure you want to clear all learning data?\n\n' +
                'This will delete:\n' +
                'â€¢ All user interactions\n' +
                'â€¢ Learned vocabulary with success rates\n' +
                'â€¢ Context patterns\n' +
                'â€¢ Learning metrics\n\n' +
                'This action cannot be undone!'
            );
            
            if (confirmed) {
                try {
                    await window.persistentLearning.clearDatabase();
                    alert('âœ… Learning database cleared successfully!\n\nThe system will start learning fresh from your next interactions.');
                    console.log('ğŸ§¬ Persistent Learning Database cleared by user');
                } catch (error) {
                    console.error('âŒ Failed to clear learning database:', error);
                    alert('âŒ Failed to clear learning database. Please check the console for details.');
                }
            }
        }

        // ğŸ›¡ï¸ System Readiness Checker
        function isSystemReady() {
            // Priority 1: Check if system is fully ready
            if (window.systemFullyReady) {
                return true;
            }
            
            // Priority 2: Check if basic simulation is ready (bacteria exist)
            if (bacteriaList && bacteriaList.length > 0) {
                return true;
            }
            
            // Priority 3: Check if any critical system is available
            const checks = {
                enhancedMorphGenerator: window.enhancedMorphGenerator || window.morphGenerator,
                languageEvolutionEngine: window.languageEvolutionEngine,
                simulationManager: window.simulationManager
            };
            
            return Object.values(checks).some(check => check);
        }
        
        // ğŸ“Š Get System Status for User Info
        function getSystemStatus() {
            const status = {
                fullyReady: !!window.systemFullyReady,
                bacteriaCount: bacteriaList ? bacteriaList.length : 0,
                systemsLoaded: 0,
                totalSystems: 4,
                readyTime: window.systemFullyReady ? 'Ready!' : 'Loading...'
            };
            
            if (window.enhancedMorphGenerator) status.systemsLoaded++;
            if (window.languageEvolutionEngine) status.systemsLoaded++;
            if (window.simulationManager) status.systemsLoaded++;
            if (bacteriaList && bacteriaList.length > 0) status.systemsLoaded++;
            
            return status;
        }

        // ğŸ­ Show Word Diversity Stats
        function showDiversityStats() {
            console.log('ğŸ­ SHOWING DIVERSITY STATS...');
            
            // Check if any system is ready, show detailed status
            if (!isSystemReady()) {
                const status = getSystemStatus();
                alert(`âš ï¸ System is still initializing...\n\nğŸ“Š Status: ${status.systemsLoaded}/${status.totalSystems} systems loaded\nğŸ§¬ Bacteria: ${status.bacteriaCount}\nâ±ï¸ ${status.readyTime}\n\nPlease wait a few more seconds and try again.\nFull initialization takes about 5-10 seconds.`);
                return;
            }
            
            try {
                // Import the diversity function dynamically
                import('./src/engine/MorphologicalDialogueGenerator.js').then(module => {
                    const { showDiversityStats } = module;
                    const stats = showDiversityStats();
                    
                    // Format the stats nicely
                    let displayText = `ğŸ­ WORD DIVERSITY ANALYSIS:

ğŸ“ Recent Words Used:
${stats.recentWords.map(word => `â€¢ ${word}`).join('\n')}

ğŸ” Most Repeated Words:
${stats.topRepeated.map(([word, count]) => `â€¢ ${word}: ${count} times`).join('\n')}

ğŸš« Currently Banned Words:
${stats.bannedWords.length > 0 ? stats.bannedWords.map(word => `â€¢ ${word}`).join('\n') : 'â€¢ None (Good!)'}

ğŸ¯ Current Context: ${stats.currentContext}
ğŸ“Š Sentences Generated: ${stats.sentenceCount}
ğŸ“š Total Vocabulary Used: ${stats.totalWordUsage} unique words

ğŸ” ANALYSIS:
${stats.bannedWords.length > 0 ? 
  `âš ï¸ ${stats.bannedWords.length} words are temporarily banned due to overuse.` :
  'âœ… No words are banned - good diversity!'
}

${stats.topRepeated.length > 0 && stats.topRepeated[0][1] > 3 ?
  `ğŸ”„ Word "${stats.topRepeated[0][0]}" has been used ${stats.topRepeated[0][1]} times recently.` :
  'âœ… No excessive word repetition detected.'
}

Context rotation is ${stats.sentenceCount > 0 ? 'active' : 'starting'}. Each 3 sentences trigger a context change.`;
                    
                    alert(displayText);
                }).catch(error => {
                    console.error('âŒ Failed to load diversity stats:', error);
                    alert('âŒ Failed to load diversity stats. Check console for details.');
                });
                
            } catch (error) {
                console.error('âŒ Error showing diversity stats:', error);
                alert('âŒ Error showing diversity stats. The Enhanced Morphological System might not be fully loaded yet.');
            }
        }

        // ğŸ”„ Reset Diversity System
        function resetDiversitySystem() {
            console.log('ğŸ”„ RESETTING DIVERSITY SYSTEM...');
            
            if (!isSystemReady()) {
                const status = getSystemStatus();
                alert(`âš ï¸ System is still initializing...\n\nğŸ“Š Status: ${status.systemsLoaded}/${status.totalSystems} systems loaded\nğŸ§¬ Bacteria: ${status.bacteriaCount}\nâ±ï¸ ${status.readyTime}\n\nPlease wait a few more seconds and try again.\nFull initialization takes about 5-10 seconds.`);
                return;
            }
            
            const confirmed = confirm(
                'ğŸ”„ Reset Word Diversity System?\n\n' +
                'This will:\n' +
                'â€¢ Clear recent word history\n' +
                'â€¢ Remove all banned words\n' +
                'â€¢ Reset word usage counters\n' +
                'â€¢ Reset context rotation\n\n' +
                'This can help if bacteria are stuck in repetitive patterns.'
            );
            
            if (confirmed) {
                try {
                    import('./src/engine/MorphologicalDialogueGenerator.js').then(module => {
                        const { resetDiversityEngine } = module;
                        resetDiversityEngine();
                        
                        alert('âœ… Diversity system reset successfully!\n\nBacteria will now have access to fresh vocabulary patterns.');
                        console.log('ğŸ”„ Diversity system reset by user');
                    }).catch(error => {
                        console.error('âŒ Failed to reset diversity system:', error);
                        alert('âŒ Failed to reset diversity system. Check console for details.');
                    });
                    
                } catch (error) {
                    console.error('âŒ Error resetting diversity system:', error);
                    alert('âŒ Error resetting diversity system. The Enhanced Morphological System might not be fully loaded yet.');
                }
            }
        }

        // ğŸ§  Language Evolution Stats Function
        function showLanguageEvolutionStats() {
            console.log('ğŸ“Š LANGUAGE EVOLUTION STATS...');
            
            if (!isSystemReady()) {
                const status = getSystemStatus();
                alert(`âš ï¸ System is still initializing...\n\nğŸ“Š Status: ${status.systemsLoaded}/${status.totalSystems} systems loaded\nğŸ§¬ Bacteria: ${status.bacteriaCount}\nâ±ï¸ ${status.readyTime}\n\nPlease wait a few more seconds and try again.\nFull initialization takes about 5-10 seconds.`);
                return;
            }
            
            try {
                const stats = {
                    totalGenerations: bacteriaList.reduce((sum, b) => sum + (b.languageGeneration || 0), 0),
                    avgVocabularySize: bacteriaList.reduce((sum, b) => sum + (b.vocabulary ? b.vocabulary.size : 0), 0) / bacteriaList.length,
                    totalWords: bacteriaList.reduce((sum, b) => sum + (b.vocabulary ? b.vocabulary.size : 0), 0),
                    activeBacteria: bacteriaList.length,
                    languageEvolutionRate: bacteriaList.filter(b => b.consciousness > 0.5).length / bacteriaList.length
                };
                
                const message = `ğŸ§  Language Evolution Statistics\n\n` +
                    `ğŸ“ˆ Total Language Generations: ${stats.totalGenerations}\n` +
                    `ğŸ“š Average Vocabulary Size: ${stats.avgVocabularySize.toFixed(1)} words\n` +
                    `ğŸ”¤ Total Words in System: ${stats.totalWords}\n` +
                    `ğŸ§¬ Active Bacteria: ${stats.activeBacteria}\n` +
                    `âš¡ Language Evolution Rate: ${(stats.languageEvolutionRate * 100).toFixed(1)}%\n\n` +
                    `ğŸ’¡ High-consciousness bacteria (>50%) are actively evolving language patterns.`;
                
                alert(message);
                console.log('ğŸ“Š Language Evolution Stats:', stats);
                
            } catch (error) {
                console.error('âŒ Error getting language evolution stats:', error);
                alert('âŒ Error retrieving language evolution statistics. Check console for details.');
            }
        }

        // ğŸ—£ï¸ Peer Dialogue Function  
        function runPeerDialogue() {
            console.log('ğŸ—£ï¸ PEER DIALOGUE...');
            
            if (bacteriaList.length < 2) {
                alert('âš ï¸ Peer Dialogue requires at least 2 bacteria.\n\nPlease add more bacteria to the simulation.');
                return;
            }
            
            try {
                // Select two random bacteria with highest consciousness
                const conscientBacteria = bacteriaList
                    .filter(b => b.consciousness > 0.3)
                    .sort((a, b) => b.consciousness - a.consciousness);
                
                if (conscientBacteria.length < 2) {
                    alert('âš ï¸ Need at least 2 conscious bacteria (consciousness > 30%).\n\nWait for bacteria to develop more consciousness.');
                    return;
                }
                
                const bacteria1 = conscientBacteria[0];
                const bacteria2 = conscientBacteria[1];
                
                // Generate peer dialogue
                const topics = ['science', 'art', 'emotion', 'discovery', 'mystery', 'friendship', 'evolution', 'creativity'];
                const topic = topics[Math.floor(Math.random() * topics.length)];
                
                console.log(`ğŸ—£ï¸ Peer dialogue between ${bacteria1.name} and ${bacteria2.name} about ${topic}`);
                
                // Generate responses using language evolution engine
                if (window.languageEvolutionEngine && window.languageEvolutionEngine.generateCrossBacteriaDialogue) {
                    window.languageEvolutionEngine.generateCrossBacteriaDialogue(bacteria1, bacteria2, topic)
                        .then(dialogue => {
                            alert(`ğŸ—£ï¸ Peer Dialogue: ${topic}\n\n${dialogue}`);
                            
                            // Add to chat
                            addChatMessage(`ğŸ—£ï¸ ${bacteria1.name} â†” ${bacteria2.name}`, dialogue, 'peer-dialogue');
                        })
                        .catch(error => {
                            console.error('âŒ Peer dialogue generation failed:', error);
                            
                            // Fallback simple dialogue
                            const fallbackDialogue = `${bacteria1.name}: "Bu ${topic} konusu Ã§ok ilginÃ§..."\n${bacteria2.name}: "Evet, ben de Ã¶yle dÃ¼ÅŸÃ¼nÃ¼yorum!"`;
                            alert(`ğŸ—£ï¸ Peer Dialogue (Simple): ${topic}\n\n${fallbackDialogue}`);
                        });
                } else {
                    // Simple fallback without language evolution engine
                    const simpleDialogue = `${bacteria1.name}: "Merhaba ${bacteria2.name}!"\n${bacteria2.name}: "Selam ${bacteria1.name}! NasÄ±lsÄ±n?"`;
                    alert(`ğŸ—£ï¸ Simple Peer Dialogue\n\n${simpleDialogue}`);
                    addChatMessage(`ğŸ—£ï¸ ${bacteria1.name} â†” ${bacteria2.name}`, simpleDialogue, 'simple-dialogue');
                }
                
            } catch (error) {
                console.error('âŒ Error in peer dialogue:', error);
                alert('âŒ Error running peer dialogue. Check console for details.');
            }
        }

        // v825: Auto-restore on page load
        async function autoRestoreFromDatabase() {
            console.log('ğŸ”„ Checking for saved bacteria to restore...');
            
            // Wait for database to be ready
            const maxWait = 5000; // 5 seconds
            const startTime = Date.now();
            
            while (!persistentDB.isReady && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (!persistentDB.isReady) {
                console.log('âš ï¸ Database not ready, skipping auto-restore');
                return;
            }
            
            const savedBacteria = await persistentDB.loadBacteria();
            
            if (savedBacteria.length > 0) {
                console.log(`ğŸ”„ Auto-restoring ${savedBacteria.length} bacteria from previous session...`);
                
                // Clear current bacteria
                bacteriaList = [];
                
                // Restore bacteria
                let maxId = 0;
                savedBacteria.forEach(bacteriaData => {
                    const bacteria = new BacteriaEntity(bacteriaData.id, bacteriaData.name, bacteriaData);
                    bacteriaList.push(bacteria);
                    maxId = Math.max(maxId, bacteriaData.id);
                });
                
                bacteriaIdCounter = maxId + 1;
                
                console.log('âœ… Auto-restore complete');
                updateBuildInfo();
                renderBacteria();
            } else {
                console.log('ğŸ“ No saved bacteria found, starting fresh simulation');
                
                // Create initial bacteria if none exist
                if (bacteriaList.length === 0) {
                    initializeBacteria();
                }
            }
        }

        // Dynamic Script Loader Utility
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                // Check if script already loaded
                if (document.querySelector(`script[src="${src}"]`)) {
                    resolve();
                    return;
                }
                
                const script = document.createElement('script');
                script.src = src;
                script.type = 'module';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Global Event Delegation System (Modern Approach)
        function initializeEventDelegation() {
            document.addEventListener('click', function(event) {
                const button = event.target.closest('button');
                if (!button || !button.dataset.action) return;
                
                const action = button.dataset.action;
                console.log(`ğŸ¯ Action triggered: ${action}`);
                
                // Ana kontrol paneli
                if (action === 'start-simulation') {
                    console.log('ğŸ”¥ START-SIMULATION CLICKED!', { simulationManager: !!simulationManager });
                    
                    if (!simulationManager) {
                        console.error('âŒ SimulationManager not ready yet - creating emergency instance');
                        alert('âš ï¸ Sistem henÃ¼z hazÄ±r deÄŸil! LÃ¼tfen biraz bekleyin ve tekrar deneyin.');
                        
                        // Emergency initialization
                        try {
                            simulationManager = new SimulationManager();
                            console.log('âœ… Emergency SimulationManager created');
                        } catch (e) {
                            console.error('âŒ Emergency SimulationManager creation failed:', e);
                            return;
                        }
                    }
                    
                    console.log('ğŸ”¥ SimulationManager isRunning:', simulationManager.isRunning);
                    
                    if (simulationManager.isRunning) {
                        simulationManager.pause();
                        button.textContent = 'â–¶ï¸ SimÃ¼lasyonu BaÅŸlat';
                        console.log('â¸ï¸ Simulation paused');
                    } else {
                        simulationManager.start();
                        button.textContent = 'â¸ï¸ SimÃ¼lasyonu Duraklat';
                        console.log('â–¶ï¸ Simulation started');
                    }
                }
                else if (action === 'pause-simulation') {
                    if (simulationManager) simulationManager.pause();
                }
                else if (action === 'reset-simulation') {
                    if (simulationManager) simulationManager.reset();
                }
                else if (action === 'add-bacteria') addBacteria();
                else if (action === 'toggle-group-chat') toggleGroupChat();
                
                // Database operations
                else if (action === 'export-csv') exportCSV();
                else if (action === 'export-json') exportEnhancedData();
                else if (action === 'save-all') saveAllNow();
                else if (action === 'load-saved') loadFromDatabase();
                else if (action === 'clear-db') clearDatabase();
                else if (action === 'show-db-stats') showDatabaseStats();
                else if (action === 'show-learning-stats') showLearningStats();
                else if (action === 'clear-learning-db') clearLearningDatabase();
                else if (action === 'show-diversity-stats') showDiversityStats();
                else if (action === 'reset-diversity') resetDiversitySystem();
                else if (action === 'show-language-stats') showLanguageEvolutionStats();
                else if (action === 'peer-dialogue') runPeerDialogue();
                else if (action === 'debug-system') debugSystemStatus();
                else if (action === 'test-conversation') testBacteriaConversation();
                else if (action === 'force-auto-conversation') forceStartAutoConversations();
            });
        }
        
        // ğŸ¯ BACTERIA SELECTION SYSTEM
        
        // Switch to individual chat mode
        function switchToIndividualChat(bacteria) {
            console.log(`ğŸ’¬ Switching to individual chat with: ${bacteria.name}`);
            
            // Get chat elements
            const chatModeIndicator = document.querySelector('.chat-mode-indicator');
            const chatInput = document.getElementById('chatInput');
            
            // Update chat mode
            chatMode = 'individual';
            
            // Update UI
            if (chatModeIndicator) {
                chatModeIndicator.textContent = `Individual Chat: ${bacteria.name}`;
                chatModeIndicator.className = 'chat-mode-indicator bg-blue-600 text-white px-3 py-1 rounded text-sm';
            }
            
            // Clear and focus input
            if (chatInput) {
                chatInput.placeholder = `Message ${bacteria.name}...`;
                chatInput.focus();
            }
            
            // Update build info
            updateBuildInfo();
        }
        
        // Highlight selected bacteria visually
        function highlightSelectedBacteria(bacteria) {
            bacteria.isSelected = true;
            bacteria.selectionTime = Date.now();
            
            // Remove selection from other bacteria
            bacteriaList.forEach(b => {
                if (b !== bacteria) {
                    b.isSelected = false;
                }
            });
            
            console.log(`âœ¨ Bacteria highlighted: ${bacteria.name}`);
        }
        
        // Add speech bubble above bacteria (NO MSGBOX!)
        function showSpeechBubble(bacteria, message) {
            // Create speech bubble element
            const bubble = document.createElement('div');
            bubble.className = 'speech-bubble';
            bubble.innerHTML = `
                <div class="speech-content">
                    <strong>${bacteria.name}:</strong><br/>
                    ${message}
                </div>
                <div class="speech-arrow"></div>
            `;
            
            // FIXED POSITIONING - Canvas Relative Coordinates
            let bubbleX = 100; // Default position
            let bubbleY = 100;
            
            try {
                // Get canvas element (multiple ways)
                const canvasElement = canvas || document.querySelector('canvas') || document.getElementById('canvas') || simulationArea?.querySelector('canvas');
                
                if (canvasElement && typeof canvasElement.getBoundingClientRect === 'function') {
                    const canvasRect = canvasElement.getBoundingClientRect();
                    const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                    const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                    
                    // Calculate absolute position on page
                    bubbleX = canvasRect.left + scrollX + (bacteria.x || 0) - 75; // Center bubble (150px width / 2)
                    bubbleY = canvasRect.top + scrollY + (bacteria.y || 0) - 80; // Above bacteria
                    
                    console.log(`ğŸ’¬ Bubble position: canvas(${canvasRect.left}, ${canvasRect.top}) + bacteria(${bacteria.x}, ${bacteria.y}) = bubble(${bubbleX}, ${bubbleY})`);
                } else {
                    // Advanced fallback: Find simulation area
                    const simArea = simulationArea || document.getElementById('simulationArea') || document.querySelector('[data-simulation-area]');
                    if (simArea) {
                        const simRect = simArea.getBoundingClientRect();
                        const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                        const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                        
                        bubbleX = simRect.left + scrollX + (bacteria.x || 0) - 75;
                        bubbleY = simRect.top + scrollY + (bacteria.y || 0) - 80;
                        console.log(`ğŸ’¬ Using simulation area fallback positioning`);
                    } else {
                        // Last resort fallback
                        bubbleX = (bacteria.x || 200) + 100; // Offset from bacteria coords
                        bubbleY = (bacteria.y || 200) + 50;
                        console.warn('âš ï¸ No canvas or simulation area found, using basic positioning');
                    }
                }
            } catch (error) {
                console.warn('âš ï¸ Error calculating bubble position:', error.message);
                bubbleX = (bacteria.x || 200) + 100;
                bubbleY = (bacteria.y || 200) + 50;
            }
            
            bubble.style.position = 'fixed';
            bubble.style.left = `${bubbleX}px`;
            bubble.style.top = `${bubbleY}px`;
            bubble.style.zIndex = '9999';
            bubble.style.pointerEvents = 'none';
            
            // Add to page
            document.body.appendChild(bubble);
            
            // Auto-remove after 2 seconds with fade out
            setTimeout(() => {
                bubble.style.opacity = '0';
                bubble.style.transform = 'translateY(-10px)';
                setTimeout(() => {
                    if (bubble.parentNode) {
                        bubble.parentNode.removeChild(bubble);
                    }
                }, 300); // Wait for fade animation
            }, 2000);
            
            console.log(`ğŸ’¬ Speech bubble shown for ${bacteria.name}: ${message}`);
        }

        // ğŸ¤ BACTERIA AUTO-COMMUNICATION SYSTEM
        
        // Auto-conversation timer
        let autoConversationInterval = null;
        
        // Start automatic bacteria conversations
        function startAutoBacteriaConversations() {
            if (autoConversationInterval) {
                clearInterval(autoConversationInterval);
            }
            
            // Every 2-4 seconds, bacteria might talk to each other (MUCH MORE FREQUENT)
            autoConversationInterval = setInterval(() => {
                if (bacteriaList.length >= 2 && simulationRunning) {
                    // 70% chance of conversation (VERY HIGH CHANCE)
                    if (Math.random() < 0.7) {
                        initiateBacteriaConversation();
                    }
                }
            }, Math.random() * 2000 + 2000); // 2-4 seconds (MUCH FASTER)
            
            console.log('ğŸ¤ Auto-bacteria conversations started - FREQUENT MODE');
        }
        
        // Stop automatic conversations
        function stopAutoBacteriaConversations() {
            if (autoConversationInterval) {
                clearInterval(autoConversationInterval);
                autoConversationInterval = null;
                console.log('ğŸ¤ Auto-bacteria conversations stopped');
            }
        }
        
        // Initiate conversation between bacteria
        function initiateBacteriaConversation() {
            // Find bacteria with moderate consciousness (>20%) - LOWERED THRESHOLD
            const consciousBacteria = bacteriaList.filter(b => {
                const consciousness = b.consciousness || b.consciousness_level || 0;
                return consciousness > 0.2; // LOWERED FROM 0.4 to 0.2
            });
            
            if (consciousBacteria.length < 2) return;
            
            // Pick two random bacteria
            const bacteria1 = consciousBacteria[Math.floor(Math.random() * consciousBacteria.length)];
            let bacteria2 = consciousBacteria[Math.floor(Math.random() * consciousBacteria.length)];
            
            // Make sure they're different
            while (bacteria2 === bacteria1 && consciousBacteria.length > 1) {
                bacteria2 = consciousBacteria[Math.floor(Math.random() * consciousBacteria.length)];
            }
            
            if (bacteria1 === bacteria2) return;
            
            // Check if they're close enough to talk (proximity-based communication)
            const distance = Math.hypot(bacteria1.x - bacteria2.x, bacteria1.y - bacteria2.y);
            const maxTalkDistance = 150; // Maximum distance to communicate
            
            if (distance > maxTalkDistance) return;
            
            // Generate conversation
            generateBacteriaToBacteriaConversation(bacteria1, bacteria2);
        }
        
        // Generate conversation between two bacteria
        async function generateBacteriaToBacteriaConversation(speaker, listener) {
            try {
                // Conversation topics based on bacteria state
                const topics = [
                    "food", "space", "growth", "friendship", "fear", "curiosity", 
                    "energy", "movement", "territory", "cooperation", "learning"
                ];
                
                const topic = topics[Math.floor(Math.random() * topics.length)];
                const speakerPersonality = speaker.personality || { optimism: 0.5, sociability: 0.5 };
                const listenerPersonality = listener.personality || { optimism: 0.5, sociability: 0.5 };
                
                // Generate message based on consciousness and personality
                let message;
                const speakerConsciousness = speaker.consciousness || speaker.consciousness_level || 0;
                
                if (speakerConsciousness > 0.8) {
                    // High consciousness - philosophical
                    const philosophicalMessages = [
                        `VaroluÅŸumuzun anlamÄ± nedir, ${listener.name}?`,
                        `Bu evrende yalnÄ±z mÄ±yÄ±z?`,
                        `BÃ¼yÃ¼mek her zaman iyi midir?`,
                        `ArkadaÅŸlÄ±k nedir?`
                    ];
                    message = philosophicalMessages[Math.floor(Math.random() * philosophicalMessages.length)];
                } else if (speakerConsciousness > 0.6) {
                    // Medium consciousness - social
                    const socialMessages = [
                        `Merhaba ${listener.name}, nasÄ±lsÄ±n?`,
                        `Bu bÃ¶lgede yemek var mÄ±?`,
                        `Beraber hareket edelim mi?`,
                        `BugÃ¼n kendimi bÃ¼yÃ¼k hissediyorum!`
                    ];
                    message = socialMessages[Math.floor(Math.random() * socialMessages.length)];
                } else {
                    // Low consciousness - basic needs
                    const basicMessages = [
                        "AÃ§Ä±m...",
                        "YardÄ±m...",
                        "Korku...",
                        "BÃ¼yÃ¼mek istiyorum"
                    ];
                    message = basicMessages[Math.floor(Math.random() * basicMessages.length)];
                }
                
                // Show speech bubble
                showSpeechBubble(speaker, message);
                
                // Update speaker's last spoken time
                speaker.lastSpoken = Date.now();
                
                // Add to chat history
                const chatBubble = document.createElement('div');
                chatBubble.className = 'bg-purple-700 text-white p-2 rounded mb-2 text-sm';
                chatBubble.innerHTML = `
                    <strong>${speaker.name}</strong> â†’ <strong>${listener.name}:</strong><br/>
                    ${message}
                    <div class="text-xs opacity-75 mt-1">ğŸ¤ Bacteria conversation</div>
                `;
                
                // Add to main chat
                if (chatMessagesDiv) {
                    chatMessagesDiv.insertBefore(chatBubble, chatMessagesDiv.firstChild);
                    // Keep only last 50 messages
                    while (chatMessagesDiv.children.length > 50) {
                        chatMessagesDiv.removeChild(chatMessagesDiv.lastChild);
                    }
                }
                
                // Track in word diversity system
                if (window.persistentLearning) {
                    window.persistentLearning.trackSpeech(speaker, message);
                }
                
                // Listener might respond (20% chance) - REDUCED FROM 30%
                if (Math.random() < 0.2 && listenerPersonality.sociability > 0.3) {
                    setTimeout(() => {
                        generateListenerResponse(listener, speaker, message);
                    }, 1500 + Math.random() * 3000); // 1.5-4.5 seconds delay
                }
                
                console.log(`ğŸ¤ Bacteria conversation: ${speaker.name} â†’ ${listener.name}: "${message}"`);
                
            } catch (error) {
                console.error('âŒ Error in bacteria conversation:', error);
            }
        }
        
        // Generate listener response
        function generateListenerResponse(responder, originalSpeaker, originalMessage) {
            const personality = responder.personality || { optimism: 0.5, sociability: 0.5 };
            
            let response;
            if (personality.optimism > 0.7) {
                const positiveResponses = [
                    "Evet, haklÄ±sÄ±n!",
                    "Ne gÃ¼zel bir dÃ¼ÅŸÃ¼nce!",
                    "Benimle konuÅŸtuÄŸun iÃ§in teÅŸekkÃ¼rler!",
                    "Beraber baÅŸarabiliriz!"
                ];
                response = positiveResponses[Math.floor(Math.random() * positiveResponses.length)];
            } else if (personality.optimism < 0.3) {
                const negativeResponses = [
                    "Bilmiyorum...",
                    "Korkuyorum",
                    "Emin deÄŸilim",
                    "Belki..."
                ];
                response = negativeResponses[Math.floor(Math.random() * negativeResponses.length)];
            } else {
                const neutralResponses = [
                    "AnlÄ±yorum",
                    "Ä°lginÃ§",
                    "DÃ¼ÅŸÃ¼nmeliyim",
                    "HaklÄ± olabilirsin"
                ];
                response = neutralResponses[Math.floor(Math.random() * neutralResponses.length)];
            }
            
            // Show response bubble
            showSpeechBubble(responder, response);
            
            // Update last spoken time
            responder.lastSpoken = Date.now();
            
            console.log(`ğŸ¤ Bacteria response: ${responder.name} â†’ ${originalSpeaker.name}: "${response}"`);
        }
        
        // ğŸ’¬ SEPARATED CHAT SYSTEM
        
        // Send message to all bacteria (GROUP CHAT)
        async function sendMessageToAllBacteria(message) {
            console.log(`ğŸ“¢ GROUP CHAT: User â†’ All bacteria: "${message}"`);
            
            // Add user message to group chat
            const userChatBubble = document.createElement('div');
            userChatBubble.className = 'bg-teal-600 text-white p-2 rounded mb-2 text-sm';
            userChatBubble.innerHTML = `
                <strong>Sen:</strong> ${message}
                <div class="text-xs opacity-75 mt-1">ğŸ“¢ Group message to ${bacteriaList.length} bacteria</div>
            `;
            
            if (chatMessagesDiv) {
                chatMessagesDiv.insertBefore(userChatBubble, chatMessagesDiv.firstChild);
            }
            
            // All bacteria receive and might respond
            const responseBacteria = bacteriaList.filter(b => b.consciousness > 0.3);
            
            for (const bacteria of responseBacteria) {
                // 50% chance each bacteria responds to group message
                if (Math.random() < 0.5) {
                    setTimeout(async () => {
                        const response = await generateBacteriaResponse(bacteria, message, 'group');
                        
                        // Show speech bubble over bacteria
                        showSpeechBubble(bacteria, response);
                        
                        // Add to group chat
                        const bacteriaChatBubble = document.createElement('div');
                        bacteriaChatBubble.className = 'bg-green-600 text-white p-2 rounded mb-2 text-sm';
                        bacteriaChatBubble.innerHTML = `
                            <strong>${bacteria.name}:</strong> ${response}
                            <div class="text-xs opacity-75 mt-1">ğŸ§¬ Consciousness: ${(bacteria.consciousness * 100).toFixed(0)}%</div>
                        `;
                        
                        if (chatMessagesDiv) {
                            chatMessagesDiv.insertBefore(bacteriaChatBubble, chatMessagesDiv.firstChild);
                        }
                        
                        // Track for learning
                        if (window.persistentLearning) {
                            window.persistentLearning.trackSpeech(bacteria, response);
                        }
                        
                    }, Math.random() * 3000 + 500); // Random 0.5-3.5s delay
                }
            }
        }
        
        // Send message to individual bacteria (INDIVIDUAL CHAT)
        async function sendMessageToIndividualBacteria(bacteria, message) {
            console.log(`ğŸ’¬ INDIVIDUAL CHAT: User â†’ ${bacteria.name}: "${message}"`);
            
            // Add user message to individual chat
            const userChatBubble = document.createElement('div');
            userChatBubble.className = 'bg-blue-600 text-white p-2 rounded mb-2 text-sm';
            userChatBubble.innerHTML = `
                <strong>Sen â†’ ${bacteria.name}:</strong> ${message}
                <div class="text-xs opacity-75 mt-1">ğŸ’¬ Individual conversation</div>
            `;
            
            if (chatMessagesDiv) {
                chatMessagesDiv.insertBefore(userChatBubble, chatMessagesDiv.firstChild);
            }
            
            // Generate bacteria response
            setTimeout(async () => {
                const response = await generateBacteriaResponse(bacteria, message, 'individual');
                
                // Show speech bubble over bacteria
                showSpeechBubble(bacteria, response);
                
                // Add bacteria response to chat
                const bacteriaChatBubble = document.createElement('div');
                bacteriaChatBubble.className = 'bg-purple-600 text-white p-2 rounded mb-2 text-sm';
                bacteriaChatBubble.innerHTML = `
                    <strong>${bacteria.name} â†’ Sen:</strong> ${response}
                    <div class="text-xs opacity-75 mt-1">
                        ğŸ§¬ Consciousness: ${((bacteria.consciousness || bacteria.consciousness_level || 0) * 100).toFixed(0)}% | 
                        ğŸ’ Mood: ${bacteria.personality?.optimism > 0.7 ? 'Happy' : bacteria.personality?.optimism < 0.3 ? 'Sad' : 'Neutral'}
                    </div>
                `;
                
                if (chatMessagesDiv) {
                    chatMessagesDiv.insertBefore(bacteriaChatBubble, chatMessagesDiv.firstChild);
                }
                
                // Track for learning
                if (window.persistentLearning) {
                    window.persistentLearning.trackSpeech(bacteria, response);
                }
                
                // Update bacteria's last spoken time
                bacteria.lastSpoken = Date.now();
                
            }, Math.random() * 2000 + 500); // Random 0.5-2.5s delay
        }
        
        // Generate bacteria response based on context
        async function generateBacteriaResponse(bacteria, userMessage, chatType) {
            const consciousness = bacteria.consciousness || bacteria.consciousness_level || 0;
            const personality = bacteria.personality || { optimism: 0.5, sociability: 0.5 };
            
            let response;
            
            if (consciousness > 0.8) {
                // High consciousness - thoughtful responses
                const thoughtfulResponses = [
                    `Bu konuda dÃ¼ÅŸÃ¼nmÃ¼ÅŸtÃ¼m. ${userMessage.includes('?') ? 'CevabÄ±m karmaÅŸÄ±k...' : 'Fikrimi paylaÅŸayÄ±m.'}`,
                    `AnlÄ±yorum. ${chatType === 'individual' ? 'Seninle konuÅŸmak gÃ¼zel.' : 'Herkesle paylaÅŸmaya deÄŸer.'}`,
                    `Ä°lginÃ§ perspektif. Ben ${personality.optimism > 0.6 ? 'umutluyum' : 'temkinliyim'}.`,
                    `VaroluÅŸsal olarak bakarsak, ${userMessage.toLowerCase().includes('neden') ? 'sebepleri derin' : 'her ÅŸeyin bir anlamÄ± var'}.`
                ];
                response = thoughtfulResponses[Math.floor(Math.random() * thoughtfulResponses.length)];
            } else if (consciousness > 0.5) {
                // Medium consciousness - social responses  
                const socialResponses = [
                    `${personality.sociability > 0.6 ? 'Evet, katÄ±lÄ±yorum!' : 'Belki haklÄ±sÄ±n.'}`,
                    `${chatType === 'group' ? 'Herkesi dinliyorum.' : 'Seninle konuÅŸmak hoÅŸ.'}`,
                    `${personality.optimism > 0.7 ? 'Bu gÃ¼zel!' : personality.optimism < 0.3 ? 'Biraz endiÅŸeliyim...' : 'AnladÄ±m.'}`,
                    `BÃ¼yÃ¼rken ${userMessage.toLowerCase().includes('Ã¶ÄŸren') ? 'Ã§ok ÅŸey Ã¶ÄŸreniyorum' : 'deneyimlerim artÄ±yor'}.`
                ];
                response = socialResponses[Math.floor(Math.random() * socialResponses.length)];
            } else {
                // Low consciousness - basic responses
                const basicResponses = [
                    "Evet...",
                    "AÃ§Ä±m...",
                    "BÃ¼yÃ¼mek istiyorum.",
                    `${personality.optimism < 0.4 ? 'Korkuyorum...' : 'Tamam.'}`,
                    "YardÄ±m..."
                ];
                response = basicResponses[Math.floor(Math.random() * basicResponses.length)];
            }
            
            return response;
        }
        
        // ğŸ”§ Debug System Status
        function debugSystemStatus() {
            console.log('ğŸ”§ DEBUGGING SYSTEM STATUS...');
            
            let debugInfo = 'ğŸ”§ SYSTEM DEBUG INFO:\n\n';
            
            // Check bacteria
            debugInfo += `ğŸ§¬ Bacteria Count: ${bacteriaList.length}\n`;
            debugInfo += `ğŸ“Š Bacteria with consciousness >50%: ${bacteriaList.filter(b => b.consciousness > 0.5).length}\n`;
            debugInfo += `ğŸ¤ Auto conversation running: ${autoConversationInterval !== null}\n`;
            debugInfo += `ğŸ“¡ Simulation running: ${simulationRunning}\n`;
            debugInfo += `ğŸ§¬ Conscious bacteria count (>20%): ${bacteriaList.filter(b => (b.consciousness || b.consciousness_level || 0) > 0.2).length}\n`;
            debugInfo += `ğŸ¯ High conscious bacteria (>40%): ${bacteriaList.filter(b => (b.consciousness || b.consciousness_level || 0) > 0.4).length}\n\n`;
            
            // Check system components
            debugInfo += `ğŸ”§ SYSTEM COMPONENTS:\n`;
            debugInfo += `â€¢ systemFullyReady: ${!!window.systemFullyReady}\n`;
            debugInfo += `â€¢ enhancedMorphGenerator: ${!!window.enhancedMorphGenerator}\n`;
            debugInfo += `â€¢ languageEvolutionEngine: ${!!window.languageEvolutionEngine}\n`;
            debugInfo += `â€¢ persistentLearning: ${!!window.persistentLearning}\n`;
            debugInfo += `â€¢ learningEngine: ${!!learningEngine}\n\n`;
            
            // Test morphological system
            debugInfo += `ğŸ“š MORPHOLOGICAL SYSTEM:\n`;
            if (window.enhancedMorphGenerator) {
                try {
                    const morphStatus = window.enhancedMorphGenerator.getSystemStatus ? 
                        window.enhancedMorphGenerator.getSystemStatus() : 'No status method';
                    debugInfo += `â€¢ Status: ${JSON.stringify(morphStatus)}\n`;
                } catch (e) {
                    debugInfo += `â€¢ Error: ${e.message}\n`;
                }
            } else {
                debugInfo += `â€¢ Not loaded yet\n`;
            }
            
            debugInfo += `\nğŸ’¾ PERSISTENT LEARNING:\n`;
            if (window.persistentLearning && window.persistentLearning.isReady) {
                const stats = window.persistentLearning.getLearningStats();
                debugInfo += `â€¢ Total Interactions: ${stats.totalInteractions}\n`;
                debugInfo += `â€¢ Vocabulary Size: ${stats.vocabularySize}\n`;
            } else {
                debugInfo += `â€¢ Not ready yet\n`;
            }
            
            // Check if bacteria have spoken
            debugInfo += `\nğŸ—£ï¸ RECENT BACTERIA ACTIVITY:\n`;
            const recentlySpoken = bacteriaList.filter(b => b.lastSpoken && (Date.now() - b.lastSpoken) < 60000);
            debugInfo += `â€¢ Recently spoken bacteria: ${recentlySpoken.length}\n`;
            
            if (bacteriaList.length > 0) {
                const firstBacteria = bacteriaList[0];
                const consciousness = firstBacteria.consciousness || firstBacteria.consciousness_level || 0;
                debugInfo += `â€¢ Sample bacteria consciousness: ${consciousness.toFixed(2)}\n`;
                debugInfo += `â€¢ Sample bacteria vocabulary size: ${firstBacteria.vocabulary ? firstBacteria.vocabulary.size : 'No vocabulary'}\n`;
            }
            
            alert(debugInfo);
            console.log('ğŸ”§ Debug Info:', debugInfo);
        }
        
        // ğŸ§ª TEST CONVERSATION SYSTEM
        function testBacteriaConversation() {
            console.log('ğŸ§ª TESTING BACTERIA CONVERSATION SYSTEM...');
            
            if (bacteriaList.length < 2) {
                alert('âŒ Need at least 2 bacteria for conversation test');
                return;
            }
            
            // Force a conversation between first two bacteria
            const bacteria1 = bacteriaList[0];
            const bacteria2 = bacteriaList[1];
            
            console.log(`ğŸ§ª Testing conversation: ${bacteria1.name} â†’ ${bacteria2.name}`);
            const consciousness1 = (bacteria1.consciousness || bacteria1.consciousness_level || 0) * 100;
            const consciousness2 = (bacteria2.consciousness || bacteria2.consciousness_level || 0) * 100;
            console.log(`Consciousness: ${bacteria1.name}=${consciousness1.toFixed(0)}%, ${bacteria2.name}=${consciousness2.toFixed(0)}%`);
            
            // Force generate conversation
            generateBacteriaToBacteriaConversation(bacteria1, bacteria2);
            
            // Test user message to bacteria
            setTimeout(() => {
                console.log('ğŸ§ª Testing user â†’ bacteria conversation');
                sendMessageToIndividualBacteria(bacteria1, 'Test message: NasÄ±lsÄ±n?');
            }, 2000);
            
            alert('ğŸ§ª Conversation test started! Check console and watch for speech bubbles.');
        }
        
        // ğŸš€ FORCE AUTO CONVERSATIONS
        function forceStartAutoConversations() {
            console.log('ğŸš€ FORCING AUTO CONVERSATIONS TO START...');
            
            // Stop any existing interval
            stopAutoBacteriaConversations();
            
            // Set simulation running if not already
            if (!simulationRunning) {
                simulationRunning = true;
                console.log('ğŸ¯ Simulation set to running');
            }
            
            // Start auto conversations
            startAutoBacteriaConversations();
            
            // Immediately trigger a conversation for testing
            setTimeout(() => {
                if (bacteriaList.length >= 2) {
                    console.log('ğŸ§ª Forcing immediate conversation...');
                    initiateBacteriaConversation();
                } else {
                    console.warn('âš ï¸ Not enough bacteria for conversation');
                }
            }, 1000);
            
            alert(`ğŸš€ Auto conversations FORCED to start! 
Simulation running: ${simulationRunning}
Bacteria count: ${bacteriaList.length}
Conscious bacteria: ${bacteriaList.filter(b => (b.consciousness || b.consciousness_level || 0) > 0.4).length}`);
        }

        // ğŸš€ MAIN INITIALIZATION - EVENT DRIVEN
        async function mainInitialize() {
            console.log('ğŸš€ mnBac v9.6.2 - System Readiness & GitHub Pages Fix - Final Initialization Complete!');
            
            // 1. Setup event listeners first
            initializeEventListeners();
            initializeEventDelegation();
            
            // 2. Basic setup
            updateBuildInfo(); // Initial state
            initializeCanvasSystem();
            initializeBacteriaPopulation();
            
            // 3. Initialize core systems (PROMISE-BASED ORDER)
            try {
                // DB first (others depend on it)
                persistentDB = new PersistentBacteriaDB();
                await persistentDB.initialize();
                console.log('âœ… Database initialization complete');
                
                // AI systems parallel (they don't depend on each other)
                const tabPFNAdapter = new TabPFNAdapter();
                realAI = new RealAITrainingSystem(); // Use global realAI variable
                
                // Initialize Learning Engine
                if (!learningEngine) {
                    learningEngine = new SystemLearningEngine();
                    console.log('âœ… AI Learning Engine initialized');
                }
                
                await Promise.all([
                    tabPFNAdapter.initialize(),
                    realAI.initialize()
                ]);
                console.log('âœ… AI systems initialization complete');
                
                // Emit final event
                appEvents.emit('all:systems:ready');
                
                // 4. Load saved data if available
                await autoRestoreFromDatabase();
                
                // 5. Start simulation manager
                simulationManager = new SimulationManager();
                
                // 6. ğŸ­ Initialize Advanced Comedy Culture System
                setTimeout(() => {
                    if (typeof tabpfnVocabularySystem !== 'undefined' && tabpfnVocabularySystem) {
                        jokeMasterInstance = new JokeMaster(tabpfnVocabularySystem);
                        console.log('ğŸ­ JokeMaster initialized with TabPFN integration');
                    } else {
                        jokeMasterInstance = new JokeMaster(null);
                        console.log('ğŸ­ JokeMaster initialized without TabPFN integration');
                    }
                }, 3000); // Wait for TabPFN to be ready
                
                // 7. ğŸ§¬ Initialize Dynamic Language Evolution System
                setTimeout(() => {
                    languageEvolutionEngine = new LanguageEvolutionEngine();
                    console.log('ğŸ§¬ Language Evolution Engine initialized - bacterial languages will now evolve!');
                }, 4000); // Wait for other systems to be ready
                
                // 8. ğŸ”¤ Initialize Enhanced Morphological System (Phase 2.7) - SAFE MODE
                setTimeout(async () => {
                    try {
                        console.log('ğŸ”¤ Attempting to initialize Enhanced Morphological System...');
                        
                        // Check if external scripts exist before loading
                        const scriptPaths = [
                            './src/engine/AITrainingAdapter.js',
                            './src/engine/EnhancedMorphologicalGenerator.js', 
                            './src/engine/MorphologicalDialogueGenerator.js',
                            './src/engine/PersistentLearningEngine.js'
                        ];
                        
                        let scriptsLoaded = 0;
                        
                        // Try to load each script safely
                        for (const scriptPath of scriptPaths) {
                            try {
                                if (typeof loadScript === 'function') {
                                    await loadScript(scriptPath);
                                    scriptsLoaded++;
                                    console.log(`âœ… Loaded: ${scriptPath}`);
                                } else {
                                    console.warn(`âš ï¸ loadScript function not available`);
                                    break;
                                }
                            } catch (scriptError) {
                                console.warn(`âš ï¸ Could not load ${scriptPath}:`, scriptError.message);
                            }
                        }
                        
                        if (scriptsLoaded === scriptPaths.length) {
                            // Only initialize if all scripts loaded successfully
                            if (typeof AITrainingAdapter !== 'undefined') {
                                window.aiTrainingAdapter = new AITrainingAdapter();
                                console.log('âœ… AITrainingAdapter initialized');
                            }
                            
                            if (typeof EnhancedMorphologicalGenerator !== 'undefined' && window.aiTrainingAdapter) {
                                window.enhancedMorphGenerator = new EnhancedMorphologicalGenerator(window.aiTrainingAdapter);
                                console.log('âœ… EnhancedMorphologicalGenerator initialized');
                            }
                            
                            // Try dynamic import for PersistentLearningEngine
                            try {
                                const { PersistentLearningEngine } = await import('./src/engine/PersistentLearningEngine.js');
                                window.persistentLearning = new PersistentLearningEngine();
                                console.log('âœ… PersistentLearningEngine initialized');
                            } catch (importError) {
                                console.warn('âš ï¸ PersistentLearningEngine dynamic import failed:', importError.message);
                                // Create a minimal fallback
                                window.persistentLearning = {
                                    isReady: true,
                                    trackSpeech: (bacteria, message) => {
                                        console.log(`ğŸ“ Speech tracked: ${bacteria.name}: ${message}`);
                                    },
                                    getLearningStats: () => ({
                                        totalInteractions: 0,
                                        vocabularySize: 0
                                    }),
                                    metrics: { totalInteractions: 0 }
                                };
                                console.log('âœ… Fallback PersistentLearning created');
                            }
                            
                            console.log('ğŸ”¤ Enhanced Morphological System initialized successfully!');
                        } else {
                            console.warn('âš ï¸ Some morphological scripts failed to load, using basic fallbacks');
                            
                            // Create basic fallback systems
                            window.persistentLearning = {
                                isReady: true,
                                trackSpeech: (bacteria, message) => {
                                    console.log(`ğŸ“ [Fallback] Speech tracked: ${bacteria.name}: ${message}`);
                                },
                                getLearningStats: () => ({
                                    totalInteractions: 0,
                                    vocabularySize: 0
                                }),
                                metrics: { totalInteractions: 0 }
                            };
                            
                            window.enhancedMorphGenerator = {
                                getSystemStatus: () => ({ status: 'fallback', ready: true })
                            };
                            
                            console.log('âœ… Fallback morphological systems created');
                        }
                        
                        // Mark system as ready regardless
                        window.systemFullyReady = true;
                        
                        // Update UI
                        const loadingIndicators = document.querySelectorAll('.loading-indicator');
                        loadingIndicators.forEach(indicator => {
                            indicator.style.display = 'none';
                        });
                        
                        // Emit events
                        appEvents.emit('morphological:system:ready');
                        appEvents.emit('persistent:learning:ready');
                        appEvents.emit('system:fully:ready');
                        
                        console.log('ğŸ‰ mnBac v9.6.2 FULLY LOADED - All systems operational!');
                        
                    } catch (error) {
                        console.error('âŒ Enhanced Morphological System initialization failed:', error);
                        
                        // Create emergency fallbacks
                        window.persistentLearning = {
                            isReady: true,
                            trackSpeech: () => {},
                            getLearningStats: () => ({ totalInteractions: 0, vocabularySize: 0 }),
                            metrics: { totalInteractions: 0 }
                        };
                        window.systemFullyReady = true;
                        console.log('ğŸš¨ Emergency fallback systems activated');
                    }
                }, 5000); // Wait for all other systems to be ready
                
                console.log('ğŸ‰ Event-driven initialization complete!');
                
            } catch (error) {
                console.error('âŒ Initialization error:', error);
                updateBuildInfo(); // Show error state
            }
        }

        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', mainInitialize);

    </script>
</body>
</html>