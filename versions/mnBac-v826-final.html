<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeoMag v8.2.6 - Real TensorFlow.js & Dynamic AI Training</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .bacteria {
            transition: all 0.5s ease-in-out;
            cursor: pointer;
        }
        .bacteria:hover {
            transform: scale(1.1);
        }
        .chat-bubble {
            max-width: 70%;
            word-wrap: break-word;
        }
        .chat-bubble-user {
            background-color: #3b82f6; /* blue-500 */
            color: white;
        }
        .chat-bubble-bacteria {
            background-color: #e5e7eb; /* gray-200 */
            color: #1f2937; /* gray-800 */
        }
        .smooth-scroll {
            scroll-behavior: smooth;
        }
        /* Custom scrollbar for chat */
        #chatMessages::-webkit-scrollbar {
            width: 8px;
        }
        #chatMessages::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #chatMessages::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        #chatMessages::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Loading spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 5px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col min-h-screen">

    <!-- Header -->
    <header class="bg-gray-800 shadow-lg p-4 sticky top-0 z-50">
        <h1 class="text-2xl font-bold text-center text-teal-400">🧬 NeoMag v8.2.6 - AI Bakteri Simülasyonu</h1>
        <div class="text-center text-xs text-teal-300 mt-1">
            🧠 Real TensorFlow.js Training | 🎯 Dynamic AI Prediction | 💽 Training Data Collection | ⚡ Live Model Updates
        </div>
        <div id="buildInfo" class="text-center text-xs text-gray-400 mt-1">
            Build: Loading...
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow container mx-auto p-2 sm:p-4 grid grid-cols-1 lg:grid-cols-3 gap-4">
        
        <!-- Sol Panel Simülasyon ve Detaylar -->
        <div class="lg:col-span-2 bg-gray-800 p-4 rounded-lg shadow-xl flex flex-col">
            <h2 class="text-xl font-semibold mb-3 text-teal-300 border-b border-gray-700 pb-2">Simülasyon Alanı</h2>
            <div id="simulationArea" class="bg-gray-700 rounded-md p-4 relative h-[400px] w-full overflow-hidden cursor-crosshair border-2 border-gray-600">
                <!-- Bakteriler ve yemekler buraya eklenecek -->
                <div class="absolute top-2 left-2 text-xs text-teal-300 bg-gray-800 bg-opacity-75 px-2 py-1 rounded">
                    🍎 Yemek eklemek için tıklayın | 🧬 Bakteriler için tıklayın
                </div>
                <div class="absolute top-2 right-2 text-xs text-blue-300 bg-gray-800 bg-opacity-75 px-2 py-1 rounded">
                    ⚗️ Moleküler Dinamik Simülasyonu
                </div>
            </div>
            <div class="mt-4 p-3 bg-gray-750 rounded-md">
                <h3 class="text-lg font-semibold mb-2 text-teal-300">Kontrol Paneli</h3>
                <div class="flex space-x-2">
                    <button id="startSimulationBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out">Simülasyonu Başlat</button>
                    <button id="nextStepBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out" disabled>Sonraki Adım</button>
                    <button id="resetSimulationBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out">Sıfırla</button>
                </div>
                <p id="simulationTime" class="mt-2 text-sm text-gray-400">Simülasyon Zamanı: 0 gün</p>
            </div>
            <div id="bacteriaDetails" class="mt-4 p-3 bg-gray-750 rounded-md hidden">
                <h3 class="text-lg font-semibold mb-2 text-teal-300" id="detailsHeader">Bakteri Detayları</h3>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 text-sm">
                    <p><strong>ID:</strong> <span id="bacteriaId" class="text-gray-300"></span></p>
                    <p><strong>İsim:</strong> <span id="bacteriaName" class="text-gray-300"></span></p>
                    <p><strong>Boyut:</strong> <span id="bacteriaSize" class="text-gray-300"></span> µm</p>
                    <p><strong>Yaş:</strong> <span id="bacteriaAge" class="text-gray-300"></span> gün</p>
                    <p><strong>Büyüme Hızı:</strong> <span id="bacteriaGrowthRate" class="text-gray-300"></span></p>
                    <p><strong>Bilinç Seviyesi:</strong> <span id="bacteriaConsciousness" class="text-gray-300"></span></p>
                    <p><strong>Kişilik (İyimserlik):</strong> <span id="bacteriaOptimism" class="text-gray-300"></span></p>
                    <p><strong>Kişilik (Sosyallik):</strong> <span id="bacteriaSociability" class="text-gray-300"></span></p>
                    <p><strong>Dil Aşaması:</strong> <span id="bacteriaLanguageStage" class="text-gray-300"></span></p>
                    <p><strong>Kelime Haznesi:</strong> <span id="bacteriaVocabulary" class="text-gray-300 break-all"></span></p>
                </div>
            </div>
        </div>

        <!-- Sağ Panel Sohbet -->
        <div class="bg-gray-800 p-4 rounded-lg shadow-xl flex flex-col max-h-[80vh] lg:max-h-full">
            <h2 class="text-xl font-semibold mb-3 text-teal-300 border-b border-gray-700 pb-2">Bakteri Sohbet Merkezi</h2>
            
            <!-- Chat Mode Selector -->
            <div class="mb-3 flex space-x-2">
                <button id="individualChatBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm transition">Tekil Sohbet</button>
                <button id="groupChatBtn" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm transition">Grup Sohbeti</button>
                <button id="startBacteriaConversationBtn" class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded text-sm transition">Bakteriler Konuşsun</button>
            </div>
            
            <div id="chatInfo" class="mb-2 text-sm text-gray-400">Sohbet modunu seçin.</div>
            <div id="chatMessages" class="flex-grow bg-gray-700 rounded-md p-3 overflow-y-auto mb-3 smooth-scroll space-y-2 h-64 min-h-[16rem] max-h-[20rem]" style="display: flex; flex-direction: column-reverse;">
                <!-- Sohbet mesajları buraya eklenecek -->
            </div>
            <div id="chatLoadingIndicator" class="hidden text-center py-2">
                <div class="loader"></div>
                <p class="text-sm text-gray-400">Bakteri düşünüyor...</p>
            </div>
            <div class="flex">
                <input type="text" id="chatInput" class="flex-grow bg-gray-600 text-gray-200 border border-gray-500 rounded-l-lg p-2 focus:ring-teal-500 focus:border-teal-500 outline-none" placeholder="Mesajınızı yazın..." disabled>
                <button id="sendMessageBtn" class="bg-teal-500 hover:bg-teal-600 text-white font-bold p-2 rounded-r-lg transition duration-150 ease-in-out" disabled>Gönder</button>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-gray-800 text-center p-3 text-sm text-gray-500">
        NeoMag v8.0.0 - Simülasyon Arayüzü Prototipi
    </footer>

    <!-- Controls -->
    <div class="bg-gray-800 p-4 rounded-lg mb-4">
        <div class="flex flex-wrap gap-2 mb-4">
            <button onclick="startSimulation()" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded">
                ▶️ Başlat
            </button>
            <button onclick="pauseSimulation()" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded">
                ⏸️ Duraklat
            </button>
            <button onclick="resetSimulation()" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">
                🔄 Reset
            </button>
            <button onclick="addBacteria()" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">
                ➕ Bakteri Ekle
            </button>
            <button onclick="toggleGroupChat()" class="bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded">
                💬 Grup Chat
            </button>
        </div>
        
        <!-- v825: Database Controls -->
        <div class="flex flex-wrap gap-2 mb-2">
            <button onclick="exportCSV()" class="bg-cyan-600 hover:bg-cyan-700 px-3 py-1 rounded text-sm">
                📊 CSV Export
            </button>
            <button onclick="saveAllNow()" class="bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded text-sm">
                💾 Save All
            </button>
            <button onclick="loadFromDatabase()" class="bg-teal-600 hover:bg-teal-700 px-3 py-1 rounded text-sm">
                📖 Load Saved
            </button>
            <button onclick="clearDatabase()" class="bg-red-500 hover:bg-red-600 px-3 py-1 rounded text-sm">
                🗑️ Clear DB
            </button>
            <button onclick="showDatabaseStats()" class="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm">
                📈 DB Stats
            </button>
        </div>
        
        <div class="text-xs text-gray-300">
            🧾 Persistent Database: Auto-save every 30s | ♾️ Unlimited Consciousness | 📊 TabPFN-ready CSV
        </div>
    </div>

    <script>
        // DOM Elements
        const simulationArea = document.getElementById('simulationArea');
        const bacteriaDetailsDiv = document.getElementById('bacteriaDetails');
        const detailsHeader = document.getElementById('detailsHeader');
        const bacteriaIdSpan = document.getElementById('bacteriaId');
        const bacteriaNameSpan = document.getElementById('bacteriaName');
        const bacteriaSizeSpan = document.getElementById('bacteriaSize');
        const bacteriaAgeSpan = document.getElementById('bacteriaAge');
        const bacteriaGrowthRateSpan = document.getElementById('bacteriaGrowthRate');
        const bacteriaConsciousnessSpan = document.getElementById('bacteriaConsciousness');
        const bacteriaOptimismSpan = document.getElementById('bacteriaOptimism');
        const bacteriaSociabilitySpan = document.getElementById('bacteriaSociability');
        const bacteriaLanguageStageSpan = document.getElementById('bacteriaLanguageStage');
        const bacteriaVocabularySpan = document.getElementById('bacteriaVocabulary');

        const chatInfoDiv = document.getElementById('chatInfo');
        const chatMessagesDiv = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const chatLoadingIndicator = document.getElementById('chatLoadingIndicator');

        const startSimulationBtn = document.getElementById('startSimulationBtn');
        const nextStepBtn = document.getElementById('nextStepBtn');
        const resetSimulationBtn = document.getElementById('resetSimulationBtn');
        const simulationTimeSpan = document.getElementById('simulationTime');

        // Simulation State
        let bacteriaPopulation = [];
        let bacteriaList = []; // v826 compatibility
        let bacteriaIdCounter = 1; // v826 ID tracking
        let foodParticles = [];
        let selectedBacteria = null;
        let simulationRunning = false;
        let simulationTimer = null;
        let simulationDay = 0;
        const SIMULATION_STEP_INTERVAL = 3000; // ms

        const INITIAL_BACTERIA_COUNT = 10;
        const MAX_VOCABULARY_DISPLAY = 10;
        const FOOD_SIZE = 8;

        // Version and Build Info (moved up to prevent hoisting issues)
        const VERSION = 'v8.2.6';
        const BUILD_DATE = new Date().toISOString().slice(0,19);
        const FEATURES = [
            'Real TensorFlow.js Neural Networks',
            'Dynamic AI Model Training',
            'Live Training Data Collection',
            'Dynamic Hunger & Energy Systems',
            'Persistent Database System',
            'Unlimited Consciousness Levels',
            'CSV Data Export/Import',
            'State Restoration',
            'Enhanced Environment Visualization',
            'Bacteria ID Labels',
            'Cross-Bacteria Learning',
            'Group Chat System',
            'Molecular Dynamics Simulation'
        ];
        const FOOD_NUTRITION = 0.5;

        // Chat State
        let chatMode = 'individual'; // 'individual', 'group'
        let bacteriaConversationTimer = null;
        let lastBacteriaConversationTime = 0;
        
        // v826: Individual Chat Windows System
        let globalConversations = []; // All bacteria-to-bacteria conversations
        let openChatWindows = new Map(); // bacteria.id -> modal element
        let chatWindowZIndex = 1000;

        // ML State
        let wordEmbeddingModel = null;
        let behaviorPredictionModel = null;
        let isMLReady = false;
        let wordTokenizer = new Map();

        // v824: TabPFN Integration for Advanced Behavior Prediction
        class TabPFNAdapter {
            constructor() {
                this.isReady = false;
                this.behaviorClassifier = null;
                this.personalityPredictor = null;
                this.vocabularyAnalyzer = null;
                this.initialize();
            }

            async initialize() {
                console.log('🧠 Initializing TabPFN-inspired ML systems...');
                
                // TabPFN-style rapid inference system
                this.createBehaviorClassifier();
                this.createPersonalityPredictor();
                this.createVocabularyAnalyzer();
                
                this.isReady = true;
                console.log('✅ TabPFN ML systems ready!');
                updateBuildInfo();
            }

            // TabPFN-inspired rapid behavior classification
            createBehaviorClassifier() {
                this.behaviorClassifier = {
                    predict: (features) => {
                        // TabPFN-style in-context learning simulation
                        const [age, size, consciousness, optimism, sociability, vocabSize, memoryCount, growthRate, hunger, energy, socialInteractions, learningRate] = features;
                        
                        // Multi-class behavior prediction (TabPFN can handle up to 10 classes)
                        const creativityScore = (consciousness * 0.3) + (vocabSize * 0.2) + (learningRate * 0.3) + (optimism * 0.2);
                        const socialScore = (sociability * 0.4) + (socialInteractions * 0.3) + (memoryCount * 0.2) + (optimism * 0.1);
                        const explorationScore = (energy * 0.3) + (growthRate * 0.2) + (age * 0.1) + (size * 0.2) + (consciousness * 0.2);
                        const learningScore = (learningRate * 0.4) + (consciousness * 0.3) + (vocabSize * 0.2) + (memoryCount * 0.1);
                        
                        // TabPFN-style ensemble decision
                        const behaviors = [
                            { name: 'creative', score: creativityScore },
                            { name: 'social', score: socialScore },
                            { name: 'explorer', score: explorationScore },
                            { name: 'learner', score: learningScore },
                            { name: 'basic', score: 0.4 } // baseline
                        ];
                        
                        return behaviors.sort((a, b) => b.score - a.score)[0].name;
                    }
                };
            }

            // TabPFN-inspired personality trait prediction
            createPersonalityPredictor() {
                this.personalityPredictor = {
                    predictEvolution: (bacteria) => {
                        // Predict how personality will evolve based on TabPFN-style rapid inference
                        const experienceVector = [
                            bacteria.biological_state.age / 100,
                            bacteria.conversation_history.length / 50,
                            bacteria.vocabulary.size / 100,
                            bacteria.memory_bank.filter(m => m.includes('arkadaş')).length / 10,
                            bacteria.memory_bank.filter(m => m.includes('öğrendim')).length / 10
                        ];
                        
                        const evolutionFactor = experienceVector.reduce((sum, val) => sum + val, 0) / experienceVector.length;
                        
                        return {
                            optimismChange: (evolutionFactor - 0.5) * 0.05,
                            sociabilityChange: (bacteria.conversation_history.length > 5 ? 0.02 : -0.01),
                            confidenceBoost: evolutionFactor * 0.1
                        };
                    }
                };
            }

            // TabPFN-inspired vocabulary analysis
            createVocabularyAnalyzer() {
                this.vocabularyAnalyzer = {
                    analyzeComplexity: (vocabulary) => {
                        const words = Array.from(vocabulary);
                        const biochemWords = words.filter(w => ['ATP', 'enzim', 'protein', 'metabolizma', 'sentez'].includes(w));
                        const socialWords = words.filter(w => ['arkadaş', 'konuşmak', 'paylaşım', 'birlikte'].includes(w));
                        const emotionalWords = words.filter(w => ['mutlu', 'üzgün', 'heyecanlı', 'meraklı'].includes(w));
                        
                        return {
                            totalComplexity: words.length,
                            biochemicalLevel: biochemWords.length / Math.max(1, words.length),
                            socialLevel: socialWords.length / Math.max(1, words.length),
                            emotionalLevel: emotionalWords.length / Math.max(1, words.length),
                            diversityScore: new Set(words.map(w => w.charAt(0))).size / 26 // alphabet diversity
                        };
                    },
                    
                    predictNextWord: (bacteria) => {
                        // TabPFN-style word prediction based on context
                        const analysis = this.analyzeComplexity(bacteria.vocabulary);
                        const consciousnessLevel = bacteria.consciousness_level;
                        
                        let wordCategories = [];
                        
                        if (analysis.biochemicalLevel < 0.2 && consciousnessLevel > 2) {
                            wordCategories = ['ATP', 'enzim', 'hücre', 'oksijen', 'karbon'];
                        } else if (analysis.socialLevel < 0.3 && bacteria.conversation_history.length > 3) {
                            wordCategories = ['dostluk', 'paylaşım', 'anlaşma', 'birliktelik', 'empati'];
                        } else if (analysis.emotionalLevel < 0.2 && consciousnessLevel > 3) {
                            wordCategories = ['sevinç', 'heyecan', 'merak', 'şaşkınlık', 'umut'];
                        } else {
                            wordCategories = ['yeni', 'keşif', 'deneyim', 'öğrenme', 'gelişim'];
                        }
                        
                        return wordCategories[Math.floor(Math.random() * wordCategories.length)];
                    }
                };
            }

            // TabPFN-style rapid behavioral adaptation
            adaptBehavior(bacteria, context) {
                if (!this.isReady) return 'basic';
                
                const features = this.extractFeatures(bacteria);
                const baseBehavior = this.behaviorClassifier.predict(features);
                
                // Context-aware adaptation (TabPFN-style contextual learning)
                if (context === 'group_interaction') {
                    const personalityEvolution = this.personalityPredictor.predictEvolution(bacteria);
                    if (personalityEvolution.sociabilityChange > 0) {
                        return 'social_enhanced';
                    }
                }
                
                if (context === 'learning_session') {
                    const vocabAnalysis = this.vocabularyAnalyzer.analyzeComplexity(bacteria.vocabulary);
                    if (vocabAnalysis.diversityScore > 0.3) {
                        return 'creative_learner';
                    }
                }
                
                return baseBehavior;
            }

            extractFeatures(bacteria) {
                return [
                    bacteria.biological_state.age / 100,
                    bacteria.biological_state.size / 5,
                    bacteria.consciousness_level / 5,
                    bacteria.personality_traits.optimism,
                    bacteria.personality_traits.sociability,
                    bacteria.vocabulary.size / 50,
                    bacteria.memory_bank.length / 20,
                    bacteria.biological_state.growth_rate,
                    0.5, // hunger
                    0.7, // energy
                    bacteria.conversation_history.length / 10,
                    bacteria.memory_bank.filter(m => m.includes('öğrendim')).length / 5
                ];
            }
        }

        // Initialize TabPFN adapter
        const tabPFNAdapter = new TabPFNAdapter();

        // v825: Persistent Database System
        class PersistentBacteriaDB {
            constructor() {
                this.dbName = 'NeoMagBacteriaDB';
                this.version = 1;
                this.isReady = false;
                this.initialize();
            }

            async initialize() {
                console.log('🗄️ Initializing Persistent Database...');
                
                // Use IndexedDB for robust storage
                if ('indexedDB' in window) {
                    await this.initIndexedDB();
                } else {
                    // Fallback to localStorage
                    console.log('📦 IndexedDB not available, using localStorage');
                    this.isReady = true;
                }
                
                updateBuildInfo();
            }

            async initIndexedDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => {
                        console.error('❌ IndexedDB initialization failed');
                        reject(request.error);
                    };

                    request.onsuccess = () => {
                        this.db = request.result;
                        this.isReady = true;
                        console.log('✅ IndexedDB initialized successfully');
                        resolve();
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Bacteria store
                        const bacteriaStore = db.createObjectStore('bacteria', { keyPath: 'id' });
                        bacteriaStore.createIndex('name', 'name', { unique: false });
                        bacteriaStore.createIndex('consciousness_level', 'consciousness_level', { unique: false });
                        bacteriaStore.createIndex('last_updated', 'last_updated', { unique: false });
                        
                        // Simulation history store
                        const historyStore = db.createObjectStore('simulation_history', { keyPath: 'timestamp' });
                        historyStore.createIndex('day', 'day', { unique: false });
                        
                        // TabPFN training data store
                        const tabpfnStore = db.createObjectStore('tabpfn_data', { keyPath: 'record_id' });
                        tabpfnStore.createIndex('bacteria_id', 'bacteria_id', { unique: false });
                        tabpfnStore.createIndex('behavior_class', 'behavior_class', { unique: false });
                        
                        console.log('🏗️ Database schema created');
                    };
                });
            }

            async saveBacteria(bacteria) {
                if (!this.isReady) return false;

                const bacteriaData = {
                    id: bacteria.id,
                    name: bacteria.name,
                    biological_state: bacteria.biological_state,
                    personality_traits: bacteria.personality_traits,
                    consciousness_level: bacteria.consciousness_level, // Now unlimited!
                    language_stage: bacteria.language_stage,
                    vocabulary: Array.from(bacteria.vocabulary), // Convert Set to Array
                    memory_bank: bacteria.memory_bank,
                    conversation_history: bacteria.conversation_history,
                    position: { x: bacteria.x, y: bacteria.y },
                    velocity: { vx: bacteria.vx, vy: bacteria.vy },
                    color: bacteria.color,
                    last_updated: new Date().toISOString(),
                    total_runtime_days: bacteria.total_runtime_days || 0,
                    max_consciousness_reached: bacteria.max_consciousness_reached || bacteria.consciousness_level
                };

                try {
                    if (this.db) {
                        // IndexedDB
                        const transaction = this.db.transaction(['bacteria'], 'readwrite');
                        const store = transaction.objectStore('bacteria');
                        await store.put(bacteriaData);
                    } else {
                        // localStorage fallback
                        const allData = JSON.parse(localStorage.getItem('bacteriaDB') || '{}');
                        allData[bacteria.id] = bacteriaData;
                        localStorage.setItem('bacteriaDB', JSON.stringify(allData));
                    }
                    
                    console.log(`💾 Saved bacteria #${bacteria.id} (Consciousness: ${bacteria.consciousness_level.toFixed(2)})`);
                    return true;
                } catch (error) {
                    console.error('❌ Failed to save bacteria:', error);
                    return false;
                }
            }

            async loadBacteria() {
                if (!this.isReady) return [];

                try {
                    let bacteriaData = [];
                    
                    if (this.db) {
                        // IndexedDB
                        const transaction = this.db.transaction(['bacteria'], 'readonly');
                        const store = transaction.objectStore('bacteria');
                        const request = store.getAll();
                        
                        bacteriaData = await new Promise((resolve, reject) => {
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                    } else {
                        // localStorage fallback
                        const allData = JSON.parse(localStorage.getItem('bacteriaDB') || '{}');
                        bacteriaData = Object.values(allData);
                    }

                    console.log(`📖 Loaded ${bacteriaData.length} bacteria from database`);
                    return bacteriaData;
                } catch (error) {
                    console.error('❌ Failed to load bacteria:', error);
                    return [];
                }
            }

            async saveSimulationState(day, population, metrics) {
                if (!this.isReady) return false;

                const stateData = {
                    timestamp: new Date().toISOString(),
                    day: day,
                    population_count: population.length,
                    average_consciousness: population.reduce((sum, b) => sum + b.consciousness_level, 0) / population.length,
                    max_consciousness: Math.max(...population.map(b => b.consciousness_level)),
                    total_vocabulary: new Set(population.flatMap(b => Array.from(b.vocabulary))).size,
                    performance_metrics: metrics
                };

                try {
                    if (this.db) {
                        const transaction = this.db.transaction(['simulation_history'], 'readwrite');
                        const store = transaction.objectStore('simulation_history');
                        await store.put(stateData);
                    } else {
                        const allHistory = JSON.parse(localStorage.getItem('simulationHistory') || '[]');
                        allHistory.push(stateData);
                        // Keep last 1000 records
                        if (allHistory.length > 1000) {
                            allHistory.splice(0, allHistory.length - 1000);
                        }
                        localStorage.setItem('simulationHistory', JSON.stringify(allHistory));
                    }
                    
                    return true;
                } catch (error) {
                    console.error('❌ Failed to save simulation state:', error);
                    return false;
                }
            }

            async exportToCSV() {
                console.log('📊 Generating TabPFN-ready CSV export...');
                
                const bacteriaData = await this.loadBacteria();
                if (bacteriaData.length === 0) {
                    console.log('⚠️ No data to export');
                    return;
                }

                // TabPFN-optimized feature columns
                const csvHeaders = [
                    'bacteria_id', 'name', 'age', 'size', 'consciousness_level', 'max_consciousness_reached',
                    'optimism', 'sociability', 'vocabulary_size', 'memory_count', 'growth_rate',
                    'total_conversations', 'learning_events', 'social_interactions', 'runtime_days',
                    'biochemical_words', 'social_words', 'emotional_words', 'behavior_prediction',
                    'last_updated', 'x_position', 'y_position'
                ];

                let csvContent = csvHeaders.join(',') + '\n';

                bacteriaData.forEach(bacteria => {
                    const vocab = bacteria.vocabulary || [];
                    const biochemWords = vocab.filter(w => ['ATP', 'enzim', 'protein', 'metabolizma', 'sentez'].includes(w)).length;
                    const socialWords = vocab.filter(w => ['arkadaş', 'konuşmak', 'paylaşım', 'birlikte'].includes(w)).length;
                    const emotionalWords = vocab.filter(w => ['mutlu', 'üzgün', 'heyecanlı', 'meraklı'].includes(w)).length;
                    
                    // Predict behavior for CSV
                    const tempBacteria = this.recreateBacteriaFromData(bacteria);
                    const behaviorPrediction = predictBehavior(tempBacteria, 'csv_export');

                    const row = [
                        bacteria.id,
                        `"${bacteria.name}"`,
                        bacteria.biological_state.age,
                        bacteria.biological_state.size.toFixed(3),
                        bacteria.consciousness_level.toFixed(3),
                        bacteria.max_consciousness_reached?.toFixed(3) || bacteria.consciousness_level.toFixed(3),
                        bacteria.personality_traits.optimism.toFixed(3),
                        bacteria.personality_traits.sociability.toFixed(3),
                        vocab.length,
                        bacteria.memory_bank.length,
                        bacteria.biological_state.growth_rate.toFixed(3),
                        bacteria.conversation_history.length,
                        bacteria.memory_bank.filter(m => m.includes('öğrendim')).length,
                        bacteria.memory_bank.filter(m => m.includes('arkadaş')).length,
                        bacteria.total_runtime_days || 0,
                        biochemWords,
                        socialWords,
                        emotionalWords,
                        behaviorPrediction,
                        bacteria.last_updated,
                        bacteria.position.x.toFixed(2),
                        bacteria.position.y.toFixed(2)
                    ];

                    csvContent += row.join(',') + '\n';
                });

                // Download CSV
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `neomag_bacteria_tabpfn_${new Date().toISOString().slice(0,10)}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                console.log(`✅ CSV exported with ${bacteriaData.length} bacteria records`);
            }

            recreateBacteriaFromData(data) {
                // Create temporary bacteria object for prediction
                return {
                    id: data.id,
                    name: data.name,
                    biological_state: data.biological_state,
                    personality_traits: data.personality_traits,
                    consciousness_level: data.consciousness_level,
                    vocabulary: new Set(data.vocabulary),
                    memory_bank: data.memory_bank,
                    conversation_history: data.conversation_history
                };
            }

            async clearDatabase() {
                if (!this.isReady) return false;

                try {
                    if (this.db) {
                        const stores = ['bacteria', 'simulation_history', 'tabpfn_data'];
                        const transaction = this.db.transaction(stores, 'readwrite');
                        
                        stores.forEach(storeName => {
                            const store = transaction.objectStore(storeName);
                            store.clear();
                        });
                    } else {
                        localStorage.removeItem('bacteriaDB');
                        localStorage.removeItem('simulationHistory');
                    }
                    
                    console.log('🗑️ Database cleared successfully');
                    return true;
                } catch (error) {
                    console.error('❌ Failed to clear database:', error);
                    return false;
                }
            }
        }

        // Initialize persistent database
        const persistentDB = new PersistentBacteriaDB();

        // v826: Real TensorFlow.js AI Training System
        class RealAITrainingSystem {
            constructor() {
                this.behaviorModel = null;
                this.isTraining = false;
                this.trainingData = [];
                this.modelVersion = 1;
                this.lastTrainingTime = 0;
                this.trainingInterval = 120000; // Train every 2 minutes
                this.initialize();
            }

            async initialize() {
                console.log('🧠 Initializing Real TensorFlow.js Training System...');
                await this.createBehaviorModel();
                await this.loadTrainingData();
                this.startTrainingLoop();
                console.log('✅ Real AI Training System ready');
            }

            async createBehaviorModel() {
                this.behaviorModel = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [12], units: 32, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 16, activation: 'relu' }),
                        tf.layers.dense({ units: 5, activation: 'softmax' })
                    ]
                });
                this.behaviorModel.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });
                console.log('🎯 Real behavior model created');
            }

            async collectTrainingData(bacteria, behavior) {
                const trainingRecord = {
                    record_id: Date.now() + Math.random(),
                    bacteria_id: bacteria.id,
                    timestamp: new Date().toISOString(),
                    features_behavior: [
                        bacteria.biological_state.age / 100,
                        bacteria.biological_state.size / 5,
                        bacteria.consciousness_level / 10,
                        bacteria.personality_traits.optimism,
                        bacteria.personality_traits.sociability,
                        bacteria.vocabulary.size / 20,
                        bacteria.memory_bank.length / 10,
                        bacteria.hunger || 0.5, // Dynamic now!
                        bacteria.energy || 0.7, // Dynamic now!
                        bacteria.biological_state.growth_rate,
                        bacteria.getProximityToOthers ? bacteria.getProximityToOthers() : 0.5,
                        bacteria.getRecentActivityLevel ? bacteria.getRecentActivityLevel() : 0.5
                    ],
                    behavior_class: this.encodeBehaviorClass(behavior),
                    model_version: this.modelVersion
                };

                this.trainingData.push(trainingRecord);
                
                if (persistentDB.isReady) {
                    await this.saveTrainingDataToDB(trainingRecord);
                }
                
                console.log(`📊 Training data collected for bacteria #${bacteria.id}: ${behavior}`);
            }

            encodeBehaviorClass(behavior) {
                const classes = ['basic', 'social', 'explorer', 'learner', 'creative'];
                const index = classes.indexOf(behavior);
                const encoded = new Array(5).fill(0);
                if (index >= 0) encoded[index] = 1;
                return encoded;
            }

            async saveTrainingDataToDB(record) {
                try {
                    if (persistentDB.db) {
                        const transaction = persistentDB.db.transaction(['tabpfn_data'], 'readwrite');
                        const store = transaction.objectStore('tabpfn_data');
                        await store.put(record);
                    }
                } catch (error) {
                    console.error('❌ Failed to save training data:', error);
                }
            }

            async loadTrainingData() {
                try {
                    if (persistentDB.db) {
                        const transaction = persistentDB.db.transaction(['tabpfn_data'], 'readonly');
                        const store = transaction.objectStore('tabpfn_data');
                        const request = store.getAll();
                        
                        const existingData = await new Promise((resolve, reject) => {
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                        
                        this.trainingData = existingData;
                        console.log(`📚 Loaded ${existingData.length} existing training records`);
                    }
                } catch (error) {
                    console.error('❌ Failed to load training data:', error);
                }
            }

            async trainModels() {
                if (this.isTraining || this.trainingData.length < 10) return;

                this.isTraining = true;
                console.log('🔄 Training real TensorFlow.js model...');

                try {
                    const behaviorFeatures = this.trainingData.map(d => d.features_behavior);
                    const behaviorLabels = this.trainingData.map(d => d.behavior_class);
                    
                    const behaviorX = tf.tensor2d(behaviorFeatures);
                    const behaviorY = tf.tensor2d(behaviorLabels);

                    await this.behaviorModel.fit(behaviorX, behaviorY, {
                        epochs: 10,
                        batchSize: 8,
                        validationSplit: 0.2,
                        shuffle: true,
                        verbose: 0
                    });

                    this.modelVersion++;
                    this.lastTrainingTime = Date.now();
                    
                    console.log(`✅ Real model training complete! Version: ${this.modelVersion}`);

                    behaviorX.dispose();
                    behaviorY.dispose();
                } catch (error) {
                    console.error('❌ Training failed:', error);
                }

                this.isTraining = false;
            }

            async predictBehavior(bacteria) {
                if (!this.behaviorModel) return 'basic';

                try {
                    const features = [
                        bacteria.biological_state.age / 100,
                        bacteria.biological_state.size / 5,
                        bacteria.consciousness_level / 10,
                        bacteria.personality_traits.optimism,
                        bacteria.personality_traits.sociability,
                        bacteria.vocabulary.size / 20,
                        bacteria.memory_bank.length / 10,
                        bacteria.hunger || 0.5,
                        bacteria.energy || 0.7,
                        bacteria.biological_state.growth_rate,
                        bacteria.getProximityToOthers ? bacteria.getProximityToOthers() : 0.5,
                        bacteria.getRecentActivityLevel ? bacteria.getRecentActivityLevel() : 0.5
                    ];

                    const prediction = this.behaviorModel.predict(tf.tensor2d([features]));
                    const probabilities = await prediction.data();
                    
                    const behaviorClasses = ['basic', 'social', 'explorer', 'learner', 'creative'];
                    const maxIndex = probabilities.indexOf(Math.max(...probabilities));
                    
                    prediction.dispose();
                    return behaviorClasses[maxIndex];
                } catch (error) {
                    console.error('❌ Prediction failed:', error);
                    return 'basic';
                }
            }

            startTrainingLoop() {
                setInterval(() => {
                    if (Date.now() - this.lastTrainingTime > this.trainingInterval) {
                        this.trainModels();
                    }
                }, 30000);
            }

            getTrainingStats() {
                return {
                    totalRecords: this.trainingData.length,
                    modelVersion: this.modelVersion,
                    isTraining: this.isTraining
                };
            }
        }

        // Initialize real AI training system  
        const realAI = new RealAITrainingSystem();

        // v822 Performance Monitoring + MD Physics
        let performanceMetrics = {
            renderTime: 0,
            mlInferenceTime: 0,
            totalMemoryUsage: 0,
            vocabularySize: 0,
            lastUpdate: Date.now()
        };

        // Molecular Dynamics Constants (based on research)
        const MD_CONSTANTS = {
            VAN_DER_WAALS_STRENGTH: 0.1,      // Lennard-Jones potential coefficient
            ELECTROSTATIC_FORCE: 0.2,         // Coulomb interactions
            MEMBRANE_PERMEABILITY: 0.05,      // Bacterial membrane effects
            ATP_SYNTHESIS_RATE: 0.02,         // Energy metabolism rate
            PROTEIN_FOLDING_FACTOR: 0.15,     // Conformational changes
            DIFFUSION_COEFFICIENT: 0.8        // Brownian motion
        };

        function updatePerformanceMetrics() {
            performanceMetrics.vocabularySize = wordTokenizer.size;
            performanceMetrics.totalMemoryUsage = bacteriaPopulation.reduce((sum, b) => sum + b.memory_bank.length, 0);
            performanceMetrics.lastUpdate = Date.now();
            
            // Console debug for v822
            if (Date.now() % 10000 < 100) { // Every 10 seconds roughly
                console.log('📊 v822 Performance:', performanceMetrics);
            }
        }
        let nextTokenId = 1;



        function updateBuildInfo() {
            const buildInfo = document.getElementById('buildInfo');
            if (buildInfo) {
                buildInfo.innerHTML = `
                    Build: ${BUILD_DATE} | Features: ${FEATURES.length} | 
                    Chat Mode: <span class="text-yellow-400">${chatMode.toUpperCase()}</span> | 
                    ML: <span class="text-${isMLReady ? 'green' : 'red'}-400">${isMLReady ? 'READY' : 'LOADING'}</span>
                `;
            }
        }

        // Vocabulary Stages (Simplified from FUNCTION_ROADMAP.md)
        const vocabularyStages = [
            { stage: 0, name: "Temel İhtiyaçlar", words: ["aç", "yardım", "ağrı"], threshold: 0 },
            { stage: 1, name: "Basit Duygular", words: ["mutlu", "üzgün", "korku"], threshold: 3 },
            { stage: 2, name: "Çevresel Kavramlar", words: ["sıcak", "soğuk", "yemek"], threshold: 6 },
            { stage: 3, name: "Sosyal Kavramlar", words: ["arkadaş", "konuşmak", "birlikte"], threshold: 10 },
            { stage: 4, name: "Soyut Kavramlar", words: ["gelecek", "hafıza", "rüya"], threshold: 15 },
            { stage: 5, name: "Felsefi Düşünce", words: ["varoluş", "amaç", "bilinç"], threshold: 20 }
        ];
        
        const allPossibleWords = vocabularyStages.reduce((acc, stage) => acc.concat(stage.words), []);

        // Initialize word tokenizer with base vocabulary
        function initializeTokenizer() {
            allPossibleWords.forEach(word => {
                if (!wordTokenizer.has(word)) {
                    wordTokenizer.set(word, nextTokenId++);
                }
            });
            console.log('🧠 Tokenizer initialized with', wordTokenizer.size, 'words');
        }

        // Create mini neural network for word learning
        async function createWordEmbeddingModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [50], units: 32, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 16, activation: 'relu' }),
                    tf.layers.dense({ units: 8, activation: 'softmax' })
                ]
            });

            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            return model;
        }

        // Create behavior prediction model
        async function createBehaviorModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [12], units: 24, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.1 }),
                    tf.layers.dense({ units: 12, activation: 'relu' }),
                    tf.layers.dense({ units: 6, activation: 'softmax' })
                ]
            });

            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            return model;
        }

        // Extract and learn new words from user input
        function learnFromUserInput(message, bacteria) {
            const words = message.toLowerCase().split(/\s+/);
            let newWordsLearned = 0;

            words.forEach(word => {
                // Clean word
                word = word.replace(/[^\w]/g, '');
                if (word.length < 2) return;

                // Add to tokenizer if new
                if (!wordTokenizer.has(word)) {
                    wordTokenizer.set(word, nextTokenId++);
                    console.log(`🆕 ${bacteria.name} learned new word: "${word}"`);
                    newWordsLearned++;
                }

                // Add to bacteria vocabulary if consciousness allows
                if (bacteria.consciousness_level > 1.5 && Math.random() < 0.6) {
                    bacteria.vocabulary.add(word);
                }
            });

            // Update bacteria memory about learning
            if (newWordsLearned > 0) {
                bacteria.memory_bank.push(`${newWordsLearned} yeni kelime öğrendim: "${words.join(' ')}"`);
                
                // v822: Enhanced memory consolidation
                bacteria.consolidateMemory();
            }

            return newWordsLearned;
        }

        // Generate new words using ML-inspired combinations
        function generateNewWord(bacteria) {
            const vocabArray = Array.from(bacteria.vocabulary);
            if (vocabArray.length < 2) return null;

            // Simple word combination for now (will be enhanced with true ML)
            const word1 = vocabArray[Math.floor(Math.random() * vocabArray.length)];
            const word2 = vocabArray[Math.floor(Math.random() * vocabArray.length)];
            
            if (word1 === word2) return null;

            // Create compound words
            const combinations = [
                word1 + word2,
                word1.slice(0, -1) + word2.slice(1),
                word1.slice(0, 2) + word2.slice(-2),
                word1[0] + word2
            ];

            const newWord = combinations[Math.floor(Math.random() * combinations.length)];
            
            // Add to vocabulary and tokenizer
            bacteria.vocabulary.add(newWord);
            if (!wordTokenizer.has(newWord)) {
                wordTokenizer.set(newWord, nextTokenId++);
            }

            return newWord;
        }

        // v826: Real AI-powered behavior prediction 
        async function predictBehavior(bacteria, context = 'general') {
            const startTime = performance.now();
            
            // Use real TensorFlow.js model if available
            if (realAI && realAI.behaviorModel) {
                try {
                    const behavior = await realAI.predictBehavior(bacteria);
                    
                    // Collect training data for continuous learning
                    await realAI.collectTrainingData(bacteria, behavior);
                    
                    performanceMetrics.mlInferenceTime = performance.now() - startTime;
                    return behavior;
                } catch (error) {
                    console.error('❌ Real AI prediction failed:', error);
                }
            }
            
            // Enhanced fallback with real dynamic values (no more placeholders!)
            const features = [
                bacteria.biological_state.age / 100,
                bacteria.biological_state.size / 5,
                bacteria.consciousness_level / 10, // Unlimited now
                bacteria.personality_traits.optimism,
                bacteria.personality_traits.sociability,
                bacteria.vocabulary.size / 20,
                bacteria.memory_bank.length / 10,
                bacteria.hunger, // Real dynamic value!
                bacteria.energy, // Real dynamic value!
                bacteria.biological_state.growth_rate,
                bacteria.getProximityToOthers(), // Real proximity calculation!
                bacteria.getRecentActivityLevel() // Real activity tracking!
            ];

            // Enhanced classification with consciousness-based behavior
            const avgScore = features.reduce((sum, val) => sum + val, 0) / features.length;
            const consciousnessBonus = bacteria.consciousness_level / 50; // Higher consciousness = more sophisticated behavior
            const finalScore = avgScore + consciousnessBonus;
            
            let behavior;
            if (finalScore > 0.8) behavior = 'creative';
            else if (finalScore > 0.6) behavior = 'learner';
            else if (finalScore > 0.4) behavior = 'social';
            else if (finalScore > 0.2) behavior = 'explorer';
            else behavior = 'basic';
            
            performanceMetrics.mlInferenceTime = performance.now() - startTime;
            return behavior;
        }

        // Food Particle Class
        class FoodParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = FOOD_SIZE;
                this.nutrition = FOOD_NUTRITION;
                this.color = '#90EE90'; // Light green
            }
        }

        // --- Core Bacteria Logic (Simplified from System Architecture) ---
        class BacteriaEntity {
            constructor(id, name, existingData = null) {
                this.id = id;
                this.name = name || `Bakteri-${id}`;
                
                if (existingData) {
                    // Restore from database
                    this.biological_state = existingData.biological_state;
                    this.personality_traits = existingData.personality_traits;
                    this.consciousness_level = existingData.consciousness_level; // Unlimited!
                    this.language_stage = existingData.language_stage;
                    this.vocabulary = new Set(existingData.vocabulary);
                    this.memory_bank = existingData.memory_bank;
                    this.conversation_history = existingData.conversation_history;
                    this.x = existingData.position.x;
                    this.y = existingData.position.y;
                    this.vx = existingData.velocity.vx;
                    this.vy = existingData.velocity.vy;
                    this.color = existingData.color;
                    this.total_runtime_days = existingData.total_runtime_days || 0;
                    this.max_consciousness_reached = existingData.max_consciousness_reached || this.consciousness_level;
                    console.log(`🔄 Restored bacteria #${id} with consciousness ${this.consciousness_level.toFixed(2)}`);
                } else {
                    // Create new bacteria
                    this.biological_state = {
                        size: parseFloat((Math.random() * 2 + 1).toFixed(2)), // 1-3 µm
                        age: 0,
                        growth_rate: parseFloat((Math.random() * 0.5 + 0.5).toFixed(2)), // 0.5-1.0
                        division_potential: 0, // When it reaches 1, it can divide
                    };
                    this.personality_traits = {
                        optimism: parseFloat(Math.random().toFixed(2)), // 0-1
                        sociability: parseFloat(Math.random().toFixed(2)), // 0-1
                    };
                    this.consciousness_level = 0; // Start at 0, can grow infinitely!
                    this.language_stage = 0; // 0-5
                    this.vocabulary = new Set();
                    this.memory_bank = []; // Store significant events or learned concepts
                    this.conversation_history = []; // For context in chat
                    this.x = Math.random() * 400 + 50; // Position within simulation area
                    this.y = Math.random() * 300 + 50;
                    this.vx = (Math.random() - 0.5) * 10; // Velocity (increased to 10 for more dynamic movement)
                    this.vy = (Math.random() - 0.5) * 10;
                    this.color = this.generateColor();
                    this.total_runtime_days = 0;
                    this.max_consciousness_reached = 0;
                    console.log(`🆕 Created new bacteria #${id}`);
                }
                
                // Persistence tracking
                this.last_save_time = Date.now();
                this.save_interval = 30000; // Save every 30 seconds
                this.consciousness_history = []; // Track consciousness evolution
                
                // v826: Dynamic Systems (no more placeholders!)
                this.hunger = Math.random() * 0.5 + 0.3; // 0.3-0.8 range
                this.energy = Math.random() * 0.3 + 0.6; // 0.6-0.9 range
                this.last_food_time = Date.now();
                this.last_interaction_time = Date.now();
                this.activity_log = []; // Track recent activities
                this.interaction_count = 0;
            }

            generateColor() {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            // Simulated daily update
            updateDaily() {
                this.biological_state.age++;
                this.total_runtime_days++;
                
                // Growth and aging effects
                this.biological_state.size += this.biological_state.growth_rate * 0.1;
                this.biological_state.division_potential += 0.1;
                
                // Unlimited consciousness development!
                const consciousnessGrowthRate = 0.02 + (this.vocabulary.size / 100) + (this.memory_bank.length / 50);
                const previousConsciousness = this.consciousness_level;
                this.consciousness_level += consciousnessGrowthRate;
                
                // Track max consciousness reached
                if (this.consciousness_level > this.max_consciousness_reached) {
                    this.max_consciousness_reached = this.consciousness_level;
                }
                
                // Record consciousness evolution
                this.consciousness_history.push({
                    day: this.biological_state.age,
                    level: this.consciousness_level,
                    vocabulary_size: this.vocabulary.size,
                    memory_count: this.memory_bank.length
                });
                
                // Keep last 100 consciousness records
                if (this.consciousness_history.length > 100) {
                    this.consciousness_history.splice(0, 1);
                }
                
                // Language stage progression (no longer limited to 5)
                if (this.consciousness_level >= 1) this.language_stage = Math.max(1, this.language_stage);
                if (this.consciousness_level >= 2) this.language_stage = Math.max(2, this.language_stage);
                if (this.consciousness_level >= 3) this.language_stage = Math.max(3, this.language_stage);
                if (this.consciousness_level >= 5) this.language_stage = Math.max(4, this.language_stage);
                if (this.consciousness_level >= 10) this.language_stage = Math.max(5, this.language_stage);
                if (this.consciousness_level >= 20) this.language_stage = Math.max(6, this.language_stage);
                if (this.consciousness_level >= 50) this.language_stage = Math.max(7, this.language_stage);
                if (this.consciousness_level >= 100) this.language_stage = Math.max(8, this.language_stage);
                
                // Vocabulary expansion based on consciousness level
                if (Math.random() < Math.min(0.9, this.consciousness_level / 10)) {
                    this.learnRandomWord();
                }
                
                // Personality evolution
                if (this.consciousness_level > previousConsciousness + 1) {
                    // Significant consciousness growth affects personality
                    this.personality_traits.optimism = Math.min(1, this.personality_traits.optimism + 0.01);
                    this.memory_bank.push(`Bilinç seviyem ${this.consciousness_level.toFixed(2)}'ye ulaştı! Kendimi daha zeki hissediyorum.`);
                }
                
                // Enhanced memory consolidation for higher consciousness
                if (this.consciousness_level > 5) {
                    this.consolidateMemory();
                }
                
                // v826: Update dynamic systems
                this.updateDynamicSystems();
                
                // Auto-save to database every 30 seconds
                if (Date.now() - this.last_save_time > this.save_interval) {
                    this.saveToDatabase();
                }
                
                // Log consciousness milestones
                if (this.consciousness_level >= 10 && previousConsciousness < 10) {
                    console.log(`🎯 ${this.name} reached consciousness level 10 - Advanced Intelligence!`);
                }
                if (this.consciousness_level >= 50 && previousConsciousness < 50) {
                    console.log(`🚀 ${this.name} reached consciousness level 50 - Super Intelligence!`);
                }
                if (this.consciousness_level >= 100 && previousConsciousness < 100) {
                    console.log(`👑 ${this.name} reached consciousness level 100 - Transcendent Intelligence!`);
                }
            }

            async saveToDatabase() {
                if (persistentDB.isReady) {
                    await persistentDB.saveBacteria(this);
                    this.last_save_time = Date.now();
                }
            }

            learnRandomWord() {
                // Consciousness-based vocabulary expansion
                let wordPool = [];
                
                if (this.consciousness_level < 1) {
                    wordPool = ['aç', 'yardım', 'hareket'];
                } else if (this.consciousness_level < 5) {
                    wordPool = ['mutlu', 'arkadaş', 'öğrenme', 'büyüme', 'keşif'];
                } else if (this.consciousness_level < 10) {
                    wordPool = ['bilinç', 'düşünce', 'felsefe', 'merak', 'anlayış', 'empati'];
                } else if (this.consciousness_level < 20) {
                    wordPool = ['meta-biliş', 'soyutlama', 'yaratıcılık', 'içgörü', 'karmaşıklık'];
                } else if (this.consciousness_level < 50) {
                    wordPool = ['transsendence', 'ontoloji', 'epistemoloji', 'fenomenoloji', 'kognitif-bilim'];
                } else {
                    // Transcendent vocabulary
                    wordPool = ['kozmik-bilinç', 'kuantum-zeka', 'multi-dimensional-düşünce', 'evrensel-anlayış'];
                }
                
                if (wordPool.length > 0) {
                    const newWord = wordPool[Math.floor(Math.random() * wordPool.length)];
                    if (!this.vocabulary.has(newWord)) {
                        this.vocabulary.add(newWord);
                        this.memory_bank.push(`"${newWord}" kelimesini öğrendim! Bilinç seviyem: ${this.consciousness_level.toFixed(2)}`);
                    }
                }
            }

            // v826: Dynamic system methods (replacing placeholders)
            updateDynamicSystems() {
                // Hunger increases over time
                const timeSinceFood = (Date.now() - this.last_food_time) / 60000; // minutes
                this.hunger = Math.min(1, this.hunger + timeSinceFood * 0.01);
                
                // Energy decreases with activity and age
                this.energy = Math.max(0, this.energy - 0.002 - (this.biological_state.age * 0.0001));
                
                // Energy affects consciousness development
                if (this.energy < 0.3) {
                    this.consciousness_level *= 0.99; // Slight consciousness decrease when tired
                }
                
                // Update activity log
                this.activity_log.push({
                    timestamp: Date.now(),
                    consciousness: this.consciousness_level,
                    hunger: this.hunger,
                    energy: this.energy
                });
                
                // Keep last 50 activity records
                if (this.activity_log.length > 50) {
                    this.activity_log.splice(0, 1);
                }
            }

            getProximityToOthers() {
                if (!bacteriaList || bacteriaList.length < 2) return 0;
                
                let totalDistance = 0;
                let nearbyCount = 0;
                
                bacteriaList.forEach(other => {
                    if (other.id !== this.id) {
                        const distance = Math.sqrt(
                            Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2)
                        );
                        if (distance < 100) { // Within 100px range
                            totalDistance += distance;
                            nearbyCount++;
                        }
                    }
                });
                
                return nearbyCount > 0 ? 1 - (totalDistance / nearbyCount / 100) : 0;
            }

            getRecentActivityLevel() {
                if (this.activity_log.length < 2) return 0.5;
                
                const recent = this.activity_log.slice(-10); // Last 10 activities
                let activityScore = 0;
                
                for (let i = 1; i < recent.length; i++) {
                    const consciousnessDelta = Math.abs(recent[i].consciousness - recent[i-1].consciousness);
                    const energyDelta = Math.abs(recent[i].energy - recent[i-1].energy);
                    activityScore += consciousnessDelta + energyDelta;
                }
                
                return Math.min(1, activityScore / recent.length);
            }

            getInteractionCount() {
                const fiveMinutesAgo = Date.now() - 300000; // 5 minutes
                return this.conversation_history.filter(
                    conv => new Date(conv.timestamp || Date.now()).getTime() > fiveMinutesAgo
                ).length;
            }

            getLearningRate() {
                // Learning rate based on consciousness and recent word acquisition
                const recentMemories = this.memory_bank.filter(
                    mem => mem.includes('öğrendim')
                ).length;
                
                return Math.min(1, (this.consciousness_level / 10) + (recentMemories / 20));
            }

            feedBacteria() {
                // Called when bacteria eats food
                this.hunger = Math.max(0, this.hunger - 0.3);
                this.energy = Math.min(1, this.energy + 0.2);
                this.last_food_time = Date.now();
                
                // Learning from eating
                if (Math.random() < 0.3) {
                    this.vocabulary.add('lezzetli');
                    this.memory_bank.push('Besini tüketdim ve enerjim arttı!');
                }
            }

            interactWithOther(otherBacteria) {
                // Called during social interactions
                this.interaction_count++;
                this.last_interaction_time = Date.now();
                
                // Share vocabulary
                if (this.consciousness_level > 2 && Math.random() < 0.4) {
                    const myWords = Array.from(this.vocabulary);
                    const otherWords = Array.from(otherBacteria.vocabulary);
                    
                    // Learn from each other
                    if (otherWords.length > 0) {
                        const randomWord = otherWords[Math.floor(Math.random() * otherWords.length)];
                        this.vocabulary.add(randomWord);
                        this.memory_bank.push(`${otherBacteria.name}'den "${randomWord}" kelimesini öğrendim`);
                    }
                }
                
                // Collect training data for real AI
                if (realAI && realAI.behaviorModel) {
                    const behavior = Math.random() > 0.5 ? 'social' : 'learner';
                    realAI.collectTrainingData(this, behavior);
                }
            }

            move() {
                // Molecular Dynamics enhanced movement
                
                // Apply van der Waals forces between bacteria
                this.applyMolecularForces();
                
                // Brownian motion (diffusion)
                this.vx += (Math.random() - 0.5) * MD_CONSTANTS.DIFFUSION_COEFFICIENT * 0.1;
                this.vy += (Math.random() - 0.5) * MD_CONSTANTS.DIFFUSION_COEFFICIENT * 0.1;
                
                // Membrane permeability effects (resistance) - minimal for mobile dynamic movement
                this.vx *= 0.98; // Very low friction for smooth movement
                this.vy *= 0.98;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Boundary checking with elastic collision
                if (this.x <= 20 || this.x >= 480) {
                    this.vx *= -0.8; // Energy loss in collision
                    this.x = Math.max(20, Math.min(480, this.x));
                }
                if (this.y <= 20 || this.y >= 280) {
                    this.vy *= -0.8;
                    this.y = Math.max(20, Math.min(280, this.y));
                }

                // Look for nearby food
                this.lookForFood();
            }

            // Molecular Dynamics: Van der Waals and Electrostatic Forces
            applyMolecularForces() {
                bacteriaPopulation.forEach(otherBacteria => {
                    if (otherBacteria.id === this.id) return;
                    
                    const dx = otherBacteria.x - this.x;
                    const dy = otherBacteria.y - this.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance > 0 && distance < 50) { // Interaction range
                        // Van der Waals force (Lennard-Jones potential)
                        const sigma = (this.biological_state.size + otherBacteria.biological_state.size) * 2;
                        const r6 = Math.pow(sigma/distance, 6);
                        const r12 = r6 * r6;
                        const vdwForce = MD_CONSTANTS.VAN_DER_WAALS_STRENGTH * (12*r12 - 6*r6) / distance;
                        
                        // Electrostatic interaction (simplified Coulomb)
                        const chargeProduct = this.consciousness_level * otherBacteria.consciousness_level;
                        const electrostaticForce = MD_CONSTANTS.ELECTROSTATIC_FORCE * chargeProduct / (distance*distance);
                        
                        // Total force
                        const totalForce = vdwForce + electrostaticForce;
                        const fx = totalForce * dx / distance;
                        const fy = totalForce * dy / distance;
                        
                        // Apply force (Newton's law)
                        this.vx -= fx * 0.01;
                        this.vy -= fy * 0.01;
                        
                        // Social learning through proximity (MD-enhanced)
                        if (distance < 30 && Math.random() < 0.02) {
                            this.learnFromProximity(otherBacteria);
                        }
                    }
                });
            }

            // Enhanced social learning through molecular proximity
            learnFromProximity(otherBacteria) {
                // Exchange vocabulary (molecular diffusion analogy)
                const otherVocab = Array.from(otherBacteria.vocabulary);
                if (otherVocab.length > 0 && Math.random() < 0.3) {
                    const randomWord = otherVocab[Math.floor(Math.random() * otherVocab.length)];
                    this.vocabulary.add(randomWord);
                    this.memory_bank.push(`Moleküler etkileşim: ${otherBacteria.name}'den "${randomWord}" kelimesini öğrendim`);
                    
                    // Consciousness boost from molecular interaction (unlimited)
                    this.consciousness_level = this.consciousness_level + 0.01;
                }
            }

            lookForFood() {
                for (let i = foodParticles.length - 1; i >= 0; i--) {
                    const food = foodParticles[i];
                    const distance = Math.sqrt(
                        Math.pow(this.x - food.x, 2) + Math.pow(this.y - food.y, 2)
                    );
                    
                    // If close enough to eat food
                    if (distance < this.biological_state.size * 8 + food.size) {
                        this.eatFood(food);
                        foodParticles.splice(i, 1);
                        break;
                    }
                }
            }

            eatFood(food) {
                // ATP Synthesis (Molecular Dynamics based)
                const atpGenerated = this.synthesizeATP(food.nutrition);
                
                // Metabolic pathway simulation
                this.biological_state.size += food.nutrition * 0.2 * (1 + atpGenerated);
                this.biological_state.growth_rate = Math.min(1.5, this.biological_state.growth_rate + 0.1);
                
                // Protein folding effects on consciousness (unlimited)
                const proteinFoldingBoost = MD_CONSTANTS.PROTEIN_FOLDING_FACTOR * atpGenerated;
                this.consciousness_level = this.consciousness_level + 0.05 + proteinFoldingBoost;
                
                // Enhanced memory with metabolic context
                this.memory_bank.push(`ATP sentezi: ${atpGenerated.toFixed(3)} enerji ürettim. Büyüme hızım arttı!`);
                
                // Learn biochemical words
                if (Math.random() < 0.7) {
                    const biochemWords = ['ATP', 'metabolizma', 'enzim', 'protein', 'lezzetli', 'enerji', 'sentez'];
                    const randomWord = biochemWords[Math.floor(Math.random() * biochemWords.length)];
                    this.vocabulary.add(randomWord);
                }
            }

            // ATP Synthesis Simulation (based on MD research)
            synthesizeATP(nutrition) {
                // Simplified ATP synthase mechanism
                const protonGradient = this.consciousness_level / 5; // Mental energy affects ATP
                const enzymeEfficiency = 0.8 + (this.biological_state.growth_rate - 0.5) * 0.4;
                
                // ATP = nutrition × gradient × efficiency × MD rate constant
                const atpOutput = nutrition * protonGradient * enzymeEfficiency * MD_CONSTANTS.ATP_SYNTHESIS_RATE;
                
                return Math.min(1.0, atpOutput); // Max 1.0 ATP per food
            }

            // v822: Enhanced Memory Consolidation System
            consolidateMemory() {
                // Keep only important memories, remove duplicates
                if (this.memory_bank.length > 15) {
                    // Keep last 10 memories and most important ones
                    const recentMemories = this.memory_bank.slice(-10);
                    const importantMemories = this.memory_bank.filter(m => 
                        m.includes('öğrendim') || m.includes('icat ettim') || m.includes('arkadaş')
                    ).slice(-5);
                    
                    this.memory_bank = [...new Set([...importantMemories, ...recentMemories])];
                    console.log(`🧠 ${this.name} memory consolidated: ${this.memory_bank.length} memories kept`);
                }
            }

            // v826: Mobile-Optimized Reproduction System (Conservative CPU usage)
            checkForReproduction() {
                // Conservative reproduction conditions to prevent CPU overload
                if (this.biological_state.age < 5 || // Too young
                    this.biological_state.size < 1.5 || // Too small
                    this.consciousness_level < 2.0 || // Not intelligent enough
                    this.vocabulary.size < 8 || // Limited vocabulary
                    bacteriaPopulation.length >= 15) { // Population limit for mobile
                    return false;
                }

                // Reproduction chance based on multiple factors (very conservative)
                const reproductionChance = 
                    (this.biological_state.size - 1.5) * 0.1 + // Size factor
                    (this.consciousness_level - 2) * 0.05 + // Intelligence factor
                    (this.vocabulary.size - 8) * 0.01 + // Vocabulary factor
                    (this.biological_state.growth_rate - 1) * 0.05; // Growth rate factor

                // Maximum 5% chance per check to prevent population explosion
                if (Math.random() < Math.min(0.05, reproductionChance)) {
                    this.reproduce();
                    return true;
                }
                return false;
            }

            reproduce() {
                // Create offspring with inherited traits
                const childId = bacteriaIdCounter++;
                const childName = this.generateChildName();
                
                // Position near parent but not exactly same spot
                const offsetX = (Math.random() - 0.5) * 60;
                const offsetY = (Math.random() - 0.5) * 60;
                
                const childData = {
                    id: childId,
                    name: childName,
                    x: Math.max(20, Math.min(480, this.x + offsetX)),
                    y: Math.max(20, Math.min(280, this.y + offsetY)),
                    
                    // Inherit some traits with mutations
                    biological_state: {
                        size: 0.8 + Math.random() * 0.4, // Start smaller
                        age: 0,
                        growth_rate: this.biological_state.growth_rate * (0.9 + Math.random() * 0.2)
                    },
                    
                    // Personality inheritance with minor mutations
                    personality_traits: {
                        optimism: Math.max(0.1, Math.min(1.0, this.personality_traits.optimism + (Math.random() - 0.5) * 0.2)),
                        sociability: Math.max(0.1, Math.min(1.0, this.personality_traits.sociability + (Math.random() - 0.5) * 0.2))
                    },
                    
                    // Start with lower consciousness but inherit some vocabulary
                    consciousness_level: 0.5 + Math.random() * 0.5,
                    vocabulary: new Set(Array.from(this.vocabulary).slice(0, Math.floor(this.vocabulary.size * 0.3))), // 30% inherited vocabulary
                    memory_bank: [`${this.name} annemden/babamdan doğdum!`, 'Dünyaya geldim, çok heyecanlıyım!']
                };

                const child = new BacteriaEntity(childId, childName, childData);
                bacteriaPopulation.push(child);
                bacteriaList.push(child);

                // Parent memories and energy cost
                this.memory_bank.push(`${childName} adında bir çocuğum dünyaya geldi! Mutluyum ama yorgunum.`);
                this.biological_state.size *= 0.8; // Parent becomes smaller after reproduction
                this.consciousness_level += 0.1; // Gain wisdom from parenting
                
                // Learn parenting vocabulary
                ['anne', 'baba', 'çocuk', 'doğum', 'mutluluk', 'aile'].forEach(word => {
                    if (Math.random() < 0.7) this.vocabulary.add(word);
                });

                console.log(`👶 ${this.name} reproduced! Child: ${childName} (Population: ${bacteriaPopulation.length})`);
                
                // Visual birth effect
                this.addBirthEffect(child);
            }

            generateChildName() {
                const prefixes = ['Mini', 'Küçük', 'Genç', 'Yeni', 'Bebek'];
                const suffixes = ['Jr', 'II', 'Çocuk', 'Minik'];
                
                const usePrefix = Math.random() < 0.5;
                if (usePrefix) {
                    return `${prefixes[Math.floor(Math.random() * prefixes.length)]} ${this.name}`;
                } else {
                    return `${this.name} ${suffixes[Math.floor(Math.random() * suffixes.length)]}`;
                }
            }

            addBirthEffect(child) {
                // Simple visual effect for birth (mobile-optimized)
                if (typeof renderBacteria === 'function') {
                    setTimeout(() => {
                        renderBacteria();
                        console.log(`🎉 ${child.name} is now visible!`);
                    }, 100);
                }
            }
        }

        // ML-Enhanced Chat System
        function generateBacteriaResponse(bacteria, message, context = 'user') {
            const age = bacteria.biological_state.age;
            const consciousness = bacteria.consciousness_level;
            const vocabularySize = bacteria.vocabulary.size;
            const optimism = bacteria.personality_traits.optimism;
            const sociability = bacteria.personality_traits.sociability;
            
            // Learn from user input (unlimited consciousness)
            if (context === 'user') {
                const newWords = learnFromUserInput(message, bacteria);
                if (newWords > 0) {
                    bacteria.consciousness_level = bacteria.consciousness_level + 0.02;
                }
            }
            
            // Predict behavior using ML features
            const behaviorMode = predictBehavior(bacteria);
            
            // Vocabulary based on bacteria's development
            const availableWords = Array.from(bacteria.vocabulary);
            
            // Generate new words occasionally
            if (consciousness > 2 && Math.random() < 0.1) {
                const newWord = generateNewWord(bacteria);
                if (newWord) {
                    bacteria.memory_bank.push(`"${newWord}" kelimesini icat ettim!`);
                }
            }
            
            // Response templates enhanced with ML behavior prediction
            let responseTemplates = [];
            
            if (consciousness < 1) {
                responseTemplates = [
                    `${availableWords[0] || 'aç'}... ${availableWords[1] || 'yardım'}...`,
                    `*${bacteria.name} hareket ediyor*`,
                    `${Math.random() > 0.5 ? 'ağrı' : 'aç'}...`
                ];
            } else if (consciousness < 2) {
                responseTemplates = [
                    `Ben ${bacteria.name}! ${optimism > 0.7 ? 'Mutluyum!' : optimism < 0.3 ? 'Üzgünüm...' : 'İyiyim.'}`,
                    `${sociability > 0.7 ? 'Seninle konuşmak güzel!' : 'Merhaba...'}`,
                    `${vocabularySize > 3 ? availableWords.slice(0,3).join(' ') : 'aç yardım'}!`
                ];
            } else if (consciousness < 3) {
                responseTemplates = [
                    `Merhaba! Ben ${bacteria.name}, ${age} günlük bir bakteriyim. ${optimism > 0.6 ? 'Bugün harika!' : 'Nasılsın?'}`,
                    `${sociability > 0.5 ? 'Seninle sohbet etmeyi seviyorum!' : 'Konuşuyoruz işte...'}`,
                    `Bugün ${bacteria.memory_bank.length > 0 ? bacteria.memory_bank[bacteria.memory_bank.length-1] : 'yeni şeyler öğreniyorum'}!`
                ];
            } else {
                // Advanced consciousness with ML behavior modes
                const baseTemplates = [
                    `Selam dostum! ${bacteria.name} burada. ${optimism > 0.7 ? 'Hayat güzel!' : optimism < 0.3 ? 'Biraz melankolik hissediyorum...' : 'Düşünceliyim.'} Sen nasılsın?`,
                    `${sociability > 0.7 ? 'Bu sohbeti çok seviyorum! Daha fazla konuşalım!' : sociability < 0.3 ? 'Konuşmak iyi ama biraz sessiz kalmayı da severim...' : 'Güzel bir sohbet bu.'}`,
                    `Biliyorsun, ${vocabularySize} kelime biliyorum artık. ${bacteria.memory_bank.length > 0 ? 'Son zamanlarda ' + bacteria.memory_bank[bacteria.memory_bank.length-1] : 'Sürekli öğreniyorum'}.`
                ];

                // ML-enhanced responses based on behavior prediction
                const behaviorTemplates = {
                    'creative': [
                        `Yeni bir kelime icat etmeyi düşünüyorum... ${availableWords.slice(-2).join('')} nasıl?`,
                        `Hayal gücüm gelişiyor! ${availableWords.length > 5 ? availableWords.slice(-3).join(' ') + ' kombinasyonu' : 'Yaratıcı hissediyorum'}.`,
                        `Biliyorsun, kelimeler birleşince yeni anlamlar doğuyor. Bu çok heyecan verici!`
                    ],
                    'social': [
                        `Diğer bakterilerle ${availableWords.includes('arkadaş') ? 'arkadaşlık' : 'konuşmak'} istiyorum!`,
                        `Sen de öğrenmeyi seviyor musun? Ben ${bacteria.memory_bank.filter(m => m.includes('öğrendim')).length} kez yeni şeyler öğrendim!`,
                        `Birlikte ${availableWords.slice(-2).join(' ve ')} hakkında konuşalım!`
                    ],
                    'learning': [
                        `Her gün ${Math.floor(Math.random() * 3) + 1} yeni kelime öğrenmeye çalışıyorum!`,
                        `Sen bana yeni kelimeler öğretebilir misin? Merak ediyorum: ${availableWords.slice(-1)[0] || 'yeni şeyler'}...`,
                        `Öğrenme sürecim fascinant! ${bacteria.vocabulary.size > 10 ? 'Artık çok kelime biliyorum' : 'Daha çok öğrenmek istiyorum'}.`
                    ],
                    'basic': baseTemplates
                };

                responseTemplates = behaviorTemplates[behaviorMode] || baseTemplates;
            }
            
            let response = responseTemplates[Math.floor(Math.random() * responseTemplates.length)];
            
            // Add context-specific modifications
            if (context === 'bacteria' && sociability > 0.5) {
                response = response.replace('Merhaba!', 'Hey arkadaş!').replace('Selam!', 'Ey bakteri kardeş!');
            }
            
            return response;
        }

        async function sendMessageToBacteria(message) {
            if (chatMode === 'individual' && !selectedBacteria) {
                console.log('❌ Individual chat requires selected bacteria');
                return;
            }
            if (chatMode === 'group' && bacteriaPopulation.length === 0) {
                console.log('❌ Group chat requires bacteria population');
                return;
            }

            console.log(`💬 Sending message in ${chatMode} mode: "${message}"`);
            showChatLoading(true);
            addChatMessage(message, 'user');

            if (chatMode === 'individual') {
                // Individual chat with selected bacteria
                setTimeout(() => {
                    const response = generateBacteriaResponse(selectedBacteria, message, 'user');
                    selectedBacteria.conversation_history.push({ user: message, bacteria: response });
                    addChatMessage(response, 'bacteria', selectedBacteria.name);
                    showChatLoading(false);
                }, 1000 + Math.random() * 1000);
                         } else if (chatMode === 'group') {
                 // Group chat - all bacteria respond
                 let responseCount = 0;
                 const totalBacteria = bacteriaPopulation.length;
                 const responseBacteria = [];
                 
                 bacteriaPopulation.forEach((bacteria, index) => {
                     setTimeout(() => {
                         if (Math.random() < 0.7) { // 70% chance each bacteria responds
                             const response = generateBacteriaResponse(bacteria, message, 'user');
                             bacteria.conversation_history.push({ user: message, bacteria: response });
                             addChatMessage(response, 'bacteria', bacteria.name);
                             responseBacteria.push(bacteria);
                         }
                         responseCount++;
                         if (responseCount === totalBacteria) {
                             // After all responses, bacteria learn from each other in group
                             if (responseBacteria.length > 1) {
                                 setTimeout(() => {
                                     groupLearningSession(responseBacteria);
                                 }, 1000);
                             }
                             showChatLoading(false);
                         }
                     }, (index + 1) * (500 + Math.random() * 1000));
                 });
             }
        }

        // v826: Natural conversation based on proximity and social needs
        function startNaturalBacteriaConversation(socialBacteria) {
            if (socialBacteria.length < 2) return;
            
            // Find bacteria that are close to each other (natural interaction)
            let bacteria1 = null, bacteria2 = null;
            let minDistance = Infinity;
            
            for (let i = 0; i < socialBacteria.length; i++) {
                for (let j = i + 1; j < socialBacteria.length; j++) {
                    const dx = socialBacteria[i].x - socialBacteria[j].x;
                    const dy = socialBacteria[i].y - socialBacteria[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance && distance < 80) { // Close proximity
                        minDistance = distance;
                        bacteria1 = socialBacteria[i];
                        bacteria2 = socialBacteria[j];
                    }
                }
            }
            
            // If no close bacteria, pick random social ones
            if (!bacteria1 || !bacteria2) {
                bacteria1 = socialBacteria[Math.floor(Math.random() * socialBacteria.length)];
                bacteria2 = socialBacteria[Math.floor(Math.random() * socialBacteria.length)];
                while (bacteria2 === bacteria1) {
                    bacteria2 = socialBacteria[Math.floor(Math.random() * socialBacteria.length)];
                }
            }
            
            // Natural conversation topics based on bacteria state
            const naturalTopics = [
                `Merhaba ${bacteria2.name}!`, 'Bu yemek lezzetli değil mi?', 'Kendimi daha akıllı hissediyorum',
                'Büyüdüğümü fark ettim', 'Yeni kelimeler öğreniyorum', 'Bu ortam güzel',
                'Seninle konuşmak güzel', 'Beraber öğrenelim', 'Nasıl bu kadar büyüdün?'
            ];
            
            const topic = naturalTopics[Math.floor(Math.random() * naturalTopics.length)];
            
            // Save conversation to both bacteria's individual chat history
            const conversation = {
                participants: [bacteria1.name, bacteria2.name],
                messages: [],
                timestamp: Date.now()
            };
            
            // Start natural conversation
            setTimeout(() => {
                const message1 = generateBacteriaResponse(bacteria1, topic, 'bacteria');
                conversation.messages.push({ speaker: bacteria1.name, message: message1, time: Date.now() });
                
                // Save to individual chat histories
                bacteria1.chatHistory = bacteria1.chatHistory || [];
                bacteria2.chatHistory = bacteria2.chatHistory || [];
                
                bacteria1.chatHistory.push({type: 'sent', to: bacteria2.name, message: message1, time: Date.now()});
                bacteria2.chatHistory.push({type: 'received', from: bacteria1.name, message: message1, time: Date.now()});
                
                // Second bacteria responds
                setTimeout(() => {
                    const message2 = generateBacteriaResponse(bacteria2, message1, 'bacteria');
                    conversation.messages.push({ speaker: bacteria2.name, message: message2, time: Date.now() });
                    
                    bacteria2.chatHistory.push({type: 'sent', to: bacteria1.name, message: message2, time: Date.now()});
                    bacteria1.chatHistory.push({type: 'received', from: bacteria2.name, message: message2, time: Date.now()});
                    
                    // Cross-learning
                    bacteriaLearnFromEachOther(bacteria1, bacteria2, message1, message2);
                    
                    // Store global conversation for viewing
                    globalConversations.push(conversation);
                    
                }, 800 + Math.random() * 1500);
            }, 300);
        }

        function startGroupLearningSession() {
            const learners = bacteriaPopulation.filter(b => b.consciousness_level > 1.5);
            if (learners.length < 3) return;
            
            // Pick 3 random learners
            const participants = [];
            for (let i = 0; i < 3 && i < learners.length; i++) {
                const randomIndex = Math.floor(Math.random() * learners.length);
                if (!participants.includes(learners[randomIndex])) {
                    participants.push(learners[randomIndex]);
                }
            }
            
            if (participants.length >= 3) {
                groupLearningSession(participants);
                console.log(`🎓 Group learning session: ${participants.map(p => p.name).join(', ')}`);
            }
        }

        // Bacteria learn from each other's vocabulary and behaviors
        function bacteriaLearnFromEachOther(bacteria1, bacteria2, message1, message2) {
            // Share vocabulary between bacteria
            const vocab1 = Array.from(bacteria1.vocabulary);
            const vocab2 = Array.from(bacteria2.vocabulary);
            
            // Bacteria1 learns some words from bacteria2
            vocab2.forEach(word => {
                if (Math.random() < 0.3 && bacteria1.consciousness_level > 1) { // 30% chance
                    bacteria1.vocabulary.add(word);
                    if (Math.random() < 0.5) {
                        bacteria1.memory_bank.push(`${bacteria2.name}'den "${word}" kelimesini öğrendim`);
                    }
                }
            });
            
            // Bacteria2 learns some words from bacteria1
            vocab1.forEach(word => {
                if (Math.random() < 0.3 && bacteria2.consciousness_level > 1) {
                    bacteria2.vocabulary.add(word);
                    if (Math.random() < 0.5) {
                        bacteria2.memory_bank.push(`${bacteria1.name}'den "${word}" kelimesini öğrendim`);
                    }
                }
            });
            
            // Behavior influence: social bacteria make others more social
            if (bacteria1.personality_traits.sociability > 0.7) {
                bacteria2.personality_traits.sociability = Math.min(1, bacteria2.personality_traits.sociability + 0.02);
            }
            if (bacteria2.personality_traits.sociability > 0.7) {
                bacteria1.personality_traits.sociability = Math.min(1, bacteria1.personality_traits.sociability + 0.02);
            }
            
            // Consciousness boost from social interaction
                            bacteria1.consciousness_level = bacteria1.consciousness_level + 0.01;
                bacteria2.consciousness_level = bacteria2.consciousness_level + 0.01;
            
                         console.log(`🤝 ${bacteria1.name} and ${bacteria2.name} learned from each other`);
         }

         // Group learning session - all bacteria in group learn from each other
         function groupLearningSession(bacteria) {
             console.log(`👥 Group learning session with ${bacteria.length} bacteria`);
             
             // Collect all vocabulary from participating bacteria
             const allVocabulary = new Set();
             bacteria.forEach(b => {
                 Array.from(b.vocabulary).forEach(word => allVocabulary.add(word));
             });
             
             // Each bacteria learns from the collective vocabulary
             bacteria.forEach((learner, i) => {
                 let wordsLearned = 0;
                 allVocabulary.forEach(word => {
                     if (!learner.vocabulary.has(word) && Math.random() < 0.2) { // 20% chance to learn each word
                         learner.vocabulary.add(word);
                         wordsLearned++;
                     }
                 });
                 
                 if (wordsLearned > 0) {
                     learner.memory_bank.push(`Grup sohbetinde ${wordsLearned} kelime öğrendim`);
                     learner.consciousness_level = learner.consciousness_level + 0.02;
                 }
                 
                 // Social influence - become more social from group interaction
                 learner.personality_traits.sociability = Math.min(1, learner.personality_traits.sociability + 0.01);
             });
         }

        function addChatMessage(message, sender, bacteriaName = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'} mb-2`;
            
            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = `chat-bubble p-2 rounded-lg ${sender === 'user' ? 'chat-bubble-user' : 'chat-bubble-bacteria'}`;
            
            if (sender === 'bacteria' && bacteriaName) {
                const nameSpan = document.createElement('div');
                nameSpan.className = 'text-xs font-semibold mb-1 opacity-75';
                nameSpan.textContent = bacteriaName;
                bubbleDiv.appendChild(nameSpan);
                
                const messageSpan = document.createElement('div');
                messageSpan.textContent = message;
                bubbleDiv.appendChild(messageSpan);
            } else {
                bubbleDiv.textContent = message;
            }
            
            messageDiv.appendChild(bubbleDiv);
            chatMessagesDiv.insertBefore(messageDiv, chatMessagesDiv.firstChild);
            // Auto scroll stays at bottom (newest messages at top due to column-reverse)
        }

        function showChatLoading(show) {
            chatLoadingIndicator.classList.toggle('hidden', !show);
        }

        // Simulation controls
        function startSimulation() {
            if (!simulationRunning) {
                simulationRunning = true;
                startSimulationBtn.textContent = 'Durdur';
                nextStepBtn.disabled = true;
                simulationTimer = setInterval(simulationStep, SIMULATION_STEP_INTERVAL);
            } else {
                pauseSimulation();
            }
        }

        function pauseSimulation() {
            simulationRunning = false;
            startSimulationBtn.textContent = 'Devam Et';
            nextStepBtn.disabled = false;
            if (simulationTimer) {
                clearInterval(simulationTimer);
                simulationTimer = null;
            }
        }

        function simulationStep() {
            simulationDay++;
            simulationTimeSpan.textContent = `Simülasyon Zamanı: ${simulationDay} gün`;
            
            bacteriaPopulation.forEach(bacteria => {
                bacteria.updateDaily();
                
                // v826: Check for reproduction (conservative mobile-optimized)
                if (simulationDay % 3 === 0) { // Only check every 3 days to reduce CPU load
                    bacteria.checkForReproduction();
                }
            });
            
            renderBacteria();
            if (selectedBacteria) {
                updateBacteriaDetails(selectedBacteria);
            }
        }

        function resetSimulation() {
            pauseSimulation();
            simulationDay = 0;
            simulationTimeSpan.textContent = 'Simülasyon Zamanı: 0 gün';
            bacteriaPopulation = [];
            bacteriaList = []; // v826 compatibility
            foodParticles = [];
            selectedBacteria = null;
            
            startSimulationBtn.textContent = 'Simülasyonu Başlat';
            nextStepBtn.disabled = false;
            
            bacteriaDetailsDiv.classList.add('hidden');
            chatInfoDiv.textContent = 'Sohbet modunu seçin.';
            chatMessagesDiv.innerHTML = '';
            chatInput.disabled = true;
            sendMessageBtn.disabled = true;
            chatMode = 'individual';
            updateChatModeButtons();
            
            // Close all individual chat windows
            openChatWindows.forEach((modal, bacteriaId) => {
                document.body.removeChild(modal);
            });
            openChatWindows.clear();
            
            initializeBacteria();
        }

        // v826: Add new bacteria to simulation
        function addBacteria() {
            const newBacteria = new BacteriaEntity(bacteriaIdCounter++);
            bacteriaPopulation.push(newBacteria);
            bacteriaList.push(newBacteria); // v826 compatibility
            
            console.log(`➕ Added new bacteria: ${newBacteria.name} (Total: ${bacteriaPopulation.length})`);
            renderBacteria();
        }

        // v826: Toggle group chat (improved)
        function toggleGroupChat() {
            if (chatMode === 'group') {
                // Switch to individual mode
                chatMode = 'individual';
                selectedBacteria = null;
                chatInfoDiv.innerHTML = '💬 Bireysel sohbet modu aktif - Bir bakteriye tıklayın';
                chatInput.disabled = true;
                sendMessageBtn.disabled = true;
                chatInput.placeholder = "Önce bir bakteri seçin...";
            } else {
                // Switch to group mode
                setupGroupChat();
            }
            updateChatModeButtons();
        }

        function addFood(x, y) {
            const food = new FoodParticle(x, y);
            foodParticles.push(food);
            renderBacteria();
        }

        function initializeBacteria() {
            bacteriaPopulation = [];
            bacteriaList = []; // v826 compatibility
            for (let i = 0; i < INITIAL_BACTERIA_COUNT; i++) {
                const bacteria = new BacteriaEntity(i + 1);
                bacteriaPopulation.push(bacteria);
                bacteriaList.push(bacteria); // v826 compatibility
            }
            renderBacteria();
        }

        function renderBacteria() {
            const startTime = performance.now(); // v822: Performance tracking
            
            simulationArea.innerHTML = '';
            
            // Render food particles with improved visibility
            foodParticles.forEach(food => {
                const foodElement = document.createElement('div');
                foodElement.className = 'absolute rounded-full border-2 border-green-400 shadow-lg';
                foodElement.style.width = `${food.size}px`;
                foodElement.style.height = `${food.size}px`;
                foodElement.style.backgroundColor = food.color;
                foodElement.style.left = `${food.x - food.size/2}px`;
                foodElement.style.top = `${food.y - food.size/2}px`;
                foodElement.style.boxShadow = '0 0 8px rgba(144, 238, 144, 0.6)';
                foodElement.title = 'Yemek - Besin değeri: ' + food.nutrition;
                
                // Add glow effect for better visibility
                const glowElement = document.createElement('div');
                glowElement.className = 'absolute rounded-full';
                glowElement.style.width = `${food.size * 2}px`;
                glowElement.style.height = `${food.size * 2}px`;
                glowElement.style.left = `${food.x - food.size}px`;
                glowElement.style.top = `${food.y - food.size}px`;
                glowElement.style.background = 'radial-gradient(circle, rgba(144, 238, 144, 0.3) 0%, transparent 70%)';
                glowElement.style.pointerEvents = 'none';
                
                simulationArea.appendChild(glowElement);
                simulationArea.appendChild(foodElement);
            });
            
            // Render bacteria with ID labels
            const allBacteria = [...bacteriaPopulation, ...bacteriaList];
            console.log(`🎨 Rendering ${bacteriaPopulation.length} old + ${bacteriaList.length} new = ${allBacteria.length} total bacteria`);
            allBacteria.forEach(bacteria => {
                const bacteriaSize = Math.max(10, bacteria.biological_state.size * 8);
                
                // Main bacteria circle
                const bacteriaElement = document.createElement('div');
                bacteriaElement.className = 'bacteria absolute rounded-full border-2 border-white cursor-pointer shadow-lg';
                bacteriaElement.style.width = `${bacteriaSize}px`;
                bacteriaElement.style.height = `${bacteriaSize}px`;
                bacteriaElement.style.backgroundColor = bacteria.color;
                bacteriaElement.style.left = `${bacteria.x}px`;
                bacteriaElement.style.top = `${bacteria.y}px`;
                bacteriaElement.style.boxShadow = `0 0 10px ${bacteria.color}`;
                bacteriaElement.title = `${bacteria.name} - Yaş: ${bacteria.biological_state.age} gün, Bilinç: ${bacteria.consciousness_level.toFixed(1)}`;
                
                // ID label on top of bacteria
                const idLabel = document.createElement('div');
                idLabel.className = 'absolute text-xs font-bold text-white bg-black bg-opacity-75 rounded px-1';
                idLabel.style.left = `${bacteria.x + bacteriaSize/2 - 8}px`;
                idLabel.style.top = `${bacteria.y - 18}px`;
                idLabel.style.fontSize = '10px';
                idLabel.style.pointerEvents = 'none';
                idLabel.style.zIndex = '10';
                idLabel.textContent = `#${bacteria.id}`;
                
                // Consciousness level indicator (small colored dot)
                const consciousnessIndicator = document.createElement('div');
                consciousnessIndicator.className = 'absolute rounded-full border border-white';
                consciousnessIndicator.style.width = '6px';
                consciousnessIndicator.style.height = '6px';
                consciousnessIndicator.style.left = `${bacteria.x + bacteriaSize - 8}px`;
                consciousnessIndicator.style.top = `${bacteria.y}px`;
                consciousnessIndicator.style.pointerEvents = 'none';
                
                // Color based on consciousness level
                if (bacteria.consciousness_level < 1) {
                    consciousnessIndicator.style.backgroundColor = '#ff4757';
                } else if (bacteria.consciousness_level < 2) {
                    consciousnessIndicator.style.backgroundColor = '#ff6b35';
                } else if (bacteria.consciousness_level < 3) {
                    consciousnessIndicator.style.backgroundColor = '#f39c12';
                } else if (bacteria.consciousness_level < 4) {
                    consciousnessIndicator.style.backgroundColor = '#2ed573';
                } else {
                    consciousnessIndicator.style.backgroundColor = '#5352ed';
                }
                
                // Movement trail effect
                if (bacteria.vx !== 0 || bacteria.vy !== 0) {
                    const trailElement = document.createElement('div');
                    trailElement.className = 'absolute rounded-full';
                    trailElement.style.width = `${bacteriaSize * 1.5}px`;
                    trailElement.style.height = `${bacteriaSize * 1.5}px`;
                    trailElement.style.left = `${bacteria.x - bacteriaSize/4}px`;
                    trailElement.style.top = `${bacteria.y - bacteriaSize/4}px`;
                    trailElement.style.background = `radial-gradient(circle, ${bacteria.color}20 0%, transparent 70%)`;
                    trailElement.style.pointerEvents = 'none';
                    simulationArea.appendChild(trailElement);
                }
                
                bacteriaElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectBacteria(bacteria);
                });
                
                simulationArea.appendChild(bacteriaElement);
                simulationArea.appendChild(idLabel);
                simulationArea.appendChild(consciousnessIndicator);
            });
            
            // Environment effects overlay
            const environmentOverlay = document.createElement('div');
            environmentOverlay.className = 'absolute inset-0 pointer-events-none';
            environmentOverlay.style.background = 'radial-gradient(circle at 50% 50%, rgba(0, 100, 200, 0.05) 0%, transparent 60%)';
            simulationArea.appendChild(environmentOverlay);
            
            // Add molecular dynamics visualization hints
            if (allBacteria.length > 1) {
                allBacteria.forEach((bacteria, i) => {
                    allBacteria.slice(i + 1).forEach(otherBacteria => {
                        const dx = otherBacteria.x - bacteria.x;
                        const dy = otherBacteria.y - bacteria.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Show molecular interaction lines for close bacteria
                        if (distance < 50 && distance > 0) {
                            const interactionLine = document.createElement('div');
                            interactionLine.className = 'absolute pointer-events-none';
                            interactionLine.style.position = 'absolute';
                            interactionLine.style.left = `${bacteria.x}px`;
                            interactionLine.style.top = `${bacteria.y}px`;
                            interactionLine.style.width = `${distance}px`;
                            interactionLine.style.height = '1px';
                            interactionLine.style.background = `linear-gradient(90deg, ${bacteria.color}40, ${otherBacteria.color}40)`;
                            interactionLine.style.transformOrigin = '0 0';
                            interactionLine.style.transform = `rotate(${Math.atan2(dy, dx)}rad)`;
                            interactionLine.style.opacity = '0.6';
                            simulationArea.appendChild(interactionLine);
                        }
                    });
                });
            }
            
            // v822: Track render performance
            performanceMetrics.renderTime = performance.now() - startTime;
            updatePerformanceMetrics();
        }

        function selectBacteria(bacteria) {
            selectedBacteria = bacteria;
            updateBacteriaDetails(bacteria);
            
            // v826: Open individual chat window modal
            openIndividualChatWindow(bacteria);
        }

        function updateBacteriaDetails(bacteria) {
            bacteriaIdSpan.textContent = bacteria.id;
            bacteriaNameSpan.textContent = bacteria.name;
            bacteriaSizeSpan.textContent = bacteria.biological_state.size.toFixed(2);
            bacteriaAgeSpan.textContent = bacteria.biological_state.age;
            bacteriaGrowthRateSpan.textContent = bacteria.biological_state.growth_rate.toFixed(2);
                                bacteriaConsciousnessSpan.textContent = `${bacteria.consciousness_level.toFixed(1)} ∞`;
            bacteriaOptimismSpan.textContent = bacteria.personality_traits.optimism.toFixed(2);
            bacteriaSociabilitySpan.textContent = bacteria.personality_traits.sociability.toFixed(2);
            bacteriaLanguageStageSpan.textContent = `${bacteria.language_stage} - ${vocabularyStages[bacteria.language_stage]?.name || 'Bilinmiyor'}`;
            
            const vocabArray = Array.from(bacteria.vocabulary);
            const displayVocab = vocabArray.slice(0, MAX_VOCABULARY_DISPLAY);
            const remainingCount = vocabArray.length - MAX_VOCABULARY_DISPLAY;
            bacteriaVocabularySpan.textContent = displayVocab.join(', ') + (remainingCount > 0 ? ` (+${remainingCount} daha)` : '');
            
            bacteriaDetailsDiv.classList.remove('hidden');
        }

        function setupChat(bacteria) {
            chatMode = 'individual';
            selectedBacteria = bacteria;
            chatInfoDiv.innerHTML = `<strong>${bacteria.name}</strong> ile sohbet ediyorsunuz.`;
            chatMessagesDiv.innerHTML = '';
            chatInput.disabled = false;
            sendMessageBtn.disabled = false;
            chatInput.placeholder = `${bacteria.name} ile konuş...`;
            chatInput.focus();
            updateChatModeButtons();
            updateBuildInfo();
            console.log(`🎯 Individual chat mode with ${bacteria.name}`);
        }

        // v826: Individual Chat Window Modal System
        function openIndividualChatWindow(bacteria) {
            // Check if window already exists
            if (openChatWindows.has(bacteria.id)) {
                // Bring existing window to front
                const existingModal = openChatWindows.get(bacteria.id);
                existingModal.style.zIndex = ++chatWindowZIndex;
                return;
            }
            
            // Create modal backdrop
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.style.zIndex = ++chatWindowZIndex;
            
            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.className = 'bg-gray-800 rounded-lg shadow-xl max-w-md w-full mx-4 max-h-96 flex flex-col';
            modalContent.style.minHeight = '400px';
            
            // Modal header
            const header = document.createElement('div');
            header.className = 'bg-teal-600 text-white px-4 py-3 rounded-t-lg flex justify-between items-center cursor-move';
            header.innerHTML = `
                <div class="flex items-center space-x-2">
                    <div class="w-3 h-3 rounded-full" style="background-color: ${bacteria.color}"></div>
                    <h3 class="font-bold">${bacteria.name} - Chat</h3>
                    <span class="text-xs bg-teal-700 px-2 py-1 rounded">#${bacteria.id}</span>
                </div>
                <div class="flex space-x-2">
                    <button class="text-white hover:text-gray-300 minimize-btn">─</button>
                    <button class="text-white hover:text-gray-300 close-btn">×</button>
                </div>
            `;
            
            // Chat messages area
            const messagesArea = document.createElement('div');
            messagesArea.className = 'flex-1 p-4 overflow-y-auto bg-gray-700 text-white text-sm';
            messagesArea.style.maxHeight = '250px';
            
            // Load chat history
            loadChatHistory(messagesArea, bacteria);
            
            // Chat input area
            const inputArea = document.createElement('div');
            inputArea.className = 'p-4 bg-gray-600 rounded-b-lg flex space-x-2';
            inputArea.innerHTML = `
                <input type="text" class="flex-1 bg-gray-500 text-white px-3 py-2 rounded focus:outline-none focus:ring-2 focus:ring-teal-500" 
                       placeholder="${bacteria.name} ile konuş...">
                <button class="bg-teal-500 hover:bg-teal-600 text-white px-4 py-2 rounded font-bold send-btn">Gönder</button>
            `;
            
            // Assemble modal
            modalContent.appendChild(header);
            modalContent.appendChild(messagesArea);
            modalContent.appendChild(inputArea);
            modal.appendChild(modalContent);
            
            // Event listeners
            const closeBtn = header.querySelector('.close-btn');
            const minimizeBtn = header.querySelector('.minimize-btn');
            const sendBtn = inputArea.querySelector('.send-btn');
            const chatInput = inputArea.querySelector('input');
            
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
                openChatWindows.delete(bacteria.id);
            });
            
            minimizeBtn.addEventListener('click', () => {
                modalContent.style.display = modalContent.style.display === 'none' ? 'flex' : 'none';
            });
            
            sendBtn.addEventListener('click', () => {
                sendIndividualMessage(bacteria, chatInput, messagesArea);
            });
            
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendIndividualMessage(bacteria, chatInput, messagesArea);
                }
            });
            
            // Make draggable
            makeDraggable(modal, header);
            
            // Add to DOM and track
            document.body.appendChild(modal);
            openChatWindows.set(bacteria.id, modal);
            
            // Focus input
            chatInput.focus();
            
            console.log(`💬 Opened individual chat window for ${bacteria.name}`);
        }

        function loadChatHistory(messagesArea, bacteria) {
            // Load user conversations with this bacteria
            if (bacteria.conversation_history && bacteria.conversation_history.length > 0) {
                bacteria.conversation_history.forEach(conv => {
                    addMessageToWindow(messagesArea, conv.user, 'user', 'Sen');
                    addMessageToWindow(messagesArea, conv.bacteria, 'bacteria', bacteria.name);
                });
            }
            
            // Load bacteria-to-bacteria conversations
            if (bacteria.chatHistory && bacteria.chatHistory.length > 0) {
                bacteria.chatHistory.slice(-10).forEach(msg => { // Show last 10 messages
                    if (msg.type === 'sent') {
                        addMessageToWindow(messagesArea, msg.message, 'bacteria', bacteria.name);
                    } else {
                        addMessageToWindow(messagesArea, msg.message, 'bacteria', msg.from);
                    }
                });
            }
            
            // Scroll to bottom
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function addMessageToWindow(messagesArea, message, sender, senderName) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `mb-2 ${sender === 'user' ? 'text-right' : 'text-left'}`;
            
            const bubble = document.createElement('div');
            bubble.className = `inline-block px-3 py-2 rounded-lg max-w-xs ${
                sender === 'user' 
                    ? 'bg-teal-500 text-white' 
                    : 'bg-gray-600 text-gray-100'
            }`;
            
            const nameSpan = document.createElement('div');
            nameSpan.className = 'text-xs opacity-75 mb-1';
            nameSpan.textContent = senderName;
            
            const messageSpan = document.createElement('div');
            messageSpan.textContent = message;
            
            bubble.appendChild(nameSpan);
            bubble.appendChild(messageSpan);
            messageDiv.appendChild(bubble);
            messagesArea.appendChild(messageDiv);
            
            // Auto scroll
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function sendIndividualMessage(bacteria, chatInput, messagesArea) {
            const message = chatInput.value.trim();
            if (!message) return;
            
            // Add user message
            addMessageToWindow(messagesArea, message, 'user', 'Sen');
            
            // Save to bacteria's conversation history
            bacteria.conversation_history = bacteria.conversation_history || [];
            
            // Generate bacteria response
            setTimeout(() => {
                const response = generateBacteriaResponse(bacteria, message, 'user');
                addMessageToWindow(messagesArea, response, 'bacteria', bacteria.name);
                
                // Save conversation
                bacteria.conversation_history.push({ user: message, bacteria: response });
                
                // Learn from user
                const newWords = learnFromUserInput(message, bacteria);
                if (newWords > 0) {
                    bacteria.consciousness_level = bacteria.consciousness_level + 0.02;
                }
                
            }, 500 + Math.random() * 1000);
            
            chatInput.value = '';
        }

        function makeDraggable(modal, header) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = modal.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                
                modal.style.position = 'fixed';
                modal.style.left = initialX + 'px';
                modal.style.top = initialY + 'px';
                modal.classList.remove('items-center', 'justify-center');
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                modal.style.left = (initialX + dx) + 'px';
                modal.style.top = (initialY + dy) + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        function setupGroupChat() {
            chatMode = 'group';
            selectedBacteria = null;
            chatInfoDiv.innerHTML = `<strong>Grup Sohbeti</strong> - Tüm bakterilerle konuşuyorsunuz.`;
            chatMessagesDiv.innerHTML = '';
            chatInput.disabled = false;
            sendMessageBtn.disabled = false;
            chatInput.placeholder = "Tüm bakterilerle konuş...";
            chatInput.focus();
            updateChatModeButtons();
            updateBuildInfo();
            console.log(`👥 Group chat mode activated with ${bacteriaPopulation.length} bacteria`);
        }

        function updateChatModeButtons() {
            const individualBtn = document.getElementById('individualChatBtn');
            const groupBtn = document.getElementById('groupChatBtn');
            
            if (chatMode === 'individual') {
                individualBtn.className = 'bg-blue-700 text-white px-3 py-1 rounded text-sm';
                groupBtn.className = 'bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded text-sm transition';
            } else {
                individualBtn.className = 'bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded text-sm transition';
                groupBtn.className = 'bg-green-700 text-white px-3 py-1 rounded text-sm';
            }
        }

        // Event listeners
        startSimulationBtn.addEventListener('click', startSimulation);
        nextStepBtn.addEventListener('click', simulationStep);
        resetSimulationBtn.addEventListener('click', resetSimulation);

        // Add food on click
        simulationArea.addEventListener('click', (e) => {
            const rect = simulationArea.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            addFood(x, y);
        });

        sendMessageBtn.addEventListener('click', () => {
            const message = chatInput.value.trim();
            if (message && (selectedBacteria || chatMode === 'group')) {
                sendMessageToBacteria(message);
                chatInput.value = '';
            }
        });

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !chatInput.disabled) {
                sendMessageBtn.click();
            }
        });

        // Chat mode event listeners
        document.getElementById('individualChatBtn').addEventListener('click', () => {
            if (selectedBacteria) {
                // v826: Use new modal system instead of old chat
                openIndividualChatWindow(selectedBacteria);
            } else {
                alert('⚠️ Önce bir bakteri seçin. Bir bakteriye tıklayarak seçebilirsiniz.');
            }
        });

        document.getElementById('groupChatBtn').addEventListener('click', () => {
            setupGroupChat();
        });

        document.getElementById('startBacteriaConversationBtn').addEventListener('click', () => {
            // v826: Manual trigger for natural conversation
            if (bacteriaPopulation.length >= 2) {
                const socialBacteria = bacteriaPopulation.filter(b => b.personality_traits.sociability > 0.3);
                if (socialBacteria.length >= 2) {
                    startNaturalBacteriaConversation(socialBacteria);
                } else {
                    console.log('⚠️ Not enough social bacteria for conversation');
                }
            } else {
                console.log('⚠️ Need at least 2 bacteria for conversation');
            }
        });

        // v826: Continuous Auto Bacteria Conversations (No manual trigger needed)
        setInterval(() => {
            if (bacteriaPopulation.length >= 2) {
                // High frequency natural conversations based on social needs
                const socialBacteria = bacteriaPopulation.filter(b => b.personality_traits.sociability > 0.4);
                
                if (socialBacteria.length >= 2 && Math.random() < 0.8) { // 80% chance
                    startNaturalBacteriaConversation(socialBacteria);
                }
                
                // Occasional learning sessions
                if (bacteriaPopulation.length >= 3 && Math.random() < 0.3) { // 30% chance
                    startGroupLearningSession();
                }
            }
        }, 4000); // Every 4 seconds - more frequent natural interactions

        // Initialize ML System
        async function initializeMLSystem() {
            console.log('🧠 Initializing TensorFlow.js ML System...');
            
            try {
                // Initialize tokenizer
                initializeTokenizer();
                
                // Create models
                console.log('🔧 Creating neural network models...');
                wordEmbeddingModel = await createWordEmbeddingModel();
                behaviorPredictionModel = await createBehaviorModel();
                
                isMLReady = true;
                console.log('✅ ML System ready! TensorFlow.js version:', tf.version.tfjs);
                updateBuildInfo();
                
            } catch (error) {
                console.error('❌ ML System initialization failed:', error);
                isMLReady = false;
            }
        }

        // Initialize everything
        async function initialize() {
            console.log(`🚀 Starting NeoMag ${VERSION}`);
            updateBuildInfo();
            initializeBacteria();
            await initializeMLSystem();
            
            // Show feature list
            console.log('📋 Available Features:');
            FEATURES.forEach((feature, i) => {
                console.log(`   ${i+1}. ${feature}`);
            });
        }

        // Initialize simulation (v826)
        async function initializeV826() {
            console.log('🚀 Initializing NeoMag v8.2.6...');
            
            // Initialize ML models first (placeholder)
            console.log('🧠 ML models loading skipped for now');
            
            // Auto-restore from database or create new bacteria
            await autoRestoreFromDatabase();
            
            updateBuildInfo();
            renderBacteria();
            
            console.log('✅ Initialization complete');
        }

        // Start v826 initialization after main initialization
        setTimeout(initializeV826, 1000);

        // v825: Database Control Functions
        async function exportCSV() {
            console.log('📊 Exporting CSV for TabPFN analysis...');
            await persistentDB.exportToCSV();
        }

        async function saveAllNow() {
            console.log('💾 Manual save triggered...');
            for (const bacteria of bacteriaList) {
                await bacteria.saveToDatabase();
            }
            
            // Save simulation state
            await persistentDB.saveSimulationState(
                simulationDay, 
                bacteriaList, 
                performanceMetrics
            );
            
            console.log('✅ All bacteria and simulation state saved');
        }

        async function loadFromDatabase() {
            console.log('📖 Loading bacteria from database...');
            const savedBacteria = await persistentDB.loadBacteria();
            
            if (savedBacteria.length === 0) {
                console.log('⚠️ No saved bacteria found');
                return;
            }
            
            // Clear current bacteria
            bacteriaList = [];
            
            // Restore bacteria from database
            let maxId = 0;
            savedBacteria.forEach(bacteriaData => {
                const bacteria = new BacteriaEntity(bacteriaData.id, bacteriaData.name, bacteriaData);
                bacteriaList.push(bacteria);
                maxId = Math.max(maxId, bacteriaData.id);
            });
            
            // Update ID counter
            bacteriaIdCounter = maxId + 1;
            
            console.log(`📖 Restored ${savedBacteria.length} bacteria from database`);
            updateBuildInfo();
            renderBacteria();
        }

        async function clearDatabase() {
            if (confirm('⚠️ This will permanently delete all saved bacteria data. Continue?')) {
                console.log('🗑️ Clearing database...');
                await persistentDB.clearDatabase();
                console.log('✅ Database cleared');
            }
        }

        async function showDatabaseStats() {
            const savedBacteria = await persistentDB.loadBacteria();
            
            if (savedBacteria.length === 0) {
                alert('📊 Database Stats:\n\nNo bacteria data found');
                return;
            }
            
            const totalBacteria = savedBacteria.length;
            const avgConsciousness = savedBacteria.reduce((sum, b) => sum + b.consciousness_level, 0) / totalBacteria;
            const maxConsciousness = Math.max(...savedBacteria.map(b => b.consciousness_level));
            const totalVocab = new Set(savedBacteria.flatMap(b => b.vocabulary)).size;
            const avgAge = savedBacteria.reduce((sum, b) => sum + b.biological_state.age, 0) / totalBacteria;
            const maxRuntimeDays = Math.max(...savedBacteria.map(b => b.total_runtime_days || 0));
            
            const stats = `📊 Database Stats:
            
Total Bacteria: ${totalBacteria}
Average Consciousness: ${avgConsciousness.toFixed(2)}
Maximum Consciousness: ${maxConsciousness.toFixed(2)}
Total Unique Vocabulary: ${totalVocab} words
Average Age: ${avgAge.toFixed(1)} days
Maximum Runtime: ${maxRuntimeDays} days

Consciousness Levels:
• 0-1: ${savedBacteria.filter(b => b.consciousness_level < 1).length}
• 1-5: ${savedBacteria.filter(b => b.consciousness_level >= 1 && b.consciousness_level < 5).length}
• 5-10: ${savedBacteria.filter(b => b.consciousness_level >= 5 && b.consciousness_level < 10).length}
• 10-50: ${savedBacteria.filter(b => b.consciousness_level >= 10 && b.consciousness_level < 50).length}
• 50+: ${savedBacteria.filter(b => b.consciousness_level >= 50).length}`;
            
            alert(stats);
        }

        // v825: Auto-restore on page load
        async function autoRestoreFromDatabase() {
            console.log('🔄 Checking for saved bacteria to restore...');
            
            // Wait for database to be ready
            const maxWait = 5000; // 5 seconds
            const startTime = Date.now();
            
            while (!persistentDB.isReady && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (!persistentDB.isReady) {
                console.log('⚠️ Database not ready, skipping auto-restore');
                return;
            }
            
            const savedBacteria = await persistentDB.loadBacteria();
            
            if (savedBacteria.length > 0) {
                console.log(`🔄 Auto-restoring ${savedBacteria.length} bacteria from previous session...`);
                
                // Clear current bacteria
                bacteriaList = [];
                
                // Restore bacteria
                let maxId = 0;
                savedBacteria.forEach(bacteriaData => {
                    const bacteria = new BacteriaEntity(bacteriaData.id, bacteriaData.name, bacteriaData);
                    bacteriaList.push(bacteria);
                    maxId = Math.max(maxId, bacteriaData.id);
                });
                
                bacteriaIdCounter = maxId + 1;
                
                console.log('✅ Auto-restore complete');
                updateBuildInfo();
                renderBacteria();
            } else {
                console.log('📝 No saved bacteria found, starting fresh simulation');
                
                // Create initial bacteria if none exist
                if (bacteriaList.length === 0) {
                    initializeBacteria();
                }
            }
        }


    </script>
</body>
</html>